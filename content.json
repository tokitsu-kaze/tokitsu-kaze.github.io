{"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-14","excerpt":""},{"title":"message","text":"","path":"about/index.html","date":"09-23","excerpt":""},{"title":"Category","text":"","path":"categories/index.html","date":"03-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-14","excerpt":""},{"title":"Tag","text":"","path":"tags/index.html","date":"06-20","excerpt":""}],"posts":[{"title":"「艦これ」「2018初秋」抜錨！連合艦隊、西へ！","text":"转载请注明出处：http://tokitsukaze.live/ 目前进度：活动结束。—————————————————作戦準備————————————————— —————————————————前段作戦————————————————— E1 作戦準備！後方兵站線確保E2 海峡奪還作戦E3 西方敵前線泊地を叩け！ ————————————————前段作戦结束———————————————— —————————————————後段作戦————————————————— E4 ジェノヴァの風 E5 全力出撃！新ライン演習作戦 ————————————————后段作戦结束————————————————","path":"2018/09/09/KancolleInvent2018summer/","date":"09-09","excerpt":""},{"title":"ACM-ICPC 2018 沈阳赛区网络预赛 J. Ka Chang (dfs序+树状数组+根号分治)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://nanti.jisuanke.com/t/31451 题意：给一棵有根树，根为1。根的深度为0。每个节点初始值为0。两种操作：1 L X：把深度为L的节点的值增加X。2 X：询问X的子树的和。 题解：做个dfs序，开个树状数组维护。设定阈值sq=sqrt(n)。对于深度L：1.深度为L的节点个数小于等于sq时，我们可以暴力枚举每个节点在树状数组内更新。2.深度为L的节点个数大于sq时，记录这个深度的修改量，查询的时候，遍历有修改过的深度，二分查询有多少个节点在子树中，乘上这个深度的修改量即可。 这么做均摊了一下复杂度，复杂度是根号级别的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Fenwick_Tree&#123; #define type ll type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res; &#125; type query(int l,int r) &#123; return get(r)-get(l-1); &#125; #undef type&#125;tr;VI mp[MAX],h[MAX];ll tag[MAX];int l[MAX],r[MAX],tot,deep[MAX];void dfs(int x,int fa,int dep)&#123; deep[x]=dep; l[x]=++tot; h[dep].pb(l[x]); for(auto to:mp[x]) &#123; if(to==fa) continue; dfs(to,x,dep+1); &#125; r[x]=tot;&#125;void go()&#123; int n,q,i,a,b,op,L; ll x; while(read(n,q)) &#123; for(i=0;i&lt;=n;i++) &#123; h[i].clear(); mp[i].clear(); tag[i]=0; &#125; for(i=1;i&lt;n;i++) &#123; read(a,b); mp[a].pb(b); &#125; tot=0; dfs(1,0,0); for(i=0;i&lt;=n;i++) sort(all(h[i])); tr.init(n); int sq=sqrt(n+0.5); set&lt;int&gt; s; while(q--) &#123; read(op); if(op==1) &#123; read(L,x); if(L&gt;n) continue; if(sz(h[L])&lt;=sq) &#123; for(auto it:h[L]) &#123; tr.insert(it,x); &#125; &#125; else &#123; s.insert(L); tag[L]+=x; &#125; &#125; else &#123; read(x); ll ans=tr.query(l[x],r[x]); for(auto it:s) &#123; if(it&lt;deep[x]) continue; int tl,tr; tr=upper_bound(all(h[it]),r[x])-h[it].begin(); tl=lower_bound(all(h[it]),l[x])-h[it].begin(); ans+=tag[it]*(tr-tl); &#125; printf(\"%lld\\n\",ans); &#125; &#125; &#125;&#125;","path":"2018/09/09/2018shenyangonline.J/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E5 全力出撃！新ライン演習作戦","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E5甲 注意：1.P1贴蓝条，P2贴紫条，P3只能用蓝条或者紫条，不能混用。2.？表示不确定P1 路线：道中2战1鱼(1空袭)。 配置：机动。我的配置是要打空袭的，空袭很菜，不需要刻意回避。全高速回避空袭？(划掉，好像还有其他条件)。厌战有倍卡。方舟带剑鱼有倍卡？ 支援：双支援。 路航：两队13丢boss，一队防空。 P2 路线：2战1鱼。 配置：水打。T-&gt;R条件：海外船&gt;=6？Q-&gt;P条件：bb&lt;=2 支援：双支援。 路航：两队13丢boss，另一队可以选择炸鱼，斩杀时必须13/04丢boss。 P3 开路阶段： 1.H，I点S胜。用P1配置即可。 此时开出boss点。 2.S，T点S胜+守家白字2次。配置：水打一队3bb2ca1cv 二队炸鱼。T-&gt;S：海外船&lt;6？ 3.K点空袭空优两次。用P2配置，一队3bb可以进k，一队ca换个cav背水战。路航压制k，航程4。 开出Z3。开路完成。 削甲/攻略阶段： 1.磨血，进斩杀线。配置：我用的是水打，走的不是最短路。猜测M-&gt;X条件为bb&lt;=2。X-&gt;Z3条件为一队吨位轻，cl+cvl可以走，否则走Y(Y为普通战斗)。参考配置：P3水打磨血参考配置。此配置路线为X-&gt;Z3。 2.进斩杀线后，水打进bossA胜。参考配置：P3水打斩杀参考配置。此配置路线为X-&gt;Z3。 3.进斩杀线后，机动进bossA胜。参考配置：P3机动斩杀参考配置。此配置路线为X-&gt;Y。此配置的2bb换成1cl1dd，路线为X-&gt;Z3？ 4.z3空优？(我没有这一步，削甲就成功了，所以没有配置。) 5.斩杀。削完甲就随便打了，机动水打都行。懒得换水打，直接机动两把斩了。 支援：双支援。 路航：三队13飞boss，航程7。 注意：斩杀制空要求大概490左右。(削甲后貌似低了点？机动410出门，boss能空优。) 奖励：勋章*2，螺丝*10，KMX熟练*1，Mk.I+FCR*1，甲章*1。新船：Nelson。 P1 P1参考配置： P2 P2参考配置： P3 磨血： 削甲前的斩杀： 削甲后斩杀： P3水打： 路线： 磨血参考配置： 斩杀参考配置： P3机动： 路线： 磨血参考配置：无。 斩杀参考配置：","path":"2018/09/09/KancolleInvent2018summerE5/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E4 ジェノヴァの風","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ e4甲 P1运输 路线：道中2战/3战。 配置：运输一队1av+大鹰+4大发dd 二队1cl+libeccio+zara/pola+3dd。出门随机？个人配置制空190，道中I概率空优，boss空优线比这低。 支援：道中。 路航：13或者04。 P2 开路阶段： 1.R点S胜。配置：2bb2cv2dd。R点是鱼，2dd开幕反潜。 2.O点A胜。配置：2bb1cv1ca2dd。O点是陆基。 此时开出S点和boss点。 3.S点A胜。配置：水打一队2bb2ca1dd1cv 二队随意。道中有潜水鸡，二队可以带点开幕反潜。 此时开出门神V点(红雷，概率单纵..)，开路结束。 注意：开路用的bb和ca都是意大利级。cv用的是Aquila和云龙级。 攻略阶段： 路线：道中2战2空袭。 配置：意大利+罗马+zara+Aquila+2dd。boss不是陆基，一个dd打ci。boss点配置有个集地，一个dd赛艇，可以三件套，也可以2炮+11连队(boss点有个pt，洞里塞机枪打pt)。带340而不是910的原因是夜战可能会被集地吸火力，910打不动。 支援：道中随意，决战最好上一下。 路航：04洗boss，注意航程9。 奖励：勋章*1，女神*3，打洞*1，Bofors15.2 +5 *1，Osprey +5 *1,。新船：Maestrale。 P1： P1参考配置： P2： 开路阶段： 1.R点S胜参考配置： 2.O点A胜参考配置： 3.S点A胜参考配置： 攻略阶段： 参考配置：","path":"2018/09/09/KancolleInvent2018summerE4/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E3 西方敵前線泊地を叩け！","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E3甲 P1 路线：道中2战，门神屌阵怂不过就单纵干。 配置：1bb1cav1cv1cl2dd，出门制空160左右。 支援：道中。 路航：两队04丢boss。 P2 路线：道中2战1鱼。 配置：机动一队1bb2cv1ca2cav 二队1cl1ca2clt2dd，出门制空420左右。 支援：道中。 路航：路航两队04丢boss，注意航程是9。 P3 路线：同P2。 配置：机动一队双龙吃撑1cav1ca1ssv 二队同P2，cav4水战，ssv提速2水战。出门制空510左右，若路航是两队04，则需要更高。 支援：道中，斩杀上个决战。 路航：一队大艇拖64队+54队+34型，二队同P2。 奖励：勋章*1，详报*1，97舰攻931空熟练*1，JU87改二 *1，新船：神鹰。 P1 P1参考配置： P2 P2参考配置： P3 P3参考配置：","path":"2018/09/09/KancolleInvent2018summerE3/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E2 海峡奪還作戦","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E2甲 P1运输 路线：道中2战，继续屌阵怂过去，无需支援，路航04丢boss，对面无制空。 配置：1ca1cav4dd，cacav正常配装，dd全赛艇，门神索敌沟，索敌大约16能进。 P2 路线：道中2战1空袭，无需支援，路航04丢boss。 配置：1bb1cav1cvl3dd，2dd三件套，1dd打飞机，出门制空150左右。 奖励：甲板*1，伊良湖*3，间宫*3，油桶*3，12.7B型改四(战时改修)+高射装置*1，水侦11型乙(熟练)*1 P1 P1参考配置： P2 P2参考配置：","path":"2018/09/09/KancolleInvent2018summerE2/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E1 作戦準備！後方兵站線確保","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E1甲 路线：道中2战，屌阵怂过去。无需支援。 配置：1cl4dd全对潜，5船回避H(漩涡)，斩杀有困难可上6船。 奖励：职人*1，饭团*2，22改四后期型*1，火箭弹*1，大发*1，内火*1","path":"2018/09/09/KancolleInvent2018summerE1/","date":"09-09","excerpt":""},{"title":"hdu 6447 YJJ's Salesman (dp+树状数组)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6447 题意：从 (0,0) 往 (1e9,1e9)走，每次只能从 (x,y)走到 (x+1,y) 或者 (x,y+1)或者 (x+1,y+1)。某些点(x,y)有价值v，当且仅当从 (x−1,y−1)走到(x,y)时，才能获得v，求获得的价值总和最大是多少。 题解：点只有1e5个。dp[i]表示走到第i个点能获得的最大价值。转移：dp[i]=max(dp[j])+v[i]，需要满足条件x[j]&lt;=x[i]-1且y[j]&lt;=y[i]-1。 对x进行从小到大sort，然后扫描线扫过去。这样保证了转移的第一个条件。 对y离散化一下，开一个树状数组，下标表示y。每次通过树状数组查询前缀最大值进行dp转移。转移之后把dp值插入树状数组。这样保证了转移的第二个条件。 注意：因为x[j]&lt;=x[i]-1，所以当x相同的时候，dp转移完不能马上插入树状数组，马上插入的话会导致转移条件变为x[j]&lt;=x[i]，这样就错了。所以当x相同的时候，我们先开个vector存放一下，等到碰到不同的x的时候，再全部一起插入。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=3.1415926;const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Fenwick_Tree&#123; #define type int type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]=max(bit[x],v); x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res=max(res,bit[x]); x-=lowbit(x); &#125; return res; &#125; #undef type&#125;tr;struct node&#123; int x,y,v; node()&#123;&#125; friend bool operator &lt;(node a,node b)&#123;return a.x&lt;b.x;&#125; void input()&#123;read(x,y,v);&#125;&#125;a[MAX];int y[MAX];void go()&#123; int t,i,n,tot,ans; read(t); while(t--) &#123; read(n); for(i=0;i&lt;n;i++) &#123; a[i].input(); y[i]=a[i].y; &#125; sort(a,a+n); sort(y,y+n); tot=unique(y,y+n)-y; tr.init(tot+5); ans=-INF; VI tmp; for(i=0;i&lt;n;i++) &#123; a[i].y=lower_bound(y,y+tot,a[i].y)-y+1; if(sz(tmp)&amp;&amp;a[i].x!=a[tmp[0]].x) &#123; for(auto &amp;j:tmp) tr.insert(a[j].y+1,a[j].v); tmp.clear(); &#125; a[i].v+=tr.get(a[i].y); ans=max(ans,a[i].v); tmp.pb(i); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/28/hdu6447/","date":"08-28","excerpt":""},{"title":"hdu 6444 Neko's loop (单调队列)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6444 题意：给出一个 n 个元素的环、可以任意选择起点、选完起点后、可以行走 m 步、每次前进 k 个单位、所走到的点将产生正或负贡献、问你一开始得准备多少才能使得初始资金加上在环上获取最大利益不少于给定的 s。 题解：其实就是找走m步的途中获得的最大值mx。如果大于等于s，ans=0，否则ans=s-mx。先暴力把每个环找出来。对于每个环，我们考虑以下几个事情：1.找到环的最优起点。2.m步可以走很多次环。如果整个环的贡献为正，那么多的环的贡献就直接乘一下加进来，如果为负，可以只选择从最优起点开始走，或者甚至不走。 那么如何找到环的最优起点。其实这个问题就是找一个和最大的连续子序列且长度不超过len，len为单独考虑的步数。那么我们可以先做前缀和，数组为bit，问题就变成求bit[i]-bit[j-1]的最大值，且i-j+1&lt;=len。然后控制窗口长度为len，进行滑窗，对于每个j-1，用单调队列来维护bit[i]的最大值，所以应该倒着for。代码中维护的窗口长度是len+1，这样就变成求bit[i]-bit[j]的最大值，会好写一点。注意bit[0]=0，而且碰到bit[0]时默认入队，因为bit[1]可能是负的，所以这里要特判一下。 对于len的选取： 首先有一种情况是这样的：5 100 12 1-10 1 2 3 5整个环的贡献是+1。最优走法肯定是：-10 {1 2 3 5}如果我们选择2个整环+2步的话(len=2)，最大值只能达到10。但如果我们选择1个整环+7步的话(len=7)，最大值可以达到12。走法：-10 {1 2 3 5，-10 1 2 3 5} 然后我的写法会出现第二种情况：6 100 12 51 2 3 4 -5 6整个环的贡献是+11。如果我们选择2个整环+0步(len=0)，最大值只能达到22。但如果我们选择1个整环+6步(len=6)，最大值可以达到27。但是走法是这样的：1 2 3 4 -5 {6 ，1 2 3 4 -5 6 ，1 2 3 4} -5 6跨越了3个环。所以对于我这种写法，这里的len要取12。要把环的数组复制3遍后再做前缀和。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=3.1415926;const double eps=1e-6;const int MAX=3e4+10;const ll mod=1e9+7;/********************************* head *********************************/ll res[MAX],tmp[MAX],a[MAX],bit[MAX],dq[MAX];int flag[MAX],tot;ll n,s,m,k;void gao(int pos)&#123; int i,j,tag=pos+1,top=0,len; ll cnt; for(i=pos;flag[i]!=tag;i=(i+k)%n) &#123; tmp[++top]=a[i]; flag[i]=tag; &#125; for(i=1;i&lt;=top;i++) tmp[i+top]=tmp[i+top*2]=tmp[i]; cnt=m/top; len=m%top; if(!len&amp;&amp;cnt) &#123; len=top; cnt--; &#125; if(cnt) &#123; cnt--; len+=top; &#125; top=top*3; res[++tot]=0; bit[0]=0; for(i=1;i&lt;=top;i++) bit[i]=bit[i-1]+tmp[i]; int l,r; l=r=0; for(i=j=top;i;i--) &#123; while(~j&amp;&amp;i-j&lt;=len) &#123; while(r-l&amp;&amp;j&amp;&amp;bit[dq[r-1]]&lt;bit[j]) r--; dq[r++]=j--; &#125; while(r-l&amp;&amp;dq[l]&gt;i) l++; res[tot]=max(res[tot],bit[dq[l]]-bit[dq[r-1]]); &#125; if(bit[top/3]&gt;=0) res[tot]+=bit[top/3]*cnt;&#125;void go()&#123; int t,cas=1,i; read(t); while(t--) &#123; read(n,s,m,k); for(i=0;i&lt;n;i++) read(a[i]); mem(flag,0); tot=0; for(i=0;i&lt;n;i++) &#123; if(flag[i]) continue; gao(i); &#125; ll ans=-LLINF; for(i=1;i&lt;=tot;i++) ans=max(ans,res[i]); printf(\"Case #%d: %lld\\n\",cas++,max(0LL,s-ans)); &#125;&#125;/*25 100 12 1-10 1 2 3 56 100 12 51 2 3 4 -5 6ans:8873*/","path":"2018/08/27/hdu6444/","date":"08-27","excerpt":""},{"title":"hdu 6438 Buy and Resell (贪心)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6438 题意：在一个数轴上有n个点，为1到n。每个点上有个值v。你可以在一个点上选择：买入一个商品花费v，卖出一个商品赚取v(如果手持有商品的话)，什么都不干。问从1走到n最多赚多少，在保证赚取最多的情况下，输出最少的交易次数。 题解：用优先队列维护一个结构体{v,cnt}。v表示某个点的价值，cnt表示那个点是不是卖出点。优先队列先出v小的，v相同先出cnt=1的。因为要求交易次数最少，价格相同时，把卖出点作为中转点，先出队，就能满足这个要求。每次走到一个点，如果点的价值v比优先队列中最小值大，就更新答案，然后推入{v,1}。然后每个点固定推入{v,0}。最后统计优先队列中cnt=1的个数*2就是最少交易次数。 比如：1 2 5。第1个点：入{1,0}第2个点：出{1,0}，ans+=2-1=1，入{2,1}，入{2,0}。第3个点：出{2,1}，ans+=5-2=4，入{5,1}，入{5,0}。最后优先队列中有：{2,0}，{5,1}，{5,0}。最少交易次数为2。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct node&#123; ll v,cnt; node()&#123;&#125; node(ll _v,ll _cnt):v(_v),cnt(_cnt)&#123;&#125; friend bool operator &lt;(node a,node b) &#123; if(a.v==b.v) return a.cnt&lt;b.cnt; return a.v&gt;b.v; &#125;&#125;;ll a[MAX];void go()&#123; int t,n,i; ll ans,cnt; node tmp; read(t); while(t--) &#123; read(n); for(i=0;i&lt;n;i++) read(a[i]); ans=0; priority_queue&lt;node&gt; q; for(i=0;i&lt;n;i++) &#123; if(sz(q)) &#123; tmp=q.top(); if(tmp.v&lt;a[i]) &#123; q.pop(); ans+=a[i]-tmp.v; q.push(node(a[i],1)); &#125; &#125; q.push(node(a[i],0)); &#125; cnt=0; while(!q.empty()) &#123; cnt+=(q.top()).cnt; q.pop(); &#125; printf(\"%lld %lld\\n\",ans,cnt*2); &#125;&#125;","path":"2018/08/26/hdu6438/","date":"08-26","excerpt":""},{"title":"hdu 6441 Find Integer (费马大定理)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6441 题意：a^n+b^n=c^n，现在给出n和a，输出一组b，c的正整数解，无解输出-1 -1。 题解：由费马大定理可知，n&gt;2无正整数解。又易知，n=0时也无正整数解。n=1时必有正整数解，任意输出一组可行解即可。n=2时，使用费马大定理的”a值奇偶数列法则”求解。“a值奇偶数列法则”：1.当a为奇数时，b=c-1。2.当a为偶数时，b=c-2。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/void go()&#123; int t; ll n,a,b,c; read(t); while(t--) &#123; read(n,a); if(n&gt;2||n==0) &#123; puts(\"-1 -1\"); continue; &#125; if(n==1) &#123; b=1; c=a+1; printf(\"%lld %lld\\n\",b,c); &#125; else if(n==2) &#123; if(a&amp;1) &#123; b=a*a/2; c=b+1; &#125; else &#123; b=a*a/4-1; c=b+2; &#125; if(b&gt;1000000000||c&gt;1000000000) puts(\"-1 -1\"); else printf(\"%lld %lld\\n\",b,c); &#125; &#125;&#125;","path":"2018/08/26/hdu6441/","date":"08-26","excerpt":""},{"title":"Codeforces edu#49 F. Session in BSU","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1027/F 题意：给n条边，每个点的编号范围[1,1e9]，求一个点集，使每条边至少有一个点在这个点集里，求点集中最大编号最小。不可行输出-1。 题解：对于一个连通块：1.如果没有环，其实就是树，取次大的点。2.如果只有1个环，其实就是基环树，取最大的点。3.如果有2个以上的环，直接输出-1。 先对点离散化，然后用并查集搞搞，判每个连通块有几个环。如果可行，对每个连通块判断是情况1还是情况2，然后取max就是答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e6+10;const ll mod=1e9+7;/********************************* head *********************************/struct dsu&#123; int pre[MAX]; void init(int n) &#123; int i; for(i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; &#125; int find(int x) &#123; if(pre[x]!=x) pre[x]=find(pre[x]); return pre[x]; &#125; int merge(int a,int b) &#123; int ra,rb; ra=find(a); rb=find(b); if(ra!=rb) pre[ra]=rb; if(ra!=rb) return 0; else return ra; &#125;&#125;dsu;int cnt[MAX],v[MAX],belong[MAX];priority_queue&lt;int&gt; q[MAX];void go()&#123; int n,i,a,b,tot,tmp,ans,flag; while(read(n)) &#123; tot=0; hash_map&lt;int,int&gt; mp; dsu.init(2*n); for(i=1;i&lt;=2*n;i++) belong[i]=cnt[i]=0; for(i=1;i&lt;=n;i++) &#123; read(a,b); if(!mp[a]) &#123; mp[a]=++tot; v[tot]=a; &#125; a=mp[a]; if(!mp[b]) &#123; mp[b]=++tot; v[tot]=b; &#125; b=mp[b]; tmp=dsu.merge(a,b); if(tmp) belong[tmp]++; &#125; for(i=1;i&lt;=tot;i++) cnt[dsu.find(i)]+=belong[i]; flag=0; for(i=1;i&lt;=tot;i++) &#123; if(cnt[i]&gt;=2) flag=1; while(!q[i].empty()) q[i].pop(); &#125; if(flag) &#123; puts(\"-1\"); continue; &#125; ans=0; for(i=1;i&lt;=tot;i++) &#123; tmp=dsu.find(i); if(sz(q[tmp])&lt;2) q[tmp].push(-v[i]); else &#123; if(v[i]&gt;-q[tmp].top()) &#123; q[tmp].pop(); q[tmp].push(-v[i]); &#125; &#125; &#125; for(int it=1;it&lt;=tot;it++) &#123; if(sz(q[it])==0) continue; tmp=q[it].top(); q[it].pop(); if(cnt[it]==0) &#123; if(sz(q[it])&gt;=1) ans=max(ans,-tmp); else ans=max(ans,-q[it].top()); &#125; else if(cnt[it]==1) ans=max(ans,-q[it].top()); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/25/cfedu49.F/","date":"08-25","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第九场）G.Longest Common Subsequence (kd-tree)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/147/G 题意：给4个长度为n的数组a,b,c,d，求LCS。数字范围在[1,n]，其中a,b,c中的相同数字不超过2个。 题解：对于每种数字在a,b,c,d中的下标，可以看成一组点(pa,pb,pc,pd)，这样就把LCS转换成了下标的LIS。然后这个是一个四维偏序。我们可以从小到大枚举d数组，这样保证了pd是严格递增的，所以变成三维偏序。因为a,b,c中的相同数字不超过2个，所以点(pa,pb,pc)的个数最多为8n。假设dp[i]表示选第i个点的LIS值，有转移：dp[i]=d[j]+1 其中(pa[j]&lt;pa[i]&amp;&amp;pb[j]&lt;pb[i]&amp;&amp;pb[j]&lt;pb[i])。我们把dp[i]当做点(pa[i],pb[i],pc[i])的值插入kd-tree，然后每次转移从kd-tree里查询即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=8e4+10;const ll mod=1e9+7;/********************************* head *********************************/namespace kd_tree&#123; const double alpha=0.75; const int dim=3; #define type int struct kdtnode &#123; type x[dim],mx[dim],mn[dim],v,sum; int l,r,sz; kdtnode()&#123;&#125; void initval() &#123; sz=1;sum=v; for(int i=0;i&lt;dim;i++) mn[i]=mx[i]=x[i]; &#125; void init(type val)&#123;l=r=0;v=val;initval();&#125; void set(int a,int b,int c,type d=0)&#123;x[0]=a,x[1]=b,x[2]=c;init(d);&#125; kdtnode(int a,int b,int c,type d=0)&#123;set(a,b,c,d);&#125; &#125;; struct KDT &#123; #define ls t[id].l #define rs t[id].r kdtnode t[MAX]; int tot,idx,root; inline void pushup(int id) &#123; t[id].initval(); t[id].sz=t[ls].sz+t[rs].sz+1; if(ls) t[id].sum=max(t[id].sum,t[ls].sum); if(rs) t[id].sum=max(t[id].sum,t[rs].sum); for(int i=0;i&lt;dim;i++) &#123; if(ls) &#123; t[id].mx[i]=max(t[id].mx[i],t[ls].mx[i]); t[id].mn[i]=min(t[id].mn[i],t[ls].mn[i]); &#125; if(rs) &#123; t[id].mx[i]=max(t[id].mx[i],t[rs].mx[i]); t[id].mn[i]=min(t[id].mn[i],t[rs].mn[i]); &#125; &#125; &#125; int st[MAX],top; void build(int &amp;id,int l,int r,int dep=0) &#123; id=0;if(l&gt;r) return; int m=(l+r)&gt;&gt;1; idx=dep; nth_element(st+l,st+m,st+r+1,[&amp;](int x,int y)&#123;return t[x].x[idx]&lt;t[y].x[idx];&#125;); id=st[m]; build(ls,l,m-1,(dep+1)%dim); build(rs,m+1,r,(dep+1)%dim); pushup(id); &#125; inline void init(int n=0) &#123; root=0; t[0].sz=0; for(int i=0;i&lt;dim;i++) &#123; t[0].mx[i]=-INF; t[0].mn[i]=INF; &#125; for(int i=1;i&lt;=n;i++) st[i]=i; if(n) build(root,1,n); tot=n+1; &#125; void travel(int id) &#123; if(!id) return; st[++top]=id; travel(ls); travel(rs); &#125; void rebuild(int &amp;id,int dep) &#123; top=0;travel(id); build(id,1,top,dep); &#125; void insert(int &amp;id,int now,int dep=0) &#123; if(!id)&#123;id=now;return;&#125; idx=dep; if(t[now].x[idx]&lt;t[id].x[idx]) insert(ls,now,(dep+1)%dim); else insert(rs,now,(dep+1)%dim); pushup(id); if(t[id].sz*alpha+3&lt;max(t[ls].sz,t[rs].sz)) rebuild(id,dep); &#125; inline void insert(kdtnode &amp;x)&#123;t[++tot]=x;insert(root,tot);&#125; kdtnode q; inline int check(kdtnode &amp;x) &#123; int ok=1; for(int i=0;i&lt;dim;i++) ok&amp;=(x.x[i]&lt;=q.x[i]); return ok; &#125; inline int allin(kdtnode &amp;x) &#123; int ok=1; for(int i=0;i&lt;dim;i++) ok&amp;=(x.mx[i]&lt;=q.x[i]); return ok; &#125; inline int allout(kdtnode &amp;x) &#123; int ok=0; for(int i=0;i&lt;dim;i++) ok|=(x.mn[i]&gt;q.x[i]); return ok; &#125; type query(int id) &#123; if(!id) return 0; type res=0; if(allin(t[id])) return t[id].sum; if(allout(t[id])) return 0; if(check(t[id])) res=max(res,t[id].v); int l=ls,r=rs; if(t[l].sum&lt;t[r].sum) swap(l,r); if(t[l].sum&gt;res) res=max(res,query(l)); if(t[r].sum&gt;res) res=max(res,query(r)); return res; &#125; inline type query(kdtnode _q)&#123;q=_q;return query(root);&#125; &#125;kd; #undef type #undef ls #undef rs&#125;using namespace kd_tree;VI a[MAX],b[MAX],c[MAX];int d[MAX];void go()&#123; int n,i,x,ans; while(read(n)) &#123; for(i=1;i&lt;=n;i++) &#123; a[i].clear(); b[i].clear(); c[i].clear(); &#125; for(i=1;i&lt;=n;i++) read(x),a[x].pb(i); for(i=1;i&lt;=n;i++) read(x),b[x].pb(i); for(i=1;i&lt;=n;i++) read(x),c[x].pb(i); for(i=1;i&lt;=n;i++) read(d[i]); ans=0; kd.init(); kdtnode tmp; vector&lt;kdtnode&gt; res; for(i=1;i&lt;=n;i++) &#123; res.clear(); for(auto &amp;ai:a[d[i]]) &#123; for(auto &amp;bi:b[d[i]]) &#123; for(auto &amp;ci:c[d[i]]) &#123; tmp.set(ai,bi,ci,kd.query(kdtnode(ai-1,bi-1,ci-1))+1); ans=max(ans,tmp.v); res.pb(tmp); &#125; &#125; &#125; for(auto &amp;it:res) kd.insert(it); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/17/2018niuke9.G/","date":"08-17","excerpt":""},{"title":"hdu 6406 Taotao Picks Apples (离线+二分+RMQ)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6406 题意：一个数轴上有n个苹果，放在位置1到n。刚开始篮子里没有苹果，一个人从1走到n，如果第i个位置的苹果严格大于篮子里所有苹果，就把那个苹果放进篮子。然后有q个询问，每次询问如果把位置x的苹果替换成大小为y的苹果，那么从1走到n，篮子里会有多少苹果。注意询问的替换不是真正的替换。 题解：因为没有修改(不是真正的替换)，所以离线做。先预处理出一个dp数组。dp[i]表示区间[i,n]的答案。倒着for，从区间[i+1,n]中找出第一个比v[i]大的数的位置转移过来，不存在的话dp[i]=1。对询问按x从小到大排序，然后扫过去。对于查询的一个位置x：区间[1,x-1]的最大值记为mx。1.对于区间[1,x-1]的答案是确定，记为now。2.考虑x这个位置修改后的数字val：(1)如果val大于mx，那么ans=now+1+dp[pos]。pos为区间[x+1,n]中第一个比val大的数的位置。(2)如果val小于等于mx，那么ans=now+dp[pos]。pos为区间[x+1,n]中第一个比mx大的数的位置。 至于怎么找区间中第一个比x大的数的位置，我们可以预处理一下RMQ，然后二分区间，查询区间最大值调整二分边界。 总复杂度是O(nlogn+qlogn)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=998244353;/********************************* head *********************************/int v[MAX],maxx[MAX][20];void RMQ(int n)&#123; int i,j; for(i=1;i&lt;=n;i++) &#123; maxx[i][0]=v[i]; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) maxx[i][j]=0; &#125; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int t=1&lt;&lt;(j-1); maxx[i][j]=max(maxx[i][j-1],maxx[i+t][j-1]); &#125; &#125;&#125;int query(int l,int r)&#123; int j=(int)(log10(r-l+1)/log10(2))+1; int i=r-(1&lt;&lt;(j-1))+1; return max(maxx[l][j-1],maxx[i][j-1]);&#125;struct node&#123; int x,v,id; void input(int i) &#123; read(x,v); id=i; &#125; friend bool operator&lt;(node a,node b)&#123;return a.x&lt;b.x;&#125;&#125;qs[MAX];int ans[MAX],dp[MAX];void go()&#123; int t,i,j,n,q,now,mx,pos; read(t); while(t--) &#123; read(n,q); for(i=1;i&lt;=n;i++) read(v[i]); RMQ(n); auto getpos=[&amp;](int _l,int _r,int v)-&gt;int &#123; int l,r,mid; l=_l; r=_r; if(l&gt;r) return -1; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; if(query(l,mid)&lt;=v) l=mid+1; else r=mid; &#125; if(query(l,l)&lt;=v) return -1; return l; &#125;; dp[n]=1; for(i=n-1;i;i--) &#123; pos=getpos(i+1,n,v[i]); if(pos!=-1) dp[i]=dp[pos]+1; else dp[i]=1; &#125; for(i=1;i&lt;=q;i++) qs[i].input(i); sort(qs+1,qs+1+q); now=0; mx=-1; for(i=1,j=1;i&lt;=q;i++) &#123; while(j&lt;qs[i].x) &#123; if(v[j]&gt;mx) &#123; mx=v[j]; now++; &#125; j++; &#125; ans[qs[i].id]=now; if(qs[i].v&gt;mx) &#123; pos=getpos(j+1,n,qs[i].v); ans[qs[i].id]++; &#125; else pos=getpos(j+1,n,mx); if(pos!=-1) ans[qs[i].id]+=dp[pos]; &#125; for(i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); &#125;&#125;","path":"2018/08/16/hdu6406/","date":"08-16","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第九场）A.Circulant Matrix (FWT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/147/A 题意： 题解：观察样例感觉是个卷积，然后发现是个xor的FWT。题意转换成，给个a数组和c数组，求一个b数组，使得a数组和b数组做FWT后的结果为c数组。然后观察FWT的过程：对a，b数组做FWT，c[i]=a[i]*b[i]，然后对c数组做UFWT。我们把这个过程倒过来：先对c数组做UFWT，然后对a数组做FWT，然后b[i]=c[i]/a[i]，最后对b数组做FWT，就把b数组还原了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=6e5+10;const ll mod=1e9+7;/********************************* head *********************************/namespace FWT&#123; ll inv2; const ll p=1e9+7; ll pow2(ll a,ll b) &#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res; &#125; void fwt(ll *a,int n,int v) &#123; for(int d=1;d&lt;n;d&lt;&lt;=1) &#123; for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m) &#123; for(int j=0;j&lt;d;j++) &#123; ll x=a[i+j],y=a[i+j+d]; if(!v) a[i+j]=(x+y)%p,a[i+j+d]=(x-y+p)%p; else a[i+j]=(x+y)*inv2%p,a[i+j+d]=(x-y+p)%p*inv2%p; &#125; &#125; &#125; &#125; void XOR(ll *a,ll *b,int n) &#123; int len; for(len=1;len&lt;=n;len&lt;&lt;=1); fwt(a,len,0); fwt(b,len,0); for(int i=0;i&lt;len;i++) a[i]=a[i]*b[i]%p; inv2=pow2(2,p-2); fwt(a,len,1); &#125; void XOR_inv(ll *a,ll *b,int n) &#123; int len; for(len=1;len&lt;=n;len&lt;&lt;=1); inv2=pow2(2,p-2); fwt(a,len,1); fwt(b,len,0); for(int i=0;i&lt;len;i++) a[i]=a[i]*pow2(b[i]%p,p-2)%p; fwt(a,len,0); &#125;&#125;;ll a[MAX],b[MAX];void go()&#123; int n,i; while(read(n)) &#123; for(i=0;i&lt;n;i++) read(b[i]); for(i=0;i&lt;n;i++) read(a[i]); FWT::XOR_inv(a,b,n); for(i=0;i&lt;n;i++) printf(\"%lld\\n\",a[i]); &#125;&#125;","path":"2018/08/16/2018niuke9.A/","date":"08-16","excerpt":""},{"title":"hdu 6393 Traffic Network in Numazu (基环树+树链剖分)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6393 题意：给一个n个点，n条边的联通图，边有边权。有两个操作：操作0：修改一条边的边权。操作1：查询节点a到节点b的最短路。 题解：n个点n条边的连通图，可知给的图是一棵基环树。所以做法就是先断开一条环边，变成一棵树，然后做树剖，因为单点修改，用个bit维护。判断是不是环边可以用并查集。假设断开的边为x，y，边权为v。分三类讨论：1.树链a到b2.树链a到x+树链y到b+v3.树链a到y+树链x到b+v可能会有两类是重复的，为了方便就直接分三类。那么答案就是这三类取min。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct dsu&#123; int pre[MAX]; void init(int n) &#123; int i; for(i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; &#125; int find(int x) &#123; if(pre[x]!=x) pre[x]=find(pre[x]); return pre[x]; &#125; int merge(int a,int b) &#123; int ra,rb; ra=find(a); rb=find(b); if(ra!=rb) pre[ra]=rb; return ra!=rb; &#125;&#125;dsu; struct Fenwick_Tree&#123; #define type ll type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res; &#125; type query(int l,int r) &#123; return get(r)-get(l-1); &#125; #undef type&#125;tr;struct HLD&#123; #define type ll struct edge&#123;int a,b;type v;edge(int _a,int _b,type _v=0):a(_a),b(_b),v(_v)&#123;&#125;&#125;; vector&lt;int&gt; mp[MAX]; vector&lt;edge&gt; e; int deep[MAX],fa[MAX],size[MAX],son[MAX]; int rnk[MAX],top[MAX],idx[MAX],tot; int n,rt; void init(int _n) &#123; n=_n; for(int i=1;i&lt;=n;i++) mp[i].clear(); e.clear(); e.pb(edge(0,0)); &#125; void add_edge(int a,int b,type v=0) &#123; e.pb(edge(a,b,v)); if(a==-1||b==-1) return; mp[a].pb(b); mp[b].pb(a); &#125; void dfs1(int x,int pre,int h) &#123; int i,to; deep[x]=h; fa[x]=pre; size[x]=1; for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to==pre) continue; dfs1(to,x,h+1); size[x]+=size[to]; if(son[x]==-1||size[to]&gt;size[son[x]]) son[x]=to; &#125; &#125; void dfs2(int x,int tp) &#123; int i,to; top[x]=tp; idx[x]=++tot; rnk[idx[x]]=x; if(son[x]==-1) return; dfs2(son[x],tp); for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to!=son[x]&amp;&amp;to!=fa[x]) dfs2(to,to); &#125; &#125; void work(int _rt) &#123; int i; rt=_rt; mem(son,-1); tot=0; dfs1(rt,0,0); dfs2(rt,rt); &#125; //path void init_path() &#123; for(int i=1;i&lt;=n;i++) &#123; if(e[i].a==-1) continue; if(deep[e[i].a]&lt;deep[e[i].b]) swap(e[i].a,e[i].b); tr.insert(idx[e[i].a],e[i].v); &#125; &#125; void update(int x,type val) &#123; tr.insert(x,-tr.query(x,x)+val); &#125; void modify_edge(int id,type val) &#123; if(deep[e[id].a]&gt;deep[e[id].b]) update(idx[e[id].a],val); else update(idx[e[id].b],val); &#125; type query_path(int x,int y) &#123; type res=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); res+=tr.query(idx[top[x]],idx[x]); x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); if(x!=y) res+=tr.query(idx[x]+1,idx[y]); return res; &#125; #undef type&#125;hld; //hld.init(n)void go()&#123; int t,n,q,i,op,a,b,c; ll ans; int x,y,v,id; read(t); while(t--) &#123; read(n,q); hld.init(n); tr.init(n); dsu.init(n); for(i=1;i&lt;=n;i++) &#123; read(a,b,c); if(!dsu.merge(a,b)) &#123; id=i; x=a; y=b; v=c; hld.add_edge(-1,-1,-1); &#125; else hld.add_edge(a,b,c); &#125; hld.work(1); hld.init_path(); while(q--) &#123; read(op,a,b); if(op==0) &#123; if(a==id) v=b; else hld.modify_edge(a,b); &#125; else &#123; ans=LLINF; ans=min(ans,hld.query_path(a,b)); ans=min(ans,hld.query_path(a,x)+hld.query_path(y,b)+v); ans=min(ans,hld.query_path(a,y)+hld.query_path(x,b)+v); printf(\"%lld\\n\",ans); &#125; &#125; &#125;&#125;","path":"2018/08/14/hdu6393/","date":"08-14","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第六场）I.Team Rocket(STL)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/144/I 题意：给n个列车和m个爆破点。每个列车有一个运行区间[L,R]。刚开始，所有列车都在运行。每次爆破一个点后输出有多少运行中的列车因为这次爆破而停止运行。然后那些列车就停止运行了。最后输出每个列车是因为第几次爆破而停止运行的。爆破点是加密的，所以强制在线。 题解：先把L从小到大离散化一下，然后开2e5个set存每个R和列车的id，注意R是要求从大到小存。然后每次爆破，暴力遍历每个set，遇到满足的就记录，并从set里删除，遇到第一个不满足的就break。但是这样每次可能会遍历2e5次。所以用一个双向链表维护，遍历的时候跳掉那些size等于0的set。 *赛后想了想，这种做法还是能被卡成n^2，所以仅供参考… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;/********************************* head *********************************/struct node&#123; int fi,se; node()&#123;&#125; node(int l,int r) :fi(l),se(r)&#123;&#125; friend bool operator&lt;(node a,node b) &#123; if(a.fi==b.fi) return a.se&lt;b.se; return a.fi&gt;b.fi; &#125; friend bool operator!=(node a,node b) &#123; return a.fi!=b.fi||a.se!=b.se; &#125;&#125;;set&lt;node&gt; mp[MAX];PII a[MAX];int res[MAX],nex[MAX],p[MAX];void go()&#123; int t,n,m,i,ans,x,tot,time,cas=1; node tmp; ll pre,now; read(t); while(t--) &#123; unordered_map&lt;int,int&gt; id; VI xx; read(n,m); for(i=1;i&lt;=n;i++) &#123; read(a[i].fi,a[i].se); xx.pb(a[i].fi); res[i]=0; nex[i]=i+1; p[i]=i-1; &#125; sort(all(xx)); xx.resize(unique(all(xx))-xx.begin()); for(i=0;i&lt;sz(xx);i++) id[xx[i]]=i+1; tot=sz(xx); for(i=1;i&lt;=tot;i++) mp[i].clear(); for(i=1;i&lt;=n;i++) mp[id[a[i].fi]].insert(node(a[i].se,i)); pre=0; printf(\"Case #%d:\\n\",cas++); for(time=1;time&lt;=m;time++) &#123; read(x); x=(x^pre); ans=0; now=1; for(i=1;i&lt;=tot;i=nex[i]) &#123; if(xx[i-1]&gt;x) break; tmp=node(-INF,-INF); for(auto &amp;it:mp[i]) &#123; if(tmp!=node(-INF,-INF)) mp[i].erase(tmp); if(it.fi&lt;x) break; ans++; res[it.se]=time; now=now*it.se%mod; tmp=it; &#125; if(tmp!=node(-INF,-INF)) mp[i].erase(tmp); if(sz(mp[i])==0) &#123; nex[p[i]]=nex[i]; p[nex[i]]=p[i]; &#125; &#125; if(now==1&amp;&amp;res[1]!=time) now=0; pre=now; printf(\"%d\\n\",ans); &#125; for(i=1;i&lt;=n;i++) printf(\"%d%c\",res[i],\" \\n\"[i==n]); &#125;&#125;","path":"2018/08/04/2018niuke6.I/","date":"08-04","excerpt":""},{"title":"hdu 6336 Problem E. Matrix from Arrays (二维前缀和)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6336 题意：给一个构造矩阵的代码，给一个长度为L的数组A，构造出一个无限大的矩阵，然后每次查询子矩阵的和。 题解：把矩阵构造出来后，观察发现，行和列的循环节都是2L(其实L为奇数的时候，循环节是L，为了方便这里统一为2L)，所以矩阵的循环节为2L*2L。 下图是L=4，A[]={1,2,3,4}的矩阵的一部分。红色矩阵都是一样的。假设我们要求蓝色矩阵的和。蓝色矩阵的和=6个1号矩阵+3个2号矩阵+2个3号矩阵+1个4号矩阵。 所以做法就是预处理一下2L*2L矩阵的二维前缀和。然后每次这么算一下就行了，结合图和代码理解一下。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/void go()&#123; ll mp[111][111],i,j,a[22],L,t,q,x1,y1,x2,y2,now; read(t); while(t--) &#123; read(L); for(i=0;i&lt;L;i++) read(a[i]); now=0; for(i=0;i&lt;4*L;i++) &#123; for(j=0;j&lt;=i;j++) &#123; mp[j][i-j]=a[now++]; now%=L; &#125; &#125; L*=2; for(i=0;i&lt;L;i++) &#123; for(j=0;j&lt;L;j++) &#123; if(i) mp[i][j]+=mp[i-1][j]; if(j) mp[i][j]+=mp[i][j-1]; if(i&amp;&amp;j) mp[i][j]-=mp[i-1][j-1]; &#125; &#125; read(q); while(q--) &#123; read(x1,y1,x2,y2); auto gao=[&amp;](ll x,ll y) &#123; if(x&lt;0||y&lt;0) return 0LL; return mp[L-1][L-1]*(x/L)*(y/L) +mp[x%L][L-1]*(y/L) +mp[L-1][y%L]*(x/L) +mp[x%L][y%L]; &#125;; println(gao(x2,y2)-gao(x1-1,y2)-gao(x2,y1-1)+gao(x1-1,y1-1)); &#125; &#125;&#125;","path":"2018/08/01/hdu6336/","date":"08-01","excerpt":""},{"title":"容斥的原理及广义应用","text":"原文：https://blog.csdn.net/werkeytom_ftd/article/details/74701513","path":"2018/07/28/rongchi/","date":"07-28","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第三场）I.Expected Size of Random Convex Hull (随机+打表)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/141/I 题意：给一个三角形，让你在三角形内随机选n个点，问这n个点在凸包上的期望是多少。 题解：显然三角形长什么样，对答案没有影响。注意到n&lt;=10，所以做法就是：在三角形内随机n个点，求凸包，然后求多少个点在凸包上。随机次数越多，答案是准确率越高。最后打个表交上去就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/int sgn(double x)&#123; if(fabs(x)&lt;eps) return 0; else return x&gt;0?1:-1; &#125;struct Point&#123; double x,y; Point()&#123;&#125; Point(double a,double b) &#123; x=a; y=b; &#125; void input() &#123; scanf(\"%lf%lf\",&amp;x,&amp;y); &#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,double p)&#123;return Vector(a.x*p,a.y*p);&#125; Vector operator /(Vector a,double p)&#123;return Vector(a.x/p,a.y/p);&#125;bool operator &lt;(Point a,Point b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;bool operator ==(Point a,Point b)&#123;return sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0;&#125;double cross(Vector a,Vector b)&#123;return a.x*b.y-a.y*b.x;&#125;vector&lt;Point&gt; graham(vector&lt;Point&gt; p)&#123; int n,m,k,i; sort(p.begin(),p.end()); p.erase(unique(p.begin(),p.end()),p.end()); n=p.size(); m=0; vector&lt;Point&gt; res(n+1); for(i=0;i&lt;n;i++) &#123; while(m&gt;1&amp;&amp;cross(res[m-1]-res[m-2],p[i]-res[m-2])&lt;=0) m--; res[m++]=p[i]; &#125; k=m; for(i=n-2;i&gt;=0;i--) &#123; while(m&gt;k&amp;&amp;cross(res[m-1]-res[m-2],p[i]-res[m-2])&lt;=0) m--; res[m++]=p[i]; &#125; if(n&gt;1) m--; res.resize(m); return res;&#125;Point randp()&#123; while(1) &#123; Point p(rand(),rand()); if(p.x+p.y&lt;=32766) return p; &#125; return Point(0,0);&#125;void gao()&#123; srand(time(0)); for(int i=4;i&lt;=10;i++) &#123; int t=20000000; double ans=0; while(t--) &#123; vector&lt;Point&gt; p; for(int j=0;j&lt;i;j++) p.pb(randp()); p=graham(p); ans+=sz(p); &#125; ans/=20000000; printf(\"%.6f,\",ans); &#125; puts(\"\");&#125;int main()&#123;// gao(); double ans[]=&#123;0,0,0,3,3.666724,4.166653,4.566743,4.900092,5.185803,5.435999,5.658361&#125;; int n,i; Point p; for(i=0;i&lt;3;i++) p.input(); scanf(\"%d\",&amp;n); printf(\"%.4f\\n\",ans[n]); return 0;&#125;","path":"2018/07/27/2018niuke3.I/","date":"07-27","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第三场）E.Sort String (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/141/E 题意：给一个字符串，复制前n-1个字符后，问有多少种长度n的子串，分类后按字典序输出下标。 题解：复制一遍字符串，然后预处理hash表。之后for每个起始位置，可以在O(1)的时间获取子串的hash值，然后扔进map分类即可。对于这种写法字典序不需要特殊处理。这个题卡常…有两个点要注意一下。1.mod取1e9+7会冲突(过了62.5%的数据)，而且每次%常数很大，会tle，这里选用了ull(自动%2^64)。2.要用unordered_map，不然会tle。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e6+10;const ll mod=1e9+7;/********************************* head *********************************/struct hash_table&#123; ull seed; ull Hash[MAX],tmp[MAX]; void set(ull _seed) &#123; seed=_seed; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; Hash[0]=0; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed; for(i=1;i&lt;=n;i++) Hash[i]=(Hash[i-1]*seed+(s[i]-'a')); &#125; ull get(int l,int r) &#123; return (Hash[r]-Hash[l-1]*tmp[r-l+1]); &#125;&#125;h;char s[MAX];VI res[MAX];int main()&#123; int i,j,len,tot; while(~scanf(\"%s\",s+1)) &#123; len=strlen(s+1); for(i=len+1,j=1;j&lt;=len;i++,j++) s[i]=s[j]; for(i=1;i&lt;=len;i++) res[i].clear(); h.set(23333); h.work(s,len*2); unordered_map&lt;ull,int&gt; mp; tot=0; for(i=1;i&lt;=len;i++) &#123; ull tmp=h.get(i,i+len-1); if(!mp.count(tmp)) mp[tmp]=++tot; res[mp[tmp]].pb(i-1); &#125; printf(\"%d\\n\",tot); for(i=1;i&lt;=tot;i++) &#123; printf(\"%d\",sz(res[i])); for(auto it:res[i]) printf(\" %d\",it); puts(\"\"); &#125; &#125; return 0;&#125;","path":"2018/07/26/2018niuke3.E/","date":"07-26","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）B.discount (基环树dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/B 题意：有n种饮料，你可以选择一下两种优惠策略1、打折购买，花费为p[x]-d[x]2、原价购买，但是会赠送给你一瓶类型为f[x]的饮料问你获得全部种类的饮料的最小花费为多少 题解(solved by winterzz1)：根据题意，可以建立从购买饮料到赠送饮料的有向边。建出的图每一个联通块都是一颗树多一条边。先预处理，枚举每一条边，如果两端点u,v还不在同一个联通块中，就把起点u与终点v用并查集并起来。否则记u为root，v为对应的ex节点，同时删去这条边，将图改造为树。例如 加入的边为5 12 52 42 36 76 2 那么在最后加入6-&gt;2这条边时，由于2,6已经属于同一个联通块，就记6为root，2为对应的ex节点。 因为整个图可能是不连通的，所以可能会产生多个root节点和对应的ex节点。 这样做完以后原图就被改造成了由多个树组成的森林。 先简化题目，不考虑root节点对ex节点的影响。 那么就是树形dp。dp数组两个维度dp[x][0]表示第x节点赠送父节点的最优解，dp[x][1]表示第x节点不赠送父节点的最优解。 dp[x][0]=min(p[x]-d[x]+Σdp[ch][0],dp[k][1]-dp[k][0]+ Σdp[ch][0])k∈ch。 对于dp[x][1]直接做一步贪心，因为赠送父节点就必须原价购买，而原价购买的价格一定高于其他情况。 dp[x][1]= p[x]+ Σdp[ch][0]。 现在考虑root节点对ex节点的影响，再扩个维度dp[x][k][0]表示root节点没有提供ex节点的饮料，dp[x][k][1]表示root节点提供了ex节点的饮料。 显然第三个维度仅仅对当前节点为ex节点时才有影响，否则这个维度无用。 那么如果当前节点不是ex节点，按照二维直接做，0转移到0,1转移到1即可。 即：dp[x][0][0]=min(p[x]-d[x]+Σdp[ch][0][0],dp[k][1][0]-dp[k][0][0]+ Σdp[ch][0][0])k∈ch。 dp[x][0][1]=min(p[x]-d[x]+Σdp[ch][0][1],dp[k][1][1]-dp[k][0][1]+ Σdp[ch][0][1])k∈ch。 如果当前节点为ex节点，需要特殊转移。dp[ex][0][0]=min(p[root]-d[root]+ Σdp[ch][0][0] dp[k][1][0]-dp[k][0][0]+ Σdp[ch][0][0]) k∈ch。 dp[ex][0][1]= Σdp[ch][0][1]（贪心，如果根节点提供ex节点的饮料，就不需要子树再提供） dp[ex][1][0]= Σdp[ch][0][0]+p[root]dp[ex][1][1]= Σdp[ch][0][1]+p[root] 注意转移到最后dp[root][0][1]和dp[root][1][0]是自相矛盾的非法状态，合法的只有dp[root][0][0]和dp[root][1][1]，所以答案为min(dp[root][0][0], dp[root][1][1])。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;int fa[MAXN],f[MAXN],root[MAXN],ex[MAXN],tot,n;long long ans,p[MAXN],d[MAXN],dp[MAXN][2][2];vector&lt;int&gt; G[MAXN];int findf(int x)&#123; if(x==fa[x])return x; return fa[x]=findf(fa[x]);&#125;void unions(int x,int y)&#123; if(findf(x)!=findf(y)) &#123; fa[findf(x)]=findf(y); &#125; return;&#125;void dp_dfs(int root,int ex)&#123; long long sum00=0; long long sum01=0; for(int i=0;i&lt;G[root].size();++i) &#123; dp_dfs(G[root][i],ex); sum00+=dp[G[root][i]][0][0]; sum01+=dp[G[root][i]][0][1]; &#125; if(root==ex) &#123; dp[root][0][0]=sum00+p[root]-d[root]; dp[root][0][1]=sum01; dp[root][1][0]=sum00+p[root]; dp[root][1][1]=sum01+p[root]; for(int i=0;i&lt;G[root].size();++i) &#123; dp[root][0][0]=min(dp[root][0][0],sum00-dp[G[root][i]][0][0]+dp[G[root][i]][1][0]); &#125; &#125; else &#123; dp[root][0][0]=sum00+p[root]-d[root]; dp[root][0][1]=sum01+p[root]-d[root]; dp[root][1][0]=sum00+p[root]; dp[root][1][1]=sum01+p[root]; for(int i=0;i&lt;G[root].size();++i) &#123; dp[root][0][0]=min(dp[root][0][0],sum00-dp[G[root][i]][0][0]+dp[G[root][i]][1][0]); dp[root][0][1]=min(dp[root][0][1],sum01-dp[G[root][i]][0][1]+dp[G[root][i]][1][1]); &#125; &#125; return;&#125;int main()&#123; while(scanf(\"%d\",&amp;n)!=EOF) &#123; ans=0; tot=0; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;p[i]); dp[i][0][0]=dp[i][0][1]=dp[i][1][0]=dp[i][1][1]=0; G[i].clear(); fa[i]=i; &#125; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;d[i]); &#125; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;f[i]); if(findf(i)!=findf(f[i])) &#123; G[f[i]].push_back(i); unions(f[i],i); &#125; else &#123; root[++tot]=i; ex[tot]=f[i]; &#125; &#125; for(int i=1;i&lt;=tot;++i) &#123; dp_dfs(root[i],ex[i]); ans+=min(dp[root[i]][0][0],dp[root[i]][1][1]); &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/24/2018niuke2.B/","date":"07-24","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）H.travel (树形dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/H 题意：给一棵树，在树上选3条不相交的树链，使点权和最大。 题解：对于dp数组：dp[x][y][k]表示在节点x，x节点的类型是y，现在已经选了k条链。其中：关于y，y的取值是[0,2]。0：表示节点x不选。或者选了节点x后，选择包括节点x的这条链。1：表示节点x是一条链的端点。即长这样： 2：表示节点x是一条链的拐点。即长这样： 关于k，k的取值是[0,3]。表示现在已选了0,1,2,3条树链。 那么答案就是dp[1][0][3]。 对于转移：关于k的转移，很显然，k=i+j，枚举k和i，求出j，直接转移就行了。 关于y的转移，我们要分类讨论。考虑y=2时，有两种转移。第一种：变为dp[x][2][k]=max(dp[x][2][k],dp[x][1][i]+dp[to][1][j])注意到dp[x][2][k]要从dp[x][1][i]转移过来，所以要先转移y=2，再转移y=1，不然会重复转移。 第二种就是本身已经是拐点了，然后把子节点已选的树链给加上来。dp[x][2][k]=max(dp[x][2][k],dp[x][2][i]+dp[to][0][j])注意到dp[x][2][k]要从dp[x][2][i]转移过来，所以k和i要从大到小枚举，不然会重复转移。 然后考虑y=1时，有两种转移。 第一种也是本身已经是端点了，然后把子节点已选的树链给加上来。dp[x][1][k]=max(dp[x][1][k],dp[x][1][i]+dp[to][0][j])同样注意到dp[x][1][k]要从dp[x][1][i]转移过来，所以k和i也要从大到小枚举，不然会重复转移。 第二种是子节点是端点，然后接上自己，自己还是端点。长这样：变成dp[x][1][k]=max(dp[x][1][k],dp[x][0][i]+dp[to][1][j]+v[x])注意到dp[x][1][k]要从dp[x][0][i]转移过来，所以要先转移y=1，再转移y=0，不然会重复转移。 然后考虑y=0时，有三种转移。 第一种是最基本的，就不用解释了。dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][0][j])同样注意到dp[x][0][k]要从dp[x][0][i]转移过来，所以k和i也要从大到小枚举，不然会重复转移。 第二种和第三种其实可以算一种。如果子节点是端点或者是拐点，我们选它，算作一条链。if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][2][j-1])if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][1][j-1]) 最后，我们把自己是端点或者是拐点，整合算作一条链，更新一下。dp[x][0][k]=max(dp[x][0][k],dp[x][1][k-1])dp[x][0][k]=max(dp[x][0][k],dp[x][2][k-1]) 大概这个题就这样，具体自己理解一下。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=4e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll dp[MAX][3][4],v[MAX];VI mp[MAX];void dfs(int x,int fa)&#123; int i,j,k; dp[x][1][0]=v[x]; for(auto to:mp[x]) &#123; if(to==fa) continue; dfs(to,x); for(k=2;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][2][k]=max(dp[x][2][k],dp[x][1][i]+dp[to][1][j]); dp[x][2][k]=max(dp[x][2][k],dp[x][2][i]+dp[to][0][j]); &#125; &#125; for(k=2;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][1][k]=max(dp[x][1][k],dp[x][1][i]+dp[to][0][j]); dp[x][1][k]=max(dp[x][1][k],dp[x][0][i]+dp[to][1][j]+v[x]); &#125; &#125; for(k=3;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][0][j]); if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][2][j-1]); if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][1][j-1]); &#125; &#125; &#125; for(k=1;k&lt;=3;k++) &#123; dp[x][0][k]=max(dp[x][0][k],dp[x][1][k-1]); dp[x][0][k]=max(dp[x][0][k],dp[x][2][k-1]); &#125;&#125;int main()&#123; int n,i,j,a,b; while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) &#123; mp[i].clear(); mem(dp[i],0); scanf(\"%lld\",&amp;v[i]); &#125; for(i=1;i&lt;n;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; dfs(1,-1); printf(\"%lld\\n\",dp[1][0][3]); &#125; return 0;&#125;","path":"2018/07/24/2018niuke2.H/","date":"07-24","excerpt":""},{"title":"hdu 6305 RMQ Similar Sequence(下标RMQ+分治)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6305 题意：给一个长度为n的序列A。有一个长度为n的序列B，B的每个元素都是在[0,1]内随机的实数。定义RMQ(A,l,r)为在A数组区间[l,r]内最大的那个元素的最小下标。求满足1≤l≤r≤n,RMQ(A,l,r)=RMQ(B,l,r)的所有B数组的$\\sum_{i=1}^n{b_i}$的期望。 题解：1.考虑到B中有元素相同的概率是0(因为是实数)，于是可以假设B里面元素互不相同，也就是说可以假定是一个排列。2.[0,1]内随机一个实数的期望是0.5，那么一个排列(n个数)的期望就是n/2。3.问题转换成：B为n的一个全排列，求满足1≤l≤r≤n,RMQ(A,l,r)=RMQ(B,l,r)的B数组的方案数，记为res。那么ans=(res/n!)*n/2。 所以现在的问题就是，怎么求满足条件的方案数。这个条件其实就是要满足B数组的大小关系跟A数组的一致。那么做法就是：用下标RMQ，然后分治。每次找RMQ(A,l,r)，记为pos。分配给B[pos]数组持有的数的最大值，因为如果B[pos]为最大值，那么RMQ(B,l,r)也一定返回pos。然后把剩下的数分配给区间[l,pos-1]和[pos+1,r]，那我们在剩下的数中选pos-l个数，分配给[l,pos-1]，剩下的数就分配给[pos+1,r]。所以分配的方案数就是C(r-l，pos-l)。连乘起来就是res。然后带入那个公式就是答案。 另外注意，需要贴读入挂。还有g++会爆栈，c++扩栈但是贴读入挂也是tle，所以要手写用栈模拟dfs。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e6+10;const ll mod=1e9+7;/**************************************** head ****************************************/struct FastIO &#123; static const int S=200; int wpos; char wbuf[S]; FastIO():wpos(0)&#123;&#125; inline int xchar() &#123; static char buf[S]; static int len=0,pos=0; if(pos==len) pos=0,len=fread(buf,1,S,stdin); if(pos==len) exit(0); return buf[pos++]; &#125; inline int read() &#123; int s=1,c=xchar(),x=0; while(c&lt;=32) c=xchar(); if(c=='-') s=-1,c=xchar(); for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=xchar()) x=x*10+c-'0'; return x*s; &#125; ~FastIO() &#123; if(wpos) fwrite(wbuf,1,wpos,stdout),wpos=0; &#125; &#125;io;int v[MAX],maxx[MAX][22];int pmax(int a,int b)&#123; if(v[a]==v[b]) return min(a,b); return v[a]&gt;v[b]?a:b;&#125;void RMQ(int n)&#123; int i,j; for(i=1;i&lt;=n;i++) &#123; maxx[i][0]=i; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; maxx[i][j]=0; &#125; &#125; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int t=1&lt;&lt;(j-1); maxx[i][j]=pmax(maxx[i][j-1],maxx[i+t][j-1]); &#125; &#125;&#125;int query(int l,int r)&#123; int j=(int)(log10(r-l+1)/log10(2))+1; int i=r-(1&lt;&lt;(j-1))+1; return pmax(maxx[l][j-1],maxx[i][j-1]);&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll fac[MAX],invfac[MAX];void init(int n)&#123; ll i; fac[0]=invfac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; invfac[i]=inv(fac[i]); &#125;&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*invfac[m]%mod*invfac[n-m]%mod;&#125;namespace DFS&#123; struct node&#123;int l,r;&#125;; int top; node st[MAX]; ll dfs(int mn,int mx) &#123; ll res=1; int l,r; l=mn; r=mx; top=0; st[top].l=l; st[top++].r=r; while(top) &#123; l=st[top-1].l; r=st[--top].r; if(l&gt;=r) continue; int pos=query(l,r); res=res*C(r-l,pos-l)%mod; st[top].l=l; st[top++].r=pos-1; st[top].l=pos+1; st[top++].r=r; &#125; return res; &#125;&#125;ll dfs(int l,int r)&#123; if(l&gt;=r) return 1LL; int pos=query(l,r); return dfs(l,pos-1)*dfs(pos+1,r)%mod*C(r-l,pos-l)%mod;&#125;int main()&#123; int n,t,i;// scanf(\"%d\",&amp;t); t=io.read(); init(MAX-10); ll ans; while(t--) &#123;// scanf(\"%d\",&amp;n); n=io.read(); for(i=1;i&lt;=n;i++) v[i]=io.read();//scanf(\"%d\",&amp;v[i]); RMQ(n); ans=DFS::dfs(1,n)*invfac[n]%mod*n%mod*inv(2)%mod; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/23/hdu6305/","date":"07-23","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）E.Removal (dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/E 题意：长度为n的序列，删掉m个数字后有多少种不同的序列。n&lt;=10^5，m&lt;=10。 题解：dp[i][j]表示加入第i个数字后，总共删掉j个数字时，有多少种不同的序列。假设不考虑有重复的情况，dp方程为：dp[i][j]=dp[i-1][j] (第i个数字不删)+dp[i-1][j-1] (第i个数字删)。现在考虑重复的情况。如果前面有与a[i]相同的数字a[k] (k小于i)，并且i-k&lt;=j，就会产生重复。比如：cdeaae(用字符串举例比较方便)当我们i=6,j=3时,a[3]=a[6],那么如果删掉中间的[eaa]字串就会变成[cde]，因为我们已经在前面i=3时算过了一次[cde]这种情况，所以我们需要dp[6][3]-dp[2][0]。那么为什么不是减掉dp[3][0]而是减掉dp[2][0]呢。举个比较好说明的例子。还是上面那个串，假设现在是i=6,j=4。那么我们需要dp[6][4]-dp[2][1]。那么为什么不是减掉dp[3][1]呢。因为dp[3][1]=dp[2][1]+dp[2][0]，也就是说dp[3][1]还包括了删掉a[3]的状态，而如果删掉a[3]，那么加入a[6]的时候就不会有重复了。所以减掉dp[2][1]，就是减掉了a[3]不删除的情况。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll dp[MAX][12];int last[12],pre[MAX],a[MAX];int main()&#123; int n,m,k,i,j; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k)) &#123; for(i=1;i&lt;=k;i++) last[i]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); pre[i]=last[a[i]]; last[a[i]]=i; &#125; for(i=0;i&lt;=m;i++) dp[i][i]=1; for(i=1;i&lt;=n;i++) &#123; dp[i][0]=1; for(j=1;j&lt;=min(i-1,m);j++) &#123; dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod; if(pre[i]&amp;&amp;i-pre[i]&lt;=j) &#123; dp[i][j]-=dp[pre[i]-1][j-(i-pre[i])]; dp[i][j]%=mod; dp[i][j]=(dp[i][j]+mod)%mod; &#125; &#125; &#125; printf(\"%lld\\n\",dp[n][m]); &#125; return 0;&#125;/*6 4 53 4 5 1 1 5*/","path":"2018/07/22/2018niuke1.E/","date":"07-22","excerpt":""},{"title":"AtCoder Grand Contest 026 C.String Coloring (折半搜索)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://agc026.contest.atcoder.jp/tasks/agc026_c 题意：给一个长度为2*n的字符串。每个字符可以选择涂成红色或者蓝色。从左往右涂成红色的字符组成一个字符串，记为a。从右往左涂成蓝色的字符组成一个字符串，记为b。求a==b的方案数。 题解：n最大只有18，显然是折半搜索。枚举前半段字符串，将方案用map存。枚举后半段字符串(这里把字符串反转一下，就又变成枚举前半段字符串了)，用map更新答案。复杂度O(log(2^18)*2^18)。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define len(x) (int) x.length()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/int n,flag;string s;ll ans;map&lt;pair&lt;string,string&gt;,int&gt; mp;void dfs(int p,string a,string b)&#123; if(p==n) &#123; if(flag) ans+=mp[MP(a,b)]; else mp[MP(a,b)]++; return; &#125; dfs(p+1,a+s[p],b); dfs(p+1,a,b+s[p]);&#125;int main()&#123; while(~scanf(\"%d\",&amp;n)) &#123; cin&gt;&gt;s; mp.clear(); flag=0; dfs(0,\"\",\"\"); flag=1; reverse(all(s)); ans=0; dfs(0,\"\",\"\"); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/22/agc026.C/","date":"07-22","excerpt":""},{"title":"Codeforces Round#498 div3F Xor-Paths (折半搜索)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1006/F 题意：给一个n*m的矩形，起点(1,1)。每次只能往右走或者往下走。求走到(n,m)时，走过的路径上的值异或起来等于k的方案数 题解：由于n和m只有20，也就是n+m&lt;=40，做法就很明显了。折半步长。第一次从(1,1)为起点走(n+m)/2步，最后走到的终点用map记录下异或值。然后再从(n,m)开始倒退剩下的步数，走到第一次走到的终点停下，用map更新答案。复杂度O(log(2^20)*2^20)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll mp[33][33],ans,k;map&lt;ll,ll&gt; cnt[33][33];int n,m,limt;void dfs1(int x,int y,ll now,int len)&#123; if(x&lt;1||y&lt;1||x&gt;n||y&gt;m) return; if(len==limt) &#123; now^=mp[x][y]; cnt[x][y][now]++;// cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;now&lt;&lt;endl; return; &#125; dfs1(x+1,y,now^mp[x][y],len+1); dfs1(x,y+1,now^mp[x][y],len+1);&#125;void dfs2(int x,int y,ll now,int len)&#123; if(x&lt;1||y&lt;1||x&gt;n||y&gt;m) return; if(len==limt+1) &#123; ans+=cnt[x][y][k^now]; // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;(now^k)&lt;&lt;endl; return; &#125; dfs2(x-1,y,now^mp[x][y],len+1); dfs2(x,y-1,now^mp[x][y],len+1);&#125;int main()&#123; int i,j; while(~scanf(\"%d%d%lld\",&amp;n,&amp;m,&amp;k)) &#123; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%lld\",&amp;mp[i][j]); cnt[i][j].clear(); &#125; &#125; if(n==1&amp;&amp;m==1) &#123; if(mp[1][1]==k) puts(\"1\"); else puts(\"0\"); continue; &#125; ans=0; limt=(n+m-1)/2; dfs1(1,1,0,1);// puts(\"**\"); limt=(n+m-1)-limt; dfs2(n,m,0,1); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/21/cf498.3F/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）J.Different Integers (主席树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/J 题意：给一个长度为n的序列和查询次数q。每次给出L和R，查询区间[1,L]和[R,n]中不同数的个数。 题解：把序列复制一遍，就能查询连续的区间，然后就变成了主席树模板题。注意L&gt;R的时候是查询整个序列。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//由于FastIO太长,就不贴出来了#include &lt;bits/stdc++.h&gt;using namespace std;void Main();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif Main();return 0;&#125;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct president_tree&#123; int root[MAX],ls[40*MAX],rs[40*MAX],sum[40*MAX],tot,ql,qr,qv; void init() &#123; mem(root,0); tot=1; ls[0]=rs[0]=sum[0]=0; &#125; int newnode(int x) &#123; ls[tot]=ls[x]; rs[tot]=rs[x]; sum[tot]=sum[x]; return tot++; &#125; void insert(int l,int r,int &amp;id,int pre) //set(ql,ql,v) &#123; id=newnode(pre); sum[id]+=qv; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) insert(l,mid,ls[id],ls[pre]); else insert(mid+1,r,rs[id],rs[pre]); &#125; int kindcnt(int l,int r,int id) //set(ql,qr) &#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[id]; int mid=(l+r)&gt;&gt;1; int res=0; if(ql&lt;=mid) res+=kindcnt(l,mid,ls[id]); if(qr&gt;=mid+1) res+=kindcnt(mid+1,r,rs[id]); return res; &#125; int kthsmall(int l,int r,int id,int pre,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int temp=sum[ls[id]]-sum[ls[pre]]; if(temp&gt;=k) return kthsmall(l,mid,ls[id],ls[pre],k); else return kthsmall(mid+1,r,rs[id],rs[pre],k-temp); &#125; int kthbig(int l,int r,int id,int pre,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int temp=sum[rs[id]]-sum[rs[pre]]; if(temp&gt;=k) return kthbig(mid+1,r,rs[id],rs[pre],k); else return kthbig(l,mid,ls[id],ls[pre],k-temp); &#125; void set(int l,int r,int v=0)&#123;ql=l;qr=r;qv=v;&#125;&#125;pt;int a[MAX],last[MAX];void Main()&#123; int n,q,i,j,l,r; while(read(n,q)) &#123; pt.init(); for(i=n,j=0;i&lt;=2*n-1;i++,j++) &#123; read(a[i]); last[a[i]]=-1; a[j]=a[i]; &#125;/* for(i=1;i&lt;=2*n-1;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; puts(\"\");*/ for(i=2*n-1;i&gt;=1;i--) &#123; if(last[a[i]]==-1) &#123; pt.set(i,i,1); pt.insert(1,2*n-1,pt.root[i],pt.root[i+1]); &#125; else &#123; int tmp; pt.set(last[a[i]],last[a[i]],-1); pt.insert(1,2*n-1,tmp,pt.root[i+1]); pt.set(i,i,1); pt.insert(1,2*n-1,pt.root[i],tmp); &#125; last[a[i]]=i; &#125; while(q--) &#123; read(l,r); if(l&lt;r-1) &#123; l+=n-1; r=n-(n-r+1); swap(l,r);// cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; pt.set(l,r); print(pt.kindcnt(1,2*n-1,pt.root[l]),'\\n'); &#125; else &#123; pt.set(1,2*n-1); print(pt.kindcnt(1,2*n-1,pt.root[1]),'\\n'); &#125; &#125; &#125;&#125;","path":"2018/07/21/2018niuke1.J/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）J.farm (随机化)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/J 题意：有一个nm的矩形，每个位置有一个数。有T次操作，每次往一个子矩形的每个格子中放入一个数。求有多少个格子中被放入了至少一个与对应位置不相同的数。nm&lt;=1e6,T&lt;=1e6 题解：now[i][j]表示在T次操作后，第(i，j)个格子放的数的和。cnt[i][j]表示在T次操作后，第(i，j)个格子被更新的次数。v[i][j]表示第(i，j)个格子的初始值。now和cnt用二维前缀和更新。那么答案就是now[i][j]!=cnt[i][j]*v[i][j]的个数。 很明显这是假算法，出题人会构造数据卡你。所以对初始值随机打乱一下，被卡的概率就很低。复杂度O(n*m)。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e6+10;const ll mod=1e9+7;/**************************************** head ****************************************/VI v[MAX],cnt[MAX];VL now[MAX];int mp[MAX];int main()&#123; int n,m,q,i,j,x1,x2,y1,y2,vv; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(i=1;i&lt;=n*m;i++) mp[i]=i; random_shuffle(mp+1,mp+1+n*m); for(i=0;i&lt;=n+1;i++) &#123; v[i].resize(m+5); cnt[i].resize(m+5); now[i].resize(m+5); &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;v[i][j]); v[i][j]=mp[v[i][j]]; now[i][j]=0; cnt[i][j]=0; &#125; &#125; while(q--) &#123; scanf(\"%d%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;vv); now[x1][y1]+=mp[vv]; now[x1][y2+1]-=mp[vv]; now[x2+1][y1]-=mp[vv]; now[x2+1][y2+1]+=mp[vv]; cnt[x1][y1]++; cnt[x1][y2+1]--; cnt[x2+1][y1]--; cnt[x2+1][y2+1]++; &#125; int ans=0; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; now[i][j]+=now[i-1][j]+now[i][j-1]-now[i-1][j-1]; cnt[i][j]+=cnt[i-1][j]+cnt[i][j-1]-cnt[i-1][j-1]; if(now[i][j]!=1LL*cnt[i][j]*v[i][j]) ans++; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/07/21/2018niuke2.J/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）F.Sum of Maximum(组合数学+拉格朗日插值)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/F 题意： 题解： 至于杜教的拉格朗日插值板子，是从这里扒的：http://codeforces.com/contest/995/submission/39615335 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/namespace polysum &#123; #define rep(i,a,n) for (int i=a;i&lt;n;i++) #define per(i,a,n) for (int i=n-1;i&gt;=a;i--) const int D=101000; ll a[D],tmp[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125; ll calcn(int d,ll *a,ll n) &#123; // a[0].. a[d] a[n] if (n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1) &#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1) &#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans=0; rep(i,0,d+1) &#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if ((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; void init(int M) &#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=powmod(f[M+4],mod-2); per(i,1,M+4) g[i]=g[i+1]*(i+1)%mod; &#125; ll polysum(ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] rep(i,0,m+1) tmp[i]=a[i]; tmp[m+1]=calcn(m,tmp,m+1); rep(i,1,m+2) tmp[i]=(tmp[i-1]+tmp[i])%mod; return calcn(m+1,tmp,n-1); &#125; ll qpolysum(ll R,ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=powmod(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0;h[0][1]=1; rep(i,1,m+2) &#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2) &#123; ll t=g[i]*g[m+1-i]%mod; if (i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=powmod(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*powmod(R,n)-c)%mod; if (ans&lt;0) ans+=mod; return ans; &#125;&#125; // polysum::init();ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int t,n,i,j; ll ans,a[1111],now,b[1111]; polysum::init(1010); while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); ans=0; sort(a+1,a+1+n); a[0]=0; now=1; for(i=1;i&lt;=n;i++) &#123; if(a[i]==a[i-1]) &#123; (now*=a[i])%=mod; continue; &#125; b[0]=0; for(j=1;j&lt;=n-i+1;j++) &#123; b[j]=j*((pow2(j,n-i+1)-pow2(j-1,n-i+1)%mod)+mod)%mod; &#125; ll tmp=((polysum::polysum(a[i]+1,b,n-i+1)-polysum::polysum(a[i-1]+1,b,n-i+1))%mod+mod)%mod; (ans+=tmp*now%mod)%=mod; (now*=a[i])%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;/*52 3 3 3 5*/","path":"2018/07/19/2018niuke1.F/","date":"07-19","excerpt":""},{"title":"勾股数的性质","text":"转载请注明出处：http://tokitsukaze.live/ 勾股数的基本组及其性质","path":"2018/07/12/PythagoreanTriple/","date":"07-12","excerpt":""},{"title":"Codeforces Round#495 div2E Sonya and Ice Cream (树的直径+滑动窗口+单调队列)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1004/E 题意：给一棵n个顶点的树，树的每条边有权值。我们要找一条链，节点个数在[1,k]范围内，使得不在链上的节点到链上的距离(就是边长的和)的最大值最小。 题解：很明显，最优的链肯定在树的直径上。求出树的直径，对于直径上的每个点x，求出其他能到x的最大距离。然后对树的直径滑窗，用单调队列维护最大值，ans取个min即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/*************************************** head **********************************************/vector&lt;PII &gt; mp[MAX];int mx,rt,fa[MAX],dep[MAX],flag[MAX];void dfs(int x,int pre)&#123; fa[x]=pre; if(pre==-1) dep[x]=0; for(auto to:mp[x]) &#123; if(to.fi==pre) continue; if(flag[to.fi]) continue; dep[to.fi]=dep[x]+to.se; dfs(to.fi,x); &#125; if(mx&lt;dep[x]) &#123; rt=x; mx=dep[x]; &#125;&#125;int dq[MAX],l,r;int main()&#123; int n,k,i,j,a,b,w,ans; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); mem(flag,0); for(i=1;i&lt;n;i++) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;w); mp[a].pb(MP(b,w)); mp[b].pb(MP(a,w)); &#125; mx=0; rt=1; dfs(rt,-1); mx=0; dfs(rt,-1); vector&lt;PII &gt; res; while(~rt) &#123; res.pb(MP(rt,dep[rt])); flag[rt]=1; rt=fa[rt]; &#125; reverse(all(res)); VI len; for(auto it:res) &#123; mx=0; dfs(it.fi,-1); len.pb(mx); // cout&lt;&lt;it.fi&lt;&lt;\" \"&lt;&lt;it.se&lt;&lt;endl; &#125; l=r=0; k=min(k,sz(res)); ans=INF; for(i=0,j=0;i+k-1&lt;sz(res);i++) &#123; while(i+j&lt;k) &#123; while(r-l&amp;&amp;len[dq[r-1]]&lt;len[j]) r--; dq[r++]=j++; &#125; while(r-l&amp;&amp;dq[l]&lt;i) l++; ans=min(ans,max(&#123;res[i].se,res[sz(res)-1].se-res[i+k-1].se,len[dq[l]]&#125;)); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;/*8 61 4 102 4 13 4 14 5 105 6 103 7 12 8 1*/","path":"2018/07/09/cf495.2E/","date":"07-09","excerpt":""},{"title":"CS Academy Round#65 (Div. 2 only) C.Crossing Tree (树的直径+欧拉序)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://csacademy.com/contest/archive/task/crossing-tree/statement/ 题意：给一棵n个顶点的树，让你选择一个起点，把每个点都走一遍。边的长度为1，让你输出路径的长度并按走的顺序输出路径。 题解：记录树的直径，沿着树的直径走，到每个节点再向非树的直径的节点走，走完回到直径上。所以路径长度是(n-dia)*2-1+dia。dia是树的直接的节点个数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/*************************************** head **********************************************/VI mp[MAX],res;int fa[MAX],flag[MAX],rt,mx;void dfs(int x,int pre,int h)&#123; fa[x]=pre; for(auto to:mp[x]) &#123; if(to==pre) continue; dfs(to,x,h+1); &#125; if(h&gt;mx) &#123; mx=h; rt=x; &#125;&#125;void gao(int x,int pre)&#123; res.pb(x); flag[x]=1; for(auto to:mp[x]) &#123; if(to==pre) continue; if(flag[to]) continue; gao(to,x); res.pb(x); &#125;&#125;int main()&#123; int n,i,a,b; while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); res.clear(); mem(flag,0); for(i=0;i&lt;n-1;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; rt=1; mx=-1; dfs(rt,-1,0); mx=-1; dfs(rt,-1,0); VI tmp; while(~rt) &#123; tmp.pb(rt); flag[rt]=1; rt=fa[rt]; &#125; mx++; assert(sz(tmp)==mx); for(auto it:tmp) gao(it,-1); assert(sz(res)-1==(n-mx)*2-1+mx); printf(\"%d\\n\",sz(res)-1); for(i=0;i&lt;sz(res);i++) printf(\"%d%c\",res[i],\" \\n\"[i==sz(res)-1]); &#125; return 0;&#125;","path":"2018/07/09/CSA65.C/","date":"07-09","excerpt":""},{"title":"Codeforces Round#492 div1F Cowmpany Cowmpensation (树形dp+拉格朗日插值法)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/F 题意：给一棵n个顶点的树，树的每个顶点可以赋值[1,d]。求方案数。 题解：可以证明答案为关于d的n次多项式。所以先求出多项式的n+1个点值，然后做拉格朗日插值即可。dp[x][i]表示节点x赋值为i的方案数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=3e3+10;const ll mod=1e9+7;namespace polysum &#123; #define rep(i,a,n) for (int i=a;i&lt;n;i++) #define per(i,a,n) for (int i=n-1;i&gt;=a;i--) const int D=101000; ll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125; ll calcn(int d,ll *a,ll n) &#123; // a[0].. a[d] a[n] if (n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1) &#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1) &#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans=0; rep(i,0,d+1) &#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if ((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; void init(int M) &#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=powmod(f[M+4],mod-2); per(i,1,M+4) g[i]=g[i+1]*(i+1)%mod; &#125; ll polysum(ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] a[m+1]=calcn(m,a,m+1); rep(i,1,m+2) a[i]=(a[i-1]+a[i])%mod; return calcn(m+1,a,n-1); &#125; ll qpolysum(ll R,ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=powmod(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0;h[0][1]=1; rep(i,1,m+2) &#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2) &#123; ll t=g[i]*g[m+1-i]%mod; if (i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=powmod(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*powmod(R,n)-c)%mod; if (ans&lt;0) ans+=mod; return ans; &#125;&#125;// polysum::init();ll dp[MAX][MAX];VI mp[MAX];int main()&#123; int n,d,i,x; polysum::init(3030); while(~scanf(\"%d%d\",&amp;n,&amp;d)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); for(i=2;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); mp[x].pb(i); &#125; function&lt;void(int)&gt; dfs=[&amp;](int x) &#123; ll tmp; for(i=1;i&lt;=n+1;i++) dp[x][i]=1; dp[x][0]=0; for(auto to:mp[x]) &#123; dfs(to); tmp=0; for(i=1;i&lt;=n+1;i++) &#123; (tmp+=dp[to][i])%=mod; (dp[x][i]*=tmp)%=mod; &#125; &#125; &#125;; dfs(1); for(i=1;i&lt;=n+1;i++) (dp[1][i]+=dp[1][i-1])%=mod; printf(\"%lld\\n\",polysum::calcn(n,dp[1]+1,d-1)); &#125; return 0;&#125;","path":"2018/07/07/cf492.1F/","date":"07-07","excerpt":""},{"title":"Codeforces Round#494 div3F Abbreviation (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1003/F 题意：给一篇文章，由n个单词组成。选择连续一段单词进行缩写，然后用缩写替换这篇文章，求替换后文章的最小长度。 题解：容易想到直接暴力，第一个for枚举长度，第二个for枚举缩写的起点，第三个for枚举现在的位置，第四个for是check是否能缩写。复杂度O(n^4)，优化一下可过。思考一下，发现第四个for可以用hash优化掉，复杂度O(n^3)。由于用了固定seed和固定mod，写了个双hash都被hack了…根据tls的建议，rand一下seed，然后mod用1e9+7和1e9+9比较稳(待测试)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=998244353;struct hash_table&#123; ll seed,p; ll Hash[MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(string s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=0;i&lt;n;i++) Hash[i+1]=(Hash[i]*seed%p+(s[i]))%p; &#125; ll get(int l,int r) &#123; return (Hash[r]-Hash[l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;h1,h2;int bit[MAX];int main()&#123; ll hh1,hh2; int n,i,j,k,l,ans,flag,pos,f; string s[333],res,tmp; srand(time(0)); while(~scanf(\"%d\",&amp;n)) &#123; ans=0; bit[0]=0; tmp=\"\"; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i]; ans+=s[i].length(); tmp+=s[i]; if(i!=n) tmp+=' '; bit[i]=bit[i-1]+s[i].length(); if(i!=1) bit[i]++; &#125; ans+=n-1; h1.set(rand(),1e9+7); h1.work(tmp,tmp.length()); h2.set(rand(),1e9+9); h2.work(tmp,tmp.length()); for(i=1;i&lt;=n;i++) &#123; for(j=1;j+2*i-1&lt;=n;j++) &#123; res=\"\"; f=0; for(k=1;k&lt;j;k++) &#123; f=1; res+=s[k]; if(k!=j-1) res+=' '; &#125; for(k=j;k&lt;=j+i-1;k++) &#123; if(f) &#123; res+=' '; f=0; &#125; res+=s[k][0]-'a'+'A'; &#125; hh1=h1.get(bit[j-1]+(j==1?1:2),bit[j+i-1]); hh2=h2.get(bit[j-1]+(j==1?1:2),bit[j+i-1]); k=j+i; f=1; while(k&lt;=n) &#123; flag=0; if(k+i-1&gt;n) flag=1; else &#123; if(h1.get(bit[k-1]+(k==1?1:2),bit[k+i-1])!=hh1) flag=1; if(h2.get(bit[k-1]+(k==1?1:2),bit[k+i-1])!=hh2) flag=1; &#125; if(!flag) &#123; res+=' '; for(pos=k,l=j;pos&lt;=k+i-1&amp;&amp;pos&lt;=n;pos++,l++) &#123; res+=s[pos][0]-'a'+'A'; &#125; k=k+i; f++; &#125; else &#123; res+=' '; res+=s[k]; k++; &#125; &#125; if(f==1) continue; if(ans&gt;sz(res)) tmp=res; ans=min(ans,sz(res)); &#125; &#125; // cout&lt;&lt;tmp&lt;&lt;endl; printf(\"%d\\n\",ans); &#125; return 0;&#125;/*5a a a a a2aa aa*/","path":"2018/07/04/cf494.3F/","date":"07-04","excerpt":""},{"title":"Codeforces Round#494 div3E Tree Constructing (构造)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1003/E 题意：给n，d，k。让你构造一棵n个节点的树，树的直径恰好为d，树的每个节点的度&lt;=k。 题解：首先构造直径，如果不能构造直径就直接NO。h[x]表示到x这个节点的最长树链。in[x]表示x这个节点的度。然后dfs构造即可。最后check一下是不是满足题目要求，不满足就NO。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=4e5+10;const ll mod=998244353;int n,d,k,tot,in[MAX],h[MAX];vector&lt;PII &gt; res;void dfs(int x)&#123; while(1) &#123; if(h[x]+1&gt;d) return; if(in[x]+1&gt;k) return; if(tot==n) return; tot++; in[x]++; in[tot]++; h[tot]=h[x]+1; res.pb(MP(x,tot)); dfs(tot); &#125;&#125;int main()&#123; int i,j,flag; while(~scanf(\"%d%d%d\",&amp;n,&amp;d,&amp;k)) &#123; res.clear(); mem(in,0); mem(h,0); d++; tot=d; if(d&gt;n) &#123; puts(\"NO\"); continue; &#125; for(i=1;i&lt;d;i++) &#123; res.pb(MP(i,i+1)); in[i]++; in[i+1]++; h[i]=max(d-i+1,i); h[i+1]=max(d-i,i+1); &#125; for(i=1;i&lt;=tot;i++) dfs(i); flag=0; for(i=1;i&lt;=n;i++) &#123; if(in[i]&gt;k||h[i]&gt;d) flag=1; &#125; if(tot!=n) flag=1; if(flag) &#123; puts(\"NO\"); continue; &#125; puts(\"YES\"); assert(sz(res)==n-1); for(auto it:res) printf(\"%d %d\\n\",it.fi,it.se); &#125; return 0;&#125;","path":"2018/07/04/cf494.3E/","date":"07-04","excerpt":""},{"title":"Codeforces Round#492 div1E Number Clicker (双向bfs)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/E 题意：给u，v，p。让你从u变成v。有3种操作。1.u-&gt;(u+1)%p2.u-&gt;(u-1+p)%p3.u-&gt;(u^(p-2))%p请输出u变成v的操作过程，操作次数不能超过200次。保证p是素数。 题解：由于p是素数，所以操作3就是个逆元。即若x=(y^(p-2))%p，那么y=(x^(p-2))%p。然后直接双向bfs即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;ll x,y,p;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;map&lt;ll,PLL&gt; pre[2];map&lt;ll,int&gt; flag[2];queue&lt;ll&gt; q[2];void add(ll t,ll a,int id,ll tag)&#123; if(!flag[id][a]) &#123; q[id].push(a); flag[id][a]=1; pre[id][a]=MP(t,tag); &#125;&#125;VL res;void gao(ll t)&#123; ll tmp=t; while(t!=x) &#123; res.pb(pre[0][t].se); t=pre[0][t].fi; &#125; reverse(all(res)); t=tmp; while(t!=y) &#123; res.pb(pre[1][t].se); t=pre[1][t].fi; &#125;&#125; void bfs()&#123; ll t,sz; for(int i=0;i&lt;2;i++) &#123; pre[i].clear(); flag[i].clear(); while(sz(q[0])) q[0].pop(); while(sz(q[1])) q[1].pop(); &#125; q[0].push(x); q[1].push(y); flag[0][x]=1; flag[1][y]=1; pre[0][x]=MP(x,0); pre[1][y]=MP(y,0); res.clear(); while(!q[0].empty()||!q[1].empty()) &#123; sz=sz(q[0]); while(sz--) &#123; t=q[0].front(); q[0].pop(); if(flag[1][t]) &#123; gao(t); return; &#125; add(t,(t+1)%mod,0,1); add(t,(t-1+mod)%mod,0,2); add(t,pow2(t,p-2),0,3); &#125; sz=sz(q[1]); while(sz--) &#123; t=q[1].front(); q[1].pop(); if(flag[0][t]) &#123; gao(t); return; &#125; add(t,(t+1)%mod,1,2); add(t,(t-1+mod)%mod,1,1); add(t,pow2(t,p-2),1,3); &#125; &#125;&#125; int main()&#123; while(~scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;p)) &#123; bfs(); printf(\"%d\\n\",sz(res)); for(int i=0;i&lt;sz(res);i++) printf(\"%lld%c\",res[i],\" \\n\"[i==sz(res)-1]); &#125; return 0;&#125;","path":"2018/07/01/cf492.1E/","date":"07-01","excerpt":""},{"title":"Codeforces Round#492 div2F/div1D Game (数学)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/D 题意：给2^n个数，Allen和Bessie轮流操作，每次操作可以选一个数，sum加上或者不加这个数，每个数只能选一次。Allen想让sum最大，Bessie想让sum最小。让你求sum的期望值。然后有r轮，每轮会改变一个数，每次输出改变后sum的期望值。 题解：观察案例猜了个结论就过了… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;int main()&#123; int n,r,i,x,y; double ans; while(~scanf(\"%d%d\",&amp;n,&amp;r)) &#123; n=1&lt;&lt;n; VI a(n); ans=0; for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]),ans+=a[i]; printf(\"%.6f\\n\",ans/n); for(i=0;i&lt;r;i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); ans-=a[x]; a[x]=y; ans+=a[x]; printf(\"%.6f\\n\",ans/n); &#125; &#125; return 0;&#125;","path":"2018/07/01/cf492.1D/","date":"07-01","excerpt":""},{"title":"Codeforces Round#492 div2C/div1A Tesla (构造)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/A 题意：给4xn的矩阵，第一行和第四行表示停车位，第二行和第三行表示车或者空位。要求把车移到对应的停车位上，输出移动的方案，移动次数&lt;=20000。 题解：如图。每次所有车转一圈，如果移动到对应的车位前面，就移进去。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;int mp[55][55];int m,k;const int n=4;set&lt;int&gt; s;struct node&#123;int id,x,y;&#125;;vector&lt;node&gt; res;PII findpos()&#123; int i,j; for(i=2;i&lt;=3;i++) &#123; for(j=1;j&lt;=m;j++) &#123; if(!mp[i][j]) return MP(i,j); &#125; &#125; return MP(-1,-1);&#125;void move(PII x)&#123; int i,j; i=x.fi; if(i==2) &#123; for(j=x.se;j&lt;m;j++)//&lt;- &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; if(mp[3][m]) res.pb(&#123;mp[3][m],i,m&#125;);//up swap(mp[2][m],mp[3][m]); i=3; for(j=m;j&gt;1;j--)//-&gt; &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; if(x.se!=1) &#123; if(mp[2][1]) res.pb(&#123;mp[2][1],3,1&#125;);//dwon swap(mp[3][1],mp[2][1]); &#125; i=2; for(j=1;j&lt;x.se-1;j++) &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; &#125; else &#123; for(j=x.se;j&gt;1;j--)//-&gt; &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; if(mp[2][1]) res.pb(&#123;mp[2][1],3,1&#125;);//dwon swap(mp[3][1],mp[2][1]); i=2; for(j=1;j&lt;m;j++)//&lt;- &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; if(x.se!=m) &#123; if(mp[3][m]) res.pb(&#123;mp[3][m],i,m&#125;);//up swap(mp[2][m],mp[3][m]); &#125; i=3; for(j=m;j&gt;x.se+1;j--) &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; &#125;&#125;void gao()&#123; int j; for(j=1;j&lt;=m;j++) &#123; if(mp[2][j]&amp;&amp;mp[2][j]==mp[1][j]) &#123; mp[2][j]=0; res.pb(&#123;mp[1][j],1,j&#125;); s.insert(mp[1][j]); &#125; &#125; for(j=1;j&lt;=m;j++) &#123; if(mp[3][j]&amp;&amp;mp[3][j]==mp[4][j]) &#123; mp[3][j]=0; res.pb(&#123;mp[4][j],4,j&#125;); s.insert(mp[4][j]); &#125; &#125;&#125;int main()&#123; int i,j,f; while(~scanf(\"%d%d\",&amp;m,&amp;k)) &#123; mem(mp,0); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;mp[i][j]); &#125; &#125; s.clear(); res.clear(); gao(); PII pre=findpos(); if(pre==MP(-1,-1)) &#123; puts(\"-1\"); continue; &#125; if(pre.fi==2) f=-1; else f=1; while(sz(s)&lt;k) &#123; /* puts(\"*****\"); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; printf(\"%d \",mp[i][j]); &#125; puts(\"\"); &#125;*/ move(pre); gao(); pre.se+=f; if(pre.se==0||pre.se==m+1) &#123; pre.se=(pre.se==0?1:m); f*=-1; pre.fi^=1; &#125; &#125; printf(\"%d\\n\",sz(res)); for(i=0;i&lt;sz(res);i++) printf(\"%d %d %d\\n\",res[i].id,res[i].x,res[i].y); &#125; return 0;&#125;/*4 51 2 3 47 1 2 34 5 6 05 6 7 0*/","path":"2018/07/01/cf492.1A/","date":"07-01","excerpt":""},{"title":"Codeforces edu#46 F.One Occurrence (线段树+扫描线)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/F 题意：给一个序列，q次查询，每次查询区间[L,R]内只出现一次的数字，输出任意一个，如果没有就输出0。 题解：注意到没有修改，所以很容易想到离线做。把查询按R从小到大排序，扫描线扫R，把每一个数的前驱位置插入线段树，那么要查询区间[L,R]内只出现一次的数字，只需要查询区间[L,R]内出现的数的前驱位置的最小值是不是小于L即可。注意，在每次插入之前，如果有前驱的话，要把前驱插入的信息删除，即把位置赋值成INF，这样就避免了查询到的是某个数的前驱的前驱的问题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;struct Segment_Tree&#123; #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; PII v[MAX&lt;&lt;2],qv; void pushup(int id) &#123; v[id]=min(v[ls],v[rs]); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; v[id]=qv; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; PII query(int l,int r,int id) &#123; PII res=MP(INF,INF); if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res=min(res,query(l,mid,ls)); if(qr&gt;mid) res=min(res,query(mid+1,r,rs)); return res; &#125; void upd(int l,int r,PII x) &#123; ql=l; qr=r; qv=x; update(1,n,1); &#125; PII ask(int l,int r) &#123; ql=l; qr=r; return query(1,n,1); &#125; void build(int _n)&#123;n=_n;mem(v,0);&#125; &#125;tr;struct node&#123; int l,r,id; friend bool operator &lt;(node a,node b) &#123; return a.r&lt;b.r; &#125;&#125;;int a[MAX],ans[MAX],pre[MAX],last[MAX];int main()&#123; int n,q,i,l,r,j; while(~scanf(\"%d\",&amp;n)) &#123; mem(last,0); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); if(!last[a[i]]) pre[i]=0; else pre[i]=last[a[i]]; last[a[i]]=i; &#125; tr.build(MAX-10); scanf(\"%d\",&amp;q); vector&lt;node&gt; res; for(i=1;i&lt;=q;i++) &#123; scanf(\"%d%d\",&amp;l,&amp;r); res.pb(node&#123;l,r,i&#125;); &#125; sort(all(res)); r=1; for(i=0;i&lt;sz(res);i++) &#123; while(r&lt;=res[i].r) &#123; if(pre[r]) tr.upd(pre[r],pre[r],MP(INF,INF)); tr.upd(r,r,MP(pre[r],a[r])); r++; &#125; PII tmp=tr.ask(res[i].l,res[i].r); if(tmp.fi&lt;res[i].l) ans[res[i].id]=tmp.se; else ans[res[i].id]=0; &#125; for(i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); &#125; return 0;&#125;","path":"2018/07/01/cfedu46.F/","date":"07-01","excerpt":""},{"title":"Codeforces edu#46 E.We Need More Bosses (无向图tarjan缩点+树的直径)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/E 题意：一条路径上必经的边为关键边，现在让你找一条路径，使得其关键边最多，输出最多的数量。 题解：如果一条路径上面有环，那么这个环的任意一条边都不是关键边。所以先缩点，缩点完变成一棵树，那么在一棵树上找最多的关键边，显然就是求直径。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=3e5+10;const ll mod=1e9+7;namespace Tarjan&#123; int bcc,top,tot,n; vector&lt;int&gt; mp[MAX]; int low[MAX],dfn[MAX],belong[MAX],fa[MAX]; int stk[MAX]; void dfs(int x,int pre) &#123; int to,i,temp,k; stk[top++]=x; low[x]=dfn[x]=++tot; fa[x]=pre; k=0; for(auto to:mp[x]) &#123; if(to==pre&amp;&amp;!k) &#123; k++; continue; &#125; if(!dfn[to]) &#123; dfs(to,x); low[x]=min(low[x],low[to]); &#125; else low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; bcc++; do &#123; temp=stk[--top]; belong[temp]=bcc; &#125;while(temp!=x); &#125; &#125; void work(int _n,vector&lt;int&gt; e[]) &#123; n=_n; for(int i=1;i&lt;=n;i++) &#123; mp[i]=e[i]; low[i]=dfn[i]=fa[i]=stk[i]=0; &#125; bcc=top=tot=0; for(int i=1;i&lt;=n;i++) &#123; if(!dfn[i]) dfs(i,i); &#125; &#125; void rebuild(vector&lt;int&gt; e[]) &#123; int i,t; for(i=1;i&lt;=n;i++) e[i].clear(); for(i=1;i&lt;=n;i++) &#123; t=fa[i]; if(belong[i]!=belong[t]) &#123; e[belong[i]].pb(belong[t]); e[belong[t]].pb(belong[i]); &#125; &#125; &#125;&#125;int Tree_Diameter(const vector&lt;int&gt; e[])&#123; static int h[MAX]; int mx,rt; function&lt;void(int,int)&gt; dfs=[&amp;](int x,int fa) &#123; h[x]=h[fa]+1; for(auto to:e[x]) &#123; if(to==fa) continue; dfs(to,x); &#125; if(h[x]&gt;mx) &#123; mx=h[x]; rt=x; &#125; &#125;; mx=rt=-1; dfs(1,0); dfs(rt,0); return mx;&#125;vector&lt;int&gt; mp[MAX],res[MAX];int main()&#123; int n,m,a,b,i; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); while(m--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; Tarjan::work(n,mp); Tarjan::rebuild(res); printf(\"%d\\n\",Tree_Diameter(res)-1); &#125; return 0;&#125;","path":"2018/06/30/cfedu46.E/","date":"06-30","excerpt":""},{"title":"Codeforces edu#46 D.Yet Another Problem On a Subsequence (dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/D 题意：给一个序列。定义good子序列：满足可以划分为若干个组，每个组的第一个数=这个组的长度-1。求有多少个good子序列。 题解：dp[i]表示以i开头的good子序列的个数。直接倒着转移即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;ll C[1010][1010];void init(int n)&#123; int i,j; for(i=(C[0][0]=1);i&lt;=n;i++) &#123; for(j=(C[i][0]=1);j&lt;=n;j++) &#123; C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; &#125;int main()&#123; int n,i,j,a[MAX]; ll dp[1010]; init(1000); while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); mem(dp,0); dp[n+1]=1; for(i=n;i;i--) &#123; if(a[i]&lt;=0) continue; for(j=n;j-a[i]&gt;=i;j--) &#123; (dp[i]+=dp[j+1]*C[j-i][a[i]]%mod)%=mod; &#125; &#125; for(i=2;i&lt;=n;i++) (dp[1]+=dp[i])%=mod; printf(\"%lld\\n\",dp[1]); &#125; return 0;&#125;","path":"2018/06/30/cfedu46.D/","date":"06-30","excerpt":""},{"title":"Codeforces Round#490 div3F Cards and Joy (01背包)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/F 题意：有n*k张牌，每张牌上写了数字，分给n个人，每人k张。每个人有一个喜欢的数字，分到i张喜欢的牌，得到的价值就是h[i]，问价值最大。 题解：cnt[x]表示写着数字为x的牌的个数。f[x]表示喜欢数字为x的牌的人数。 把cnt[x]看作背包容量，f[x]看作物品个数。对于每个物品，重量为i时，获得的价值为h[i]，(0&lt;=i&lt;=k，h[0]=0)。 其实就是一个01背包。枚举x，做01背包就行了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=998244353;int cnt[MAX],f[MAX],h[MAX],k;ll dp[5050];ll gao(int x)&#123; int i,j,l; if(!f[x]) return 0; for(i=0;i&lt;=cnt[x];i++) dp[i]=0; while(f[x]--) &#123; for(i=cnt[x];i;i--) &#123; for(j=0;i-j&gt;=0&amp;&amp;j&lt;=k;j++) &#123; dp[i]=max(dp[i],dp[i-j]+h[j]); &#125; &#125; &#125;// cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;dp[cnt[x]]&lt;&lt;endl; return dp[cnt[x]];&#125;int main()&#123; int n,i,x; ll ans; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; mem(cnt,0); mem(f,0); for(i=1;i&lt;=n*k;i++) &#123; scanf(\"%d\",&amp;x); cnt[x]++; &#125; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); f[x]++; &#125; h[0]=0; for(i=1;i&lt;=k;i++) scanf(\"%d\",&amp;h[i]); ans=0; for(i=1;i&lt;=MAX-10;i++) ans+=gao(i); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/22/cf490.3F/","date":"06-22","excerpt":""},{"title":"Codeforces Round#490 div3E Reachability from the Capital (强连通缩点染色)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/E 题意：给一个有向图和一个起点，求最少连多少条边，使得从起点出发，可以到达其他所有点。 题解：先从起点开始dfs，把能走到的点标记掉。剩下不能走到的点，进行缩点染色。最后统计一下缩点后，入度为0的点的个数就是答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;int scc,top,tot;vector&lt;int&gt; mp[MAX];int low[MAX],dfn[MAX],belong[MAX];int stk[MAX],flag[MAX];void init(int n)&#123; int i; for(i=1;i&lt;=n;i++) &#123; mp[i].clear(); low[i]=0; dfn[i]=0; stk[i]=0; flag[i]=0; &#125; scc=top=tot=0;&#125;void tarjan(int x)&#123; int to,i,temp; stk[top++]=x; flag[x]=1; low[x]=dfn[x]=++tot; for(i=0;i&lt;mp[x].size();i++) &#123; to=mp[x][i]; if(!dfn[to]) &#123; tarjan(to); low[x]=min(low[x],low[to]); &#125; else if(flag[to]) low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; scc++; do &#123; temp=stk[--top]; flag[temp]=0; belong[temp]=scc; &#125;while(temp!=x); &#125;&#125;int tag[MAX];void dfs(int x)&#123; if(tag[x]) return ; tag[x]=1; for(auto to:mp[x]) &#123; dfs(to); &#125;&#125;int in[MAX];int main()&#123; int n,m,s,a,b,i,j,ans; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s)) &#123; init(n); while(m--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); &#125; mem(tag,0); dfs(s); for(i=1;i&lt;=n;i++) &#123; if(tag[i]) continue; if(!dfn[i]) tarjan(i); &#125; mem(in,0); for(i=1;i&lt;=n;i++) &#123; if(!belong[i]) continue; for(j=0;j&lt;sz(mp[i]);j++) &#123; if(belong[i]!=belong[mp[i][j]]) in[belong[mp[i][j]]]++; &#125; &#125; ans=0; for(i=1;i&lt;=scc;i++) &#123; ans+=(!in[i]); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/06/22/cf490.3E/","date":"06-22","excerpt":""},{"title":"Codeforces Round#490 div3D Equalize the Remainders (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/D 题意：给n个数和一个k，把n个数按%k的余数，分成n/k组，使得每组数的个数都相等。我们一次操作：可以任选某个数，把它的值+1。问操作的最小次数和操作后的序列。 题解：先把数先按%k的余数分好，记录下标，这里为了方便操作，用了queue而不是vector。记余数为i的数的个数为sz[i]，如果sz[i]&gt;n/k，开个栈，把多的那些数存到栈中，如果sz[i]$&lt;$n/k，就把栈中的那些数往里填。先从左往右扫一遍，如果栈中还有多的数，就再扫一遍。 因为操作是把一个数的值+1，而且多的数必须移走。所以多的数往右移一定是最优的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX];queue&lt;int&gt; res[MAX];PLL st[MAX];int n,k,tot;ll ans;void gao()&#123; int i,j,sz; ll tmp; for(i=0;i&lt;k;i++) &#123; while(sz(res[i])&gt;n/k) &#123; st[tot++]=MP(res[i].front(),i); res[i].pop(); &#125; if(sz(res[i])==n/k) continue; sz=sz(res[i]); for(j=0;tot&amp;&amp;j&lt;n/k-sz;j++) &#123; res[i].push(st[tot-1].fi); tmp=i-st[tot-1].se; if(tmp&lt;0) tmp+=k; a[st[tot-1].fi]+=tmp; ans+=tmp; tot--; &#125; &#125;&#125;int main()&#123; int i,j; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(i=0;i&lt;k;i++) &#123; while(!res[i].empty()) res[i].pop(); &#125; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); res[a[i]%k].push(i); &#125; ans=0; tot=0; gao(); gao(); printf(\"%lld\\n\",ans); for(i=1;i&lt;=n;i++) printf(\"%lld%c\",a[i],\" \\n\"[i==n]); &#125; return 0;&#125;/*8 40 0 0 0 2 2 2 28 41 1 1 1 3 3 3 36 20 0 1 1 1 1*/","path":"2018/06/22/cf490.3D/","date":"06-22","excerpt":""},{"title":"Codeforces Round#489 div2E Nastya and King-Shamans (线段树+暴力剪枝)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/E 题意：给一个序列a，q次操作。每次操作单点修改。每次操作后，询问序列a中有没有一个位置满足a[i]=bit[i-1]，如果有，随便输出一个位置，如果没有输出-1。其中bit为前缀和数组。 题解：容易想到建立线段树维护a[i]-bit[i-1]，问题就转化成查询线段树内值为0的位置。记录一个区间最大值maxx，查询时，如果这个区间maxx小于0，说明这个区间内的数全都不满足，直接剪枝，否则一直查询到叶子节点。 看上去很暴力，其实想想是可行的。因为如果要避开这个剪枝，a[i]-bit[i-1]必须大于0（如果等于0的话，也能很快走到叶子节点），那么这个序列假设a[1]=0，那么a[1]就至少为1，a[2]至少为2，a[3]至少为4，以此类推。也就是说，最多走过log个叶子节点，一定能得出答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX];struct Segment_Tree&#123; #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; ll a[MAX],tag[MAX&lt;&lt;2],maxx[MAX&lt;&lt;2],qv; void pushup(int id) &#123; maxx[id]=max(maxx[ls],maxx[rs]); &#125; void pushdown(int id) &#123; if(!tag[id]) return; maxx[ls]+=tag[id]; maxx[rs]+=tag[id]; tag[ls]+=tag[id]; tag[rs]+=tag[id]; tag[id]=0; &#125; void build(int l,int r,int id) &#123; tag[id]=0; maxx[id]=0; if(l==r) &#123; maxx[id]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); pushup(id); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; tag[id]+=qv; maxx[id]+=qv; return; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=-1; if(maxx[id]&lt;0) return -1; if(l==r) &#123; if(maxx[id]==0) return l; return -1; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res=query(l,mid,ls); if(res!=-1) return res; if(qr&gt;mid) res=query(mid+1,r,rs); return res; &#125; void build(int _n)&#123;n=_n;build(1,n,1);&#125;&#125;tr;int main()&#123; int n,i,q; ll x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; tr.a[i]=a[i]-bit[i-1]; &#125; tr.build(n); while(q--) &#123; scanf(\"%d%lld\",&amp;tr.ql,&amp;x); tr.qv=x-a[tr.ql]; a[tr.ql]=x; tr.qr=tr.ql; tr.update(1,n,1); tr.qv*=-1; tr.ql++; tr.qr=n; if(tr.ql&lt;=n) tr.update(1,n,1); tr.ql=1; printf(\"%d\\n\",tr.query(1,n,1)); &#125; &#125; return 0;&#125;","path":"2018/06/19/cf489.2E/","date":"06-19","excerpt":""},{"title":"Codeforces Round#489 div2D Nastya and a Game (暴力)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/D 题意：给一个序列和一个k，求有多少个区间，区间积/区间和=k。 题解：满足题目条件的区间中，非1的数字的个数一定不会超过log个。所以先处理出对于每个数，右边第一个非1的数字的位置。枚举区间左端点，每次暴力跳log次，复杂度O(n64)。有两个需要注意的地方：1.当跳过一段1时，这一段1中可能会有满足条件的右端点，但如果只判断（区间积小于上一个右端点的区间和k，且区间积大于等于（上一个右端点的区间和+跳过的1的个数）*k）的话，会wa13。原因是没有判断区间积是否是k的倍数。2.要用除法判断是否爆ll。不然可能会wa15或者wa133。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX],r[MAX];int main()&#123; ll n,k,i,j,nex,now,ans,pre; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; r[i]=i+1; &#125; bit[n+1]=bit[n]; nex=n+1; for(i=n;i&gt;=1;i--) &#123; while(i&gt;=1&amp;&amp;a[i]==1) r[i--]=nex; r[i]=nex; nex=i; &#125; r[n]=n+1; ans=0; for(i=1;i&lt;=n;i++) &#123; // cout&lt;&lt;r[i]&lt;&lt;endl; now=1; pre=i; for(j=i;j&lt;=n+1;j=r[j]) &#123; if(pre!=j&amp;&amp;now%k==0&amp;&amp;(bit[pre]-bit[i-1])*k&lt;now&amp;&amp;(bit[j-1]-bit[i-1])*k&gt;=now) ans++; if(j==n+1) break; if(now&gt;=4e18/a[j]) break; now*=a[j]; if(now==(bit[j]-bit[i-1])*k) ans++; pre=j; if(j==n) break; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; &#125; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/19/cf489.2D/","date":"06-19","excerpt":""},{"title":"Codeforces Round#488 div1E Nikita and Order Statistics (FFT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/E 题意：给一个序列和一个x，求有多少个区间，区间内小于x的数的个数恰好等于k，输出k为[0,n]的所有答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=2e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(ll i=(a);i&lt;=(b);i++) const double pi=acos(-1); const ll p=1e9+7; const ll maxn=1&lt;&lt;20; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],ll k,ll v) &#123; ll i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,ll l1,ll l2,ll n) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]; rep(i,0,n)a[i]=a[n+i]; return; &#125; ll K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,n)a[i]=((ll)(z[n+i].a+0.5)); &#125;&#125;;ll a[MAX],b[MAX],c[MAX&lt;&lt;1];int main()&#123; ll n,i,k; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; a[0]=0; mem(c,0); c[0]=1; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); a[i]=a[i]&lt;k; a[i]+=a[i-1]; c[a[i]]++; &#125; for(i=0;i&lt;=n;i++) &#123; a[i]=b[n-i]=c[i]; c[i]=0; &#125; FFT::mul(c,a,b,n,n,n); c[0]-=n; c[0]/=2; for(i=0;i&lt;=n;i++) printf(\"%lld%c\",c[i],\" \\n\"[i==n]); &#125; return 0;&#125;","path":"2018/06/18/cf488.1E/","date":"06-18","excerpt":""},{"title":"Codeforces Round#488 div2E/div1C Careful Maneuvering (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/C 题意：在一个平面上有两组点。第一组的横坐标为x=-100，并且没有相同的y。第二组的横坐标为x=100，并且没有相同的y。现在要在x=0处放两个点(可以放在同一个坐标上)，对于那两组点，每一组的点都会对这两个点做射线，并可能命中另一组的点。求命中点的个数最大是多少。 题解：那两个点肯定是在第一组的某个点和第二组的某个点的连线上。所以先枚举每一对点(为了避免出现小数，输入的每个点的y先X2)，连线与x=0相交求出交点A。然后每个点对A做射线，如果能命中另一组的点，就状压标记一下这个点和命中的点。这里的复杂度是O(n^3*log(n))。 然后再暴力枚举两个交点，计算一下两个交点总共能命中多少个点，取max即可。状压我用了bitset(可以直接用ll)，这里的复杂度是O(n^5/64)，其实就是O(n^4)。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int n,m,a[111],b[111];hash_map&lt;int,int&gt; aa,bb;bitset&lt;65&gt; aaa[62][62],bbb[62][62];void gao(int x,int ii,int jj)&#123; int i,tmp; for(i=1;i&lt;=n;i++) &#123; tmp=a[i]+2*(x-a[i]); if(bb.count(tmp)) &#123; aaa[ii][jj][i]=1; bbb[ii][jj][bb[tmp]]=1; &#125; &#125; for(i=1;i&lt;=m;i++) &#123; tmp=b[i]+2*(x-b[i]); if(aa.count(tmp)) &#123; aaa[ii][jj][aa[tmp]]=1; bbb[ii][jj][i]=1; &#125; &#125;&#125;int main()&#123; int i,j,ans,ii,jj; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; aa.clear(); bb.clear(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); a[i]*=2; aa[a[i]]=i; &#125; for(i=1;i&lt;=m;i++) &#123; scanf(\"%d\",&amp;b[i]); b[i]*=2; bb[b[i]]=i; &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; aaa[i][j].reset(); bbb[i][j].reset(); gao(max(a[i],b[j])-abs(a[i]-b[j])/2,i,j); &#125; &#125; ans=0; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; for(ii=i;ii&lt;=n;ii++) &#123; for(jj=j;jj&lt;=m;jj++) &#123; ans=max(ans,(int)(aaa[i][j]|aaa[ii][jj]).count()+(int)(bbb[i][j]|bbb[ii][jj]).count()); &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/06/17/cf488.1C/","date":"06-17","excerpt":""},{"title":"Codeforces Round#488 div2C/div1A Two Squares (几何)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/A 题意：给出两个正方形，一个边与坐标轴平行，另一个边与坐标轴成45度角。 判断这两个正方形是否相交。 题解：判断一个正方形的4个顶点是否在另一个正方形内，然后wa8，少考虑了一种情况：对于这种情况，再判断一个正方形的4条边是否与另外一个正方形的4条边有交点即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int sgn(int x)&#123; if(x&gt;0) return 1; if(x&lt;0) return -1; return 0;&#125;struct Point&#123; int x,y; Point()&#123;&#125; Point(int a,int b) &#123; x=a; y=b; &#125; void input() &#123; scanf(\"%d%d\",&amp;x,&amp;y); &#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,double p)&#123;return Vector(a.x*p,a.y*p);&#125; Vector operator /(Vector a,double p)&#123;return Vector(a.x/p,a.y/p);&#125;int cross(Vector a,Vector b)&#123;return a.x*b.y-a.y*b.x;&#125;int dot(Vector a,Vector b)&#123;return a.x*b.x+a.y*b.y;&#125;bool OnSeg(Point p,Point p1,Point p2)&#123; return sgn(cross(p1-p,p2-p))==0&amp;&amp;sgn(dot(p1-p,p2-p))&lt;=0;&#125;int JudgePointInPolygon(Point p,vector&lt;Point&gt; poly)&#123; int cnt,n,k,d1,d2; cnt=0; n=poly.size(); for(int i=0;i&lt;n;i++) &#123; if(OnSeg(p,poly[i],poly[(i+1)%n])) return 1;//在边上 k=sgn(cross(poly[(i+1)%n]-poly[i],p-poly[i])); d1=sgn(poly[i].y-p.y); d2=sgn(poly[(i+1)%n].y-p.y); if(k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) cnt++; if(k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) cnt--; &#125; if(cnt) return 1;//内部 else return 0;//外部 &#125;int JudgeSegInter(Point a,Point b,Point c,Point d)&#123; double t1,t2,t3,t4; t1=cross(b-a,c-a); t2=cross(b-a,d-a); t3=cross(d-c,a-c); t4=cross(d-c,b-c); return sgn(t1)*sgn(t2)&lt;0&amp;&amp;sgn(t3)*sgn(t4)&lt;0;&#125;int main()&#123; Point x; vector&lt;Point&gt; a,b; int i,j,flag=0; for(i=0;i&lt;4;i++) &#123; x.input(); a.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; x.input(); b.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; for(j=0;j&lt;4;j++) &#123; flag|=JudgeSegInter(a[i],a[(i+1)%4],b[j],b[(j+1)%4]); &#125; &#125; for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(a[i],b); for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(b[i],a); flag?puts(\"YES\"):puts(\"NO\"); return 0;&#125;","path":"2018/06/17/cf488.1A/","date":"06-17","excerpt":""},{"title":"NIT 436 C=A+B (数学)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=436 C=A+B C=A+B。其中C为正偶数，A与B都是素数。 现在给你一个C，让你求出A和B，如果有多种答案，输出任意一种即可，如果不能求出A和B，请输出”-1”(不带引号)。 Input多组数据。 对于每组数据，第一行包括一个正偶数C(2≤C≤10^9)。 Output对于每组数据，如果能求出A和B，请按C=A+B的形式输出，如果不能，请输出”-1”(不带引号)。 Sample Input1046666 Sample Output10=3+746666=23333+23333 Source2017级新生选拔#3 Authortokitsukaze 题解：由哥德巴赫猜想可知，C&gt;2必有解。所以我们特判C=2的情况，然后枚举其中一个素数A，判断B=C-A是不是素数，很容易就能求出一组解。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int prime[MAX];vector&lt;int&gt; p;void init(int n)&#123; int i,j; mem(prime,0); p.clear(); for(i=2;i&lt;=n;i++) &#123; if(prime[i]) continue; p.pb(i); for(j=i+i;j&lt;=n;j+=i) &#123; if(!prime[j]) prime[j]=i; &#125; &#125;&#125;int check(int x)&#123; int i; if(x&lt;2) return 0; for(i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125;int main()&#123; init(sqrt(1e9)); int i,a,b,n; while(~scanf(\"%d\",&amp;n)) &#123; if(n==2) &#123; puts(\"-1\"); continue; &#125; for(i=0;i&lt;sz(p);i++) &#123; if(check(n-p[i])) &#123; a=p[i]; b=n-p[i]; break; &#125; &#125; printf(\"%d=%d+%d\\n\",n,a,b); &#125; return 0;&#125;/*//数据构造 ull llrand()&#123; return ( (((ull)rand()&lt;&lt;24)&amp;0xFF000000ul)| (((ull)rand()&lt;&lt;12)&amp;0x00FFF000ul)| (((ull)rand() )&amp;0x00000FFFul));&#125;int main()&#123; int cas; ll x; char s[111]; mem(s,0); srand(time(0)); for(cas=1;cas&lt;=100;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x=1; while((x&amp;1)&amp;&amp;x&lt;=2) x=llrand()%(mod-7); printf(\"%lld\\n\",x); &#125; x=0; for(cas=101;cas&lt;=150;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x+=2; printf(\"%lld\\n\",x); &#125; for(cas=151;cas&lt;=151;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x=mod-7; printf(\"%lld\\n\",x); &#125; return 0;&#125;*//*//特判程序char IN_FILE[20];char OUT_FILE[20];char USER_ANS[20];char USER_SRC[20];int check(int x)&#123; int i; if(x&lt;2) return 0; for(i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125;int main()&#123; gets(IN_FILE); //输入数据的文件名 gets(OUT_FILE); //标准输出的文件名 gets(USER_ANS); //用户输出的文件名 gets(USER_SRC); //用户源程序的文件名 FILE *IN=fopen(IN_FILE,\"r\"); FILE *OUT=fopen(OUT_FILE,\"r\"); FILE *USER=fopen(USER_ANS,\"r\"); int i,a,b,c,n; char tmp[1111]; fscanf(IN,\"%d\",&amp;n); if(n==2) &#123; fscanf(USER,\"%s\",tmp); return !(strlen(tmp)==2&amp;&amp;tmp[0]=='-'&amp;&amp;tmp[1]=='1'); &#125; c=a=b=0; fscanf(USER,\"%d=%d+%d\",&amp;c,&amp;a,&amp;b); fclose(IN); fclose(USER); if(c&lt;=0||a&lt;=0||b&lt;=0) return 1; if(c!=n) return 1; if(c!=a+b) return 1; if(!check(a)) return 1; if(!check(b)) return 1; return 0;&#125;*/","path":"2018/06/16/NIT436/","date":"06-16","excerpt":""},{"title":"NIT 442 Patrol (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=442 Patrol GF市分为n个区域，编号为1-n。有m个警察在这些区域巡逻，编号为1-m，第i个警察的巡逻区域编号为L[i]，R[i]。巡逻区域可能会有重叠。假设有一个警察请假，这n个区域中，有多少个区域没有警察巡逻。 Input第一行包括一个正整数T(T≤30)，表示T个案例。 对于每个案例： 第一行包括两个正整数n，m(1≤n，m≤10^5)。 接下来m行，每行包括两个正整数L[i]，R[i] (1≤L[i]≤R[i]≤n)。 Output对于每个案例： 第一行输出Case #x:（x表示第i组案例(i从1开始)）。 第二行输出m个整数，每个整数用空格隔开，行末无多余空格。第i个整数表示：若编号为i的警察请假，有多少个区域没有警察巡逻。(1≤i≤m) Sample Input35 31 34 53 46 21 24 59 42 93 44 51 4 Sample OutputCase #1:2 1 0Case #2:4 4Case #3:4 0 0 1 Hint第一个案例： 若编号为1的警察请假，区域1和区域2没有警察巡逻。 若编号为2的警察请假，区域5没有警察巡逻。 若编号为3的警察请假，每个区域还是有至少一个警察巡逻。 第二个案例： 若编号为1的警察请假，区域1、区域2、区域3、区域6没有警察巡逻。 若编号为2的警察请假，区域3、区域4、区域5、区域6没有警察巡逻。 Source2017级新生选拔#3 Authortokitsukaze 题解：先做个前缀和，记录被覆盖的点的个数为sum，再对只被覆盖到一次的点再做前缀和，每次撤销一条线段后的答案就是sum-这条线段内只被覆盖到一次的点的个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int bit[MAX],w[MAX];PII a[MAX];int main()&#123; int n,m,i,j,ans,t,cas=1; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;m); mem(bit,0); mem(w,0); ans=0; for(i=1;i&lt;=m;i++) &#123; scanf(\"%d%d\",&amp;a[i].fi,&amp;a[i].se); bit[a[i].fi]++; bit[a[i].se+1]--; &#125; for(i=1;i&lt;=n;i++) &#123; bit[i]+=bit[i-1]; if(bit[i]) ans++; if(bit[i]==1) w[i]++; w[i]+=w[i-1]; &#125; ans=n-ans; printf(\"Case #%d:\\n\",cas++); for(i=1;i&lt;=m;i++) printf(\"%d%c\",ans+w[a[i].se]-w[a[i].fi-1],\" \\n\"[i==m]); &#125; return 0;&#125;","path":"2018/06/16/NIT442/","date":"06-16","excerpt":""},{"title":"NIT 443 Another Stone Game (sg函数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=443 Another Stone Game 狗风(tokitsukaze)和雪亲王(yukikaze)正在玩一个游戏。有n堆石子，每次可以任选一堆拿。假设你选择的那一堆现在有x个石子，那么你可以拿走： (1) 1个石子。 (2) x个石子。 (3) x的质因数个石子。 两个人轮流拿，狗风先手，每一轮必须拿，最后拿完的人输，问谁有必胜策略。 Input多组数据。 对于每组数据： 第一行包括一个正整数n(1≤n≤10^5)。表示n堆石子 接下来一行包括n个正整数x[i]，(1≤x[i]≤10^5)。表示第i堆有x[i]个石子。 Output如果狗风能赢，输出”tokitsukaze”(不带双引号)。 否则输出”yukikaze”(不带双引号)。 Sample Input21 134 1 11316 Sample Outputtokitsukazetokitsukazeyukikazetokitsukaze Hint第一个样例：因为每堆只有1个石子，狗风先任选一堆拿完，雪亲王必须拿完剩下的一堆，所以狗风必胜。 第二个样例：第一堆有4个石子，如果选第一堆，可以拿走1、2或者4个石子。狗风先手拿走第一堆的1个石子，不管雪亲王怎么拿，狗风必胜。 第三个样例：第一堆有3个石子，如果选第一堆，可以拿走1或者3个石子。狗风如果直接拿走3个石子，狗风就输了，所以狗风不得不拿1个石子。这时候只剩2个石子，可以拿走1或者2个石子。雪亲王可以拿走1个石子，剩下1个石子。到狗风的回合，因为狗风必须拿，所以狗风必输。 第四个样例：第一堆有6个石子，如果选第一堆，可以拿走1、2、3或者6个石子。狗风先手拿走3个石子，剩下3个石子，可以拿走1或者3个石子。雪亲王如果拿走3个石子，她就输了，所以她不得不只拿走1个石子，剩下2个石子。狗风拿走1个石子，剩下一个石子，所以雪亲王必败，狗风必胜。 Source2017级新生选拔#3 Authortokitsukaze 题解：这是一个Anti-SG。先求出sg表，然后运用sj定理。注意尽量优化质因数分解，不然可能会TLE。 关于Anti-SG，请看这里：http://tokitsukaze.live/2018/06/15/(%E8%BD%AC)%E3%80%90%E5%8D%9A%E5%BC%88%E3%80%91Anti,Multi,Every-SG/ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int prime[MAX];vector&lt;int&gt; p;void init(int n)&#123; int i,j; mem(prime,0); p.clear(); for(i=2;i&lt;=n;i++) &#123; if(prime[i]) continue; p.pb(i); for(j=i+i;j&lt;=n;j+=i) &#123; if(!prime[j]) prime[j]=i; &#125; &#125;&#125;vector&lt;int&gt; res;void work(int x)&#123; int t; res.clear(); res.pb(1); while(x&gt;1) &#123; t=prime[x]; if(!t) &#123; res.pb(x); return; &#125; while(x%t==0&amp;&amp;x&gt;1) x/=t; res.pb(t); &#125;&#125;int sg[MAX];void SG(int n)&#123; int i,j,flag[4]; mem(sg,0); for(i=1;i&lt;=n;i++) &#123; mem(flag,0); work(i); res.pb(i); for(j=0;j&lt;sz(res);j++) &#123; flag[sg[i-res[j]]]=1; &#125; for(j=0;;j++) &#123; if(!flag[j]) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125;int x[MAX];int main()&#123; int n,i,ans,tag,maxx; while(~scanf(\"%d\",&amp;n)) &#123; ans=tag=0; maxx=-1; for(i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;x[i]); maxx=max(maxx,x[i]); &#125; init(maxx); SG(maxx); for(i=0;i&lt;n;i++) &#123; ans^=sg[x[i]]; tag+=(sg[x[i]]&gt;1); &#125; if(tag) ans?puts(\"tokitsukaze\"):puts(\"yukikaze\"); else ans?puts(\"yukikaze\"):puts(\"tokitsukaze\"); &#125; return 0;&#125;","path":"2018/06/15/NIT443/","date":"06-15","excerpt":""},{"title":"(转)【博弈】Anti,Multi,Every-SG","text":"原文：http://blog.sina.com.cn/s/blog_51cea4040100h3l9.html 一、Anti-SG 定义：桌子上有N堆石子，游戏者轮流取石子。 每次只能从一堆中取出任意数目的石子，但不能不取。 取走最后一个石子者败。 因为要求是取走最后一个石子的人败，那么，想赢的人，肯定是想，我就要留一个石子让你去取。 所以，我们在考虑条件的时候，就要加上石子数是不是1这个条件了。当然，还有SG函数本身。 贾志豪发明的SJ定理（Sprague Grundy——Jia Zhihao）解决了这个问题。 SJ定理： 对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束。 先手必胜当且仅当：（1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；（2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。 我们提出定理里的两个限制：1、SG函数为不为0。2、有没有某单一游戏的SG函数大于1。 通过这两个限制，我们可以组合出4种情况： （1）SG==0，有某单一游戏的SG&gt;1。 （2）SG!=0，有某单一游戏的SG&gt;1。（必胜SJ） （3）SG==0，无某单一游戏的SG&gt;1。(必胜SJ) （4）SG!=0，无某单一游戏的SG&gt;1。 对于情况（1）： 当SG==0，存在某单一游戏的SG&gt;1，因为SG==0，所以一定存在至少两个单一游戏的SG&gt;1。而一次操作只能改变一个单一游戏的SG值，那么，操作后，一定到情况（2）。所以情况（1）是先手必败。 对于情况（2）： 当SG!=0时，&lt;1&gt;若只有一个单一游戏的SG&gt;1，我们一定可以通过一次操作，使得剩下的单一游戏一共有奇数个1，这样就先手必胜。&lt;2&gt;若不只一个单一游戏的SG&gt;1，我们可以通过一次操作，使得情况变为SG==0，有某单一游戏的SG&gt;1。对于情况（2）来说，都有子状态是必败状态，所以，情况（2）是先手必胜。 对于情况（3）： 当SG==0，并且没有一单一游戏的SG&gt;1，说明这里只存在偶数个1。如果1的个数为0，则先手必胜。如果1个个数大于0，说明一共有偶数个1，依然是先手必胜。 对于情况（4）： 当SG!=0，无某单一游戏的SG&gt;1，说明现在有奇数个SG==1，操作有两种。 &lt;1&gt;将某一单一游戏的SG值变成大于1，转移后SG依然不等于0，且有一个单一游戏的SG&gt;1，这就到了情况（2）。 &lt;2&gt;将一个SG==1的转移为SG==0，这样就到了情况（3）。 所以情况（4）下是先手必败。 二、Multi-SG 定义：Multi-SG游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。 Multi-SG其他规则与SG游戏相同。 关于这个，如果ccy没理解错，就相当于POI1999/2000的Stripes那题。 http://blog.sina.com.cn/s/blog_51cea4040100h37e.html 三、Every-SG 定义：Every-SG 游戏规定，对于还没有结束的单一游戏，游戏者必须对该游戏进行一步决策。 Every-SG 游戏的其他规则与普通SG 游戏相同。 这种类型，可以想成这样，有N组游戏，有N个穿红色衣服的人代表先手，有N个穿蓝色衣服的人代表后手，这个时候，编号相同的人和游戏分到一组游戏，既第i号穿红色衣服人和第i号穿蓝色衣服的人做第i个游戏。游戏开始后，首先所有穿红衣服的人先操作，然后所有穿蓝色衣服的人再操作，这样轮流下去。直到最后还没游戏完的一组，这组如果是红色衣服的人胜利，那么该游戏先手必胜，如果是蓝色衣服的人胜利，就是先手必败。 很明显，Every-SG不仅仅像其他SG那样仅仅跟SG值有关，还与一个游戏的时间长度有关。 如果先手想赢，那么，在做先手必胜的单一游戏时，他肯定是想把战线尽量拉长。在做先手必败的单一游戏时，他肯定是想把游戏尽快结束。 于是我们开一个Step数组。 表示对于先手必胜的单一游戏而言，它最少走好多步胜利。对于先手必败的单一游戏而言，它最多走好多步。 这样，我们只需要看最后所有单一游戏最大的step那组的SG是0还是非0就可以断定是否先手必胜了。 很容易得出： （u是v的子状态） step[v] = 0； （v为终止状态） step[v] = max{step[u]} + 1； （sg[v]&gt;0,sg[u]=0） step[v] = min{step[u]} + 1； （sg[v]==0） 现在需要证明两个东西： （1）先手必胜，step表示的是最少走好多步。 （2）先手必败，step表示的是最多走好多步。 证明（1）： 对于v点，先手必胜。先手总是从sg&gt;1的到sg==0，他可以保证自己每次减少的步数为1。对手每次是从sg==0到sg&gt;1，最少将步数减小1，既对方走的min值所取的结点，如果选其他的，步数反而到那步后还要增加。所以，先手必胜，step表示的是最少走好多步。 （反起想，这也是为什么step第三个递推式是用min的原因。） 证明（2）： 对于v点，先手必败。先手总是从sg==0到sg&gt;1，他可以保证自己每次减少的步数为1。对手每次是从sg&gt;1到sg==0，对手肯定想让战线拉长，那么他只让步数减少1.所以，先手必败，step表示的是最多走好多步。 这里，式子的推导和证明柔和起来看更有利于理解。 值得注意理解的是，这里的最多和最少并不是绝对的最多最少。 对于（1）（2）而言，都是先手保证自己的操作后，看对手操作而决定最多最少。 而这里的最多最少正好等于step也是我们强制先手每次只减少步数1而得来的。 不过，我们是先手嘛，当然可以多个脑壳决定自己了！！！ 贾志豪在证Every-SG时，多证明了一条，就是最大的step为奇数时必胜。 ccy觉得这个虽然好证明，但是何必呢？最多step的那个单一游戏判断下它的SG是不是为0不就可以了吗？ 关于step为奇这个，也说一下。 最终状态，sg[v]==0，step[v]==0，为偶。 每个sg[v]!=0的step是由sg[u]==0的step[u]加上1得到，所以为奇。 每个sg[v]==0的step是由下面sg[u]!=0的step[u]加上1得到，所以为偶。 所以，sg[v]!=0的，step为奇。","path":"2018/06/15/(转)【博弈】Anti,Multi,Every-SG/","date":"06-15","excerpt":""},{"title":"NIT 458 Strictly Increasing Subinterval (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=458 Strictly Increasing Subinterval 给你一个长度为n的序列a，你需要计算严格递增子区间的个数。 Input第一行包括一个正整数T，表示案例个数。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 接下来一行包括n个正整数a[i]，(1≤a[i]≤10^5)。 Output对于每个案例，输出一行，表示答案。 Sample Input261 2 3 4 3 561 2 3 3 2 1 Sample Output139 Hint第一个案例满足题意的区间有：区间长度为1的区间有6个：[1,1]，[2,2]，[3,3]，[4,4]，[5,5]，[6,6]。 区间长度为2的区间有4个：[1,2]，[2,3]，[3,4]，[5,6]。 区间长度为3的区间有2个：[1,3]，[2,4]。 区间长度为4的区间有1个：[1,4]。 所以答案为13。 Source2017级新生选拔#5 Authortokitsukaze 题解：把原序列分成若干个连续的严格递增序列，并要求这些序列是最长的。然后对于每个序列分开计算贡献，最后加起来即为答案。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int n,i,x,now,pre,t; ll ans; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); ans=0; pre=-1; now=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); if(x&gt;pre) now++; else now=1; pre=x; ans+=now; // cout&lt;&lt;now&lt;&lt;endl; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/15/NIT458/","date":"06-15","excerpt":""},{"title":"NIT 445 Length (模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=445 Length 狗风给你一个数字x，希望你告诉她，这个数字转换成二进制后有多长。 Input多组数据。 对于每组数据，第一行包括一个整数x(0≤x≤10^18)。 Output对于每组数据，输出一行，表示答案。 Sample Input411 Sample Output34 Hint4转换成二进制变为100，所以长度为3。11转换成二进制变为1101，所以长度为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可，注意特判x=0的情况。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=5e5+10;const ll mod=1e9+7;int main()&#123; ll x,ans; while(~scanf(\"%lld\",&amp;x)) &#123; assert(x&gt;=0&amp;&amp;x&lt;=1000000000000000000LL); if(x==0) &#123; puts(\"1\"); continue; &#125; ans=0; while(x) &#123; x&gt;&gt;=1; ans++; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/15/NIT445/","date":"06-15","excerpt":""},{"title":"NIT 446 合法序列 (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=446 合法序列 给你一个长度为n的序列A，和一个整数k。如果序列满足条件：abs(Ai-Ai+1)≤k，1≤i＜n，则我们称之为合法序列。现在你可以选择任意两个元素，交换它们，这个操作只能使用一次。请问能不能使原序列变为合法序列。 Input多组数据。 对于每组数据： 第一行包括两个整数n，k (2≤n≤10^5，0≤k≤10^9)。 接下来一行包括n个整数Ai(0≤Ai≤10^9)。 Output对于每个案例，输出一行。 如果原序列已经是合法序列，请输出0。 如果原序列不能变为合法序列，请输出-1。 如果能，请输出交换的两个数的下标(下标从1开始)，输出任意一组可行解即可。 Sample Input4 11 3 2 47 31 2 10 4 7 5 84 21 2 3 44 40 5 10 15 Sample Output1 43 60-1 Hint对于第一个案例，输出1 4或者4 1或者2 3或者3 2都可以。 Source2017级新生选拔#4 Authortokitsukaze 题解： 记录序列中不满足abs(Ai-Ai+1)≤k的位置。如果这样的位置个数&gt;6，答案就是-1。如果这样的位置个数=0，答案就是0。然后枚举每个位置上的数与其他位置上的数交换，check可行性。复杂度O(n)。 原题&amp;官方题解：https://csacademy.com/contest/archive/task/bounded-difference/solution/ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int x[MAX],n,k;int check(int i)&#123; int res=0; if(i&gt;1) &#123; if(abs(x[i]-x[i-1])&gt;k) res|=1; &#125; if(i&lt;n) &#123; if(abs(x[i]-x[i+1])&gt;k) res|=1; &#125; return res;&#125;int main()&#123; int i,j,c,it; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; assert(n&lt;=100000); assert(n&gt;=2); assert(k&gt;=0); assert(k&lt;=1000000000); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x[i]); assert(x[i]&gt;=0); assert(x[i]&lt;=1000000000); &#125; vector&lt;int&gt; res; for(i=1;i&lt;=n;i++) &#123; if(check(i)) res.pb(i); &#125; if(sz(res)==0) puts(\"0\"); else if(sz(res)&gt;6) puts(\"-1\"); else &#123; for(i=0;i&lt;sz(res);i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(res[i]==j) continue; swap(x[j],x[res[i]]); c=0; c|=check(j); for(it=0;it&lt;sz(res);it++) &#123; c|=check(res[it]); &#125; if(!c) &#123; printf(\"%d %d\\n\",j,res[i]); goto end; &#125; swap(x[j],x[res[i]]); &#125; &#125; puts(\"-1\"); end:; &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT446/","date":"06-15","excerpt":""},{"title":"NIT 447 XOR and MAX (01字典树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=447 XOR and MAX 题意很简单。给你一个长度为n的序列，和q次操作。 总共有两种操作： MODIFY x y：将x位置的值改变成y。 QUERY v：把序列中的每个元素都与v异或，并输出操作后序列中的最大值。 Input第一行包括一个正整数T(T&lt;=10)，表示案例个数。 对于每个案例，第一行包括两个正整数n(1≤n≤10^5)，q(1≤q≤10^5)。 接下来一行是n个非负整数a[i] (0≤a[i]≤10^5)。 接下来有q行，每一行包括一个操作。 MODIFY x y：(1≤x≤n)，(0≤y≤10^5) QUERY v：(0≤v≤10^5) Output对于操作“QUERY”，请输出答案。 Sample Input14 31 2 3 4QUERY 5MODIFY 1 6QUERY 7 Sample Output76 Hint原序列为 1 2 3 4 对于第一次操作，序列变为4 7 6 1，所以最大值是7。 对于第二次操作，序列变为 6 7 6 1 对于第三次操作，序列变为1 0 1 6，所以最大值是6。 Source2017级新生选拔#4 Authortokitsukaze 题解： 对原序列建一棵01字典树。变量now表示原始序列每个数异或now为当前序列。 对于修改操作，先把原始那个数从字典树里删掉，然后往字典树里插入now^y，因为now^y^now=y 对于查询操作，先now^=x，然后查询字典树中与now异或的最大值maxx，那么ans=now^maxx。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct Trie&#123; int cnt[18*MAX],val[18*MAX]; void Insert(int x,int pos,int v) &#123; if(pos&lt;0) &#123; cnt[x]++; val[x]=v; return; &#125; Insert((x&lt;&lt;1)|((v&gt;&gt;pos)&amp;1),pos-1,v); cnt[x]=cnt[x&lt;&lt;1]+cnt[x&lt;&lt;1|1]; &#125; void Delete(int x,int pos,int v) &#123; if(pos&lt;0) &#123; cnt[x]--; return; &#125; Delete((x&lt;&lt;1)|((v&gt;&gt;pos)&amp;1),pos-1,v); cnt[x]=cnt[x&lt;&lt;1]+cnt[x&lt;&lt;1|1]; &#125; void clear(int x,int pos) &#123; cnt[x]=0; if(pos&lt;0) return; clear(x&lt;&lt;1,pos-1); clear(x&lt;&lt;1|1,pos-1); &#125; int query(int x,int pos,int v) &#123; if(pos&lt;0) return val[x]; int temp=(v&gt;&gt;pos)&amp;1; temp|=x&lt;&lt;1; if(cnt[temp^1]) return query(temp^1,pos-1,v); return query(temp,pos-1,v); &#125;&#125;Trie;int a[MAX];int main()&#123; int t,i,x,y,n,q,now; char op[12]; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;q); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); Trie.Insert(1,17,a[i]); &#125; now=0; while(q--) &#123; scanf(\"%s\",op); if(op[0]=='M') &#123; scanf(\"%d%d\",&amp;x,&amp;y); Trie.Delete(1,17,a[x]); a[x]=now^y; Trie.Insert(1,17,a[x]); &#125; else &#123; scanf(\"%d\",&amp;x); now^=x; printf(\"%d\\n\",now^Trie.query(1,17,now)); &#125; &#125; Trie.clear(1,17); &#125; return 0;&#125;","path":"2018/06/15/NIT447/","date":"06-15","excerpt":""},{"title":"hexo 文章中插入图片","text":"1.把博客根目录配置文件_config.yml里的post_asset_folder:这个选项设置为true 2.在你的博客根目录下执行这样一句话npm install hexo-asset-image --save 3.等待一小段时间后，再运行hexo n \"xxxx\"来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4.最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![xxxx](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。xxxx和图片名最好用英文，不要有空格。","path":"2018/06/15/hexo 文章中插入图片/","date":"06-15","excerpt":""},{"title":"NIT 448 逆序数 (树状数组)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=448 逆序数 狗风给你一个长度为n的序列，这个序列是1到n的一种排列。然后狗风会进行q次操作。每次操作会给你L R k这三个数，表示区间[L,R]往右移动k次。移动一次的定义是：一个数的位置是P(L≤P≤R-1)，它往右移动后就会在P+1这个位置上；如果一个数在R这个位置，它会移动到L这个位置。在每次操作结束后，狗风想让你算出现在这个序列的逆序数的多少，简单起见，你只需要告诉狗风现在这个序列的逆序数是奇数还是偶数就行了。 提示：序列的逆序数指的是：a[i]&gt;aj，满足条件的(i,j)的个数。 Input第一行包括一个正整数T(T≤5)，表示案例个数。 对于每个案例： 第一行包括一个正整数n(1≤n≤50000)。 接下来一行，包括一个长度为n的序列，序列为1到n的一种排列。 第三行包括一个正整数q(1≤q≤50000)。 接下来q行，每行包括三个正整数L,R,k(1≤L≤R≤n，1≤k≤n)。 所有变量的含义题面均有给出。 Output在每次操作后，逆序数如果是奇数，就输出1，如果是偶数，就输出0。 Sample Input142 3 1 431 3 22 4 12 3 1 Sample Output001 Hint对于第一个案例： 原序列为：2 3 1 4 第一次操作后，序列变为：3 1 2 4，逆序数为2，所以答案为0。 第二次操作后，序列变为：3 4 1 2，逆序数为4，所以答案为0。 第三次操作后，序列变为：3 1 4 2，逆序数为3，所以答案为1。 Source2017级新生选拔#4 Authortokitsukaze 题解：先树状数组求逆序数，然后有个结论。 结论：1到n的排列，任意交换两个数，逆序数奇偶性发生改变。 所以ans=（操作前的序列的逆序数+需要交换多少次才能变成操作后的序列（不需要求最小操作次数））%2。 结论的证明：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=5e4+10;const ll mod=1e9+7;int bit[MAX],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int v)&#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125;&#125;int getsum(int x)&#123; int res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res;&#125;int a[MAX];int main()&#123;// freopen(\"in.txt\",\"r\",stdin);// freopen(\"out.txt\",\"w\",stdout); int t,i,ans,q,l,r,k,len; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); mem(bit,0); ans=0; for(i=n;i&gt;=1;i--) &#123; ans+=getsum(a[i]); update(a[i],1); &#125; ans%=2; scanf(\"%d\",&amp;q); while(q--) &#123; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k); len=r-l+1; k%=len; ans+=(len-1)*k; ans%=2; printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT448/","date":"06-15","excerpt":""},{"title":"NIT 449 帅气的ES(改) (STL/线段树/主席树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=449 帅气的ES(改) 前略 现在ES又有骚操作，他有长度为N的数列，每次他会查询一段区间的和，以及区间内有多少个值 等于 V。 后略 Input输入多组数据，对于每组数据：第一行输入两个整数N，M，M代表有M个询问(1&lt;=N,M&lt;=100000) 。 接下来一行有N个数a[i]，1&lt;=a[i]&lt;=10000000。 接下来M行，每行输入三个整数，L，R，V，代表询问的区间为[L, R]，值是V，1&lt;=L&lt;=R&lt;=N,1&lt;=V&lt;=10000000注：对于N=100000，M=100000，数据有10组。 Output对于每组数据：对于每个询问，输出两个数，第一个数代表区间[L, R]有多少个值等于V，第二个数代表区间[L, R]的和。 Sample Input5 31 1 3 4 41 3 12 4 41 5 1 Sample Output2 51 82 13 Source2017级新生选拔#4 Authortokitsukaze 题解： 因为没有修改，区间和可以用前缀和解决。对于查询区间有多少个数值等于V，有很多种做法。 我的做法（没输入输出外挂，1700+ms）：离散化一下，建n棵动态开点线段树，每次查询直接查V所在的那棵线段树即可。 比较快的做法：开个map&lt;int,vector&lt;int&gt; &gt;，vector里存的是每一种值的下标，查询直接二分vector。 比较慢的做法：主席树(好像能过)，分块(TLE)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;struct Segment_Tree&#123; int tot,ls[MAX*24],rs[MAX*24],v[MAX*24],ql,qr,qv; void init() &#123; ls[0]=rs[0]=0; v[0]=0; tot=1; &#125; int newnode() &#123; ls[tot]=rs[tot]=0; v[tot]=0; return tot++; &#125; void pushup(int id) &#123; v[id]=v[ls[id]]+v[rs[id]]; &#125; void insert(int l,int r,int &amp;id,int pos) &#123; int mid; if(!id) id=newnode(); if(l==r) &#123; v[id]++; return; &#125; mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(l,mid,ls[id],pos); else if(pos&gt;=mid+1) insert(mid+1,r,rs[id],pos); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=0; if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res+=query(l,mid,ls[id]); if(qr&gt;mid) res+=query(mid+1,r,rs[id]); return res; &#125;&#125;tr;ll bit[MAX];int main()&#123; int n,q,i,x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; map&lt;int,int&gt; root; tr.init(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); if(!root.count(x)) root[x]=0; tr.insert(1,n,root[x],i); bit[i]=x; bit[i]+=bit[i-1]; &#125; while(q--) &#123; scanf(\"%d%d%d\",&amp;tr.ql,&amp;tr.qr,&amp;x); printf(\"%d %lld\\n\",tr.query(1,n,root[x]),bit[tr.qr]-bit[tr.ql-1]); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT449/","date":"06-15","excerpt":""},{"title":"NIT 450 极致色彩 (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=450 极致色彩 狗风要在一个n*n的棋盘里摆放放棋子。有a个红色的棋子和b个蓝色的棋子，要求任意两个相同颜色的棋子不相邻，允许有空的格子。狗风想知道棋盘的边长n至少多大，才能摆放完a个红色的棋子和b个蓝色的棋子。 Input多组案例。 第一行包括两个整数a,b(0≤a,b≤10^9)，a和b至少有一个不为零。 Output对于每个案例，输出一个正整数，表示答案。 Sample Input4 50 6 Sample Output34 Hint第一个案例，我们只能这样摆： 蓝红蓝 红蓝红 蓝红蓝 第二个案例，我们可以这样摆： 蓝空蓝空 空蓝空蓝 蓝空蓝空 空空空空 Source2017级新生选拔#4 Authortokitsukaze 题解： 枚举答案，check可行性。复杂度O(sqrt(a+b))。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int a,b;int main()&#123; ll i,now; while(~scanf(\"%d%d\",&amp;a,&amp;b)) &#123; assert(a||b); for(i=1;;i++) &#123; now=i*(i/2); if(i&amp;1) now+=(i+1)/2; if(now&gt;=max(a,b)&amp;&amp;i*i&gt;=a+b) &#123; printf(\"%lld\\n\",i); break; &#125; &#125; &#125; return 0;&#125;/*4 50 6*/","path":"2018/06/15/NIT450/","date":"06-15","excerpt":""},{"title":"NIT 451 等差序列 (FFT计数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=451 等差序列 给你一个长度为n的序列a，你的任务是找到有多少种不同的三元组(i,j,k)，(i,j,k互不相等)，使得a[i]，a[j]，a[k]，为等差序列。 注意：(i,j,k)，(i,k,j)，(j,i,k)，(j,k,i)，(k,i,j)，(k,j,i)视为同一种方案。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)。 第二行包括n个正整数ai。 Output对于每组数据，输出一行，表示答案，答案对10^9+7取模。 Sample Input51 2 3 3 332 1 341 1 1 1366 666 666611 Sample Output41400 Hint第一个案例：(1,2,3),(1,2,4),(1,2,5),(3,4,5)。所以答案为4。 第二个案例：(2,1,3)。所以答案为1。 第三个案例：(1,2,3),(1,2,4),(1,3,4),(2,3,4)。所以答案为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：FFT计数，与hdu 4609做法类似。注意如果在做FFT时取模，去重时除法要逆元。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) const double pi=acos(-1); const int p=1e9+7; const int maxn=(1&lt;&lt;18)+10; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],int k,int v) &#123; int i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,int l1,int l2) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]%p; rep(i,0,l1+l2)a[i]%=p; return; &#125; int K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,l1+l2)a[i]=((ll)(z[i].a+0.5))%p; &#125;&#125;;ll fac[MAX];void init(int n)&#123; ll i; fac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; &#125;&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*inv(fac[m]*fac[n-m]%mod)%mod;&#125;ll cnt[MAX],res[MAX&lt;&lt;1];int main()&#123; int n,i,x,maxx,cas; ll ans; char s[111]; init(1e5); ll inv2=inv(2); while(~scanf(\"%d\",&amp;n)) &#123; assert(n&gt;=1); assert(n&lt;=MAX-10); mem(cnt,0); maxx=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); assert(x&gt;=1); assert(x&lt;=MAX-10); cnt[x]++; maxx=max(maxx,x); &#125; FFT::mul(res,cnt,cnt,maxx,maxx); ans=0; maxx&lt;&lt;=1; for(i=2;i&lt;=maxx;i+=2) &#123; if(!res[i]) continue; res[i]-=cnt[i/2]; res[i]=(res[i]+mod)%mod; res[i]=res[i]*inv2%mod; res[i]-=cnt[i/2]*(cnt[i/2]-1)/2; res[i]=(res[i]+mod)%mod; ans+=res[i]*cnt[i/2]; ans%=mod; ans+=C(cnt[i/2],3); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/14/NIT451/","date":"06-14","excerpt":""},{"title":"NIT 452 Thue–Morse 序列 (模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=452 Thue–Morse 序列 这是一个有趣的二进制序列。F[0]=0，F[1]=01，F[2]=0110，F[3]=01101001，F[4]=0110100110010110…观察可知，这个序列的第n项是由第n-1项与第n-1项按位取反后得到的序列拼接而成。现在狗风得到了第x项的序列(x为正无穷)，她想知道这个序列的前n个字符是什么。 Input第一行包括一个正整数T(T≤1000)，表示T个案例。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 Output对于每个案例，输出一行长度为n的01串。 Sample Input61234532 Sample Output00101101100110101101001100101101001011001101001 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可。这里提供一个非常规写法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int t,n; string s=\"\"; for(int i=0;i&lt;100000;i++) s+='0'+__builtin_popcount(i)%2; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); cout&lt;&lt;s.substr(0,n)&lt;&lt;\"\\n\"; &#125; return 0;&#125;","path":"2018/06/14/NIT452/","date":"06-14","excerpt":""},{"title":"NIT 453 相似字符串 (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=453 相似字符串 狗风获得了一个长度为n，由a-z小写字母组成的字符串。 我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。 操作是这样的：选择一个字符串，把字符串的每个字母都+1(例如‘a’变成‘b’，’z’变成’a’)。比如选择“acdz”，操作一次后变为“bdea”。 现在狗风从字符串中任取两个子串，狗风想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)，表示字符串长度。 第二行包括一个长度为n的字符串。 接下来一行包括一个正整数q(1≤q≤10^5)，表示询问次数。 接下来q行，每行包括3个正整数x，y，len。(1≤x，y≤n)，(1≤len≤n并且1≤x+len-1，y+len-1≤n)。表示查询子串[x…x+len-1]和子串[y…y+len-1]。 n=10^5，q=10^5的数据大约有10组。 Output对于每个查询，输出一行，表示答案。 Sample Input10aabbcdedcz41 3 22 6 24 6 41 10 1 Sample Output13-11 Hint第一个查询的子串为“aa”和“bb”，“aa”变为“bb”需要1次操作，所以相似度为1。 第二个查询的子串为“ab”和“de”，“ab”变为“de”需要3次操作，所以相似度为3。 第三个查询的子串为“bcde”和“dedc”，“bcde”不能变为“dedc”，所以两个字符串不相似，输出-1。 第四个查询的子串为“a”和“z”，“z”变为“a”需要1次操作，所以相似度为1。 Source2017级新生选拔#4 Authortokitsukaze 题解： 预处理：对这个字符串的26种变化做hash。 查询：用差分的方式取出y子串的hash值，然后取出x子串26种变化的hash值，判断有没有一种变化能使x子串的hash值等于y子串的hash值，如果有，假设是第i种变化，那么答案就是min(i,26-i)，如果没有，答案就是-1。 代码： 这里给出双hash的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct hash_table&#123; ll seed,p; ll Hash[26][MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;26;j++) &#123; Hash[j][i]=(Hash[j][i-1]*seed%p+(s[i]-&apos;a&apos;+j)%26)%p; &#125; &#125; &#125; ll get(int l,int r,int id) &#123; return (Hash[id][r]-Hash[id][l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;ha[2];char s[MAX];int main()&#123; int n,i,q,x,y,len,ans; ll tmp; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; assert(n&gt;=1&amp;&amp;n&lt;=100000); scanf(&quot; %[a-z]&quot;,s+1); assert(strlen(s+1)==n); ha[0].set(233333,1e9+7); ha[1].set(19260817,998244353); for(i=0;i&lt;2;i++) ha[i].work(s,n); scanf(&quot;%d&quot;,&amp;q); assert(q&gt;=1&amp;&amp;q&lt;=100000); while(q--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); assert(len&gt;=1); assert(x&gt;=1&amp;&amp;x+len-1&lt;=n); assert(y&gt;=1&amp;&amp;y+len-1&lt;=n); vector&lt;int&gt; res; ans=INF; tmp=ha[0].get(y,y+len-1,0); for(i=0;i&lt;26;i++) if(ha[0].get(x,x+len-1,i)==tmp) res.pb(i); tmp=ha[1].get(y,y+len-1,0); for(i=0;i&lt;sz(res);i++) &#123; if(ha[1].get(x,x+len-1,res[i])==tmp) &#123; ans=min(ans,res[i]); ans=min(ans,26-res[i]); &#125; &#125; if(ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2018/06/14/NIT453/","date":"06-14","excerpt":""},{"title":"2018ICPC西安邀请赛","text":"转载请注明出处：http://tokitsukaze.live/ 西安公费旅游，住在乡下，住宿体验极差，水是黄的床是脏的马桶还能堵，再也不想来了....然后比赛，A题题目错的(知乎见.jpg)，E和A签完到，K看错题意拍上线段树wa，然后发现D是sg板子题，抄完板子1A，然后又发现G是几何，抄完板子1A(幸好没卡精度)，然后看榜发现在金牌区，而且C和K感觉都能过。然后两个队友yy了K的分块解法，一屁股坐上来就再也没下去过，最后wa还不知道哪写错了。期间我看完I感觉不好做，去看过的人多的C。然后贪心贪到封榜，怎么贪感觉都有反例，这时候我觉得肯定是dp，甩锅给队友，队友不接锅...结果赛后队友一眼秒了emmmmm终榜：http://acm.nwpu.edu.cn/static/frontpage/board/index.html..","path":"2018/05/20/2018ICPCxian/","date":"05-20","excerpt":""},{"title":"2018浙江省赛","text":"转载请注明出处：http://tokitsukaze.live/ 这省赛是打的最气的一次现场赛。开场1小时过完5个签到题，感觉顺的一逼。接着开了两个新题。我开的那道题很快就有了正解，然后一敲，TLE。仔细想想是n*log(n)^2的复杂度，肯定会TLE，于是一直在思考怎么抠掉一个log。zyf和chy开了一道dp(贪心)，一直在搞。然后讨论的差不多了(?)chy就开了个新题，是个构造题，没啥想法，扔了。期间我想不出怎么抠掉那个log，跟队友讲了一下思路，也都没啥想法，然后zyf那个题也是各种WA，于是就陷入僵局。然后chy开了一个大模拟，又是WA到死。因为我不怎么会dp，无法参与zyf的题，我也不会麻将()，无法参与chy的题，于是只能死磕我的题。所以接下来的场景就是，我坐上去改改，TLE，zfy上去改改，WA，chy上去改改，WA。然后就结束了。也就是说，开场过了5个签到后，3个人开始进入梦游状态，然后最后打铁了。 气的原因最主要是，回来一搜题解，发现全是n*log(n)^2的复杂度。几天后py了zoj的管理员，把现场赛我的TLE的代码贴出来，居然AC了！！！而且还是跑的飞快的那种，woc瞬间被气的半死，只能说可能zoj的数据比现场赛的数据弱。然后大概15天后突然想出怎么抠掉那个log...只能怪自己菜了。 直到这场，连着打了3个铁(CCPC杭州，ECL，浙江省赛)，心态略崩TAT。 榜：http://acm.zju.edu.cn/zjp2018/board/index.html?filter=type1","path":"2018/04/30/2018zhejiangshengsai/","date":"04-30","excerpt":""},{"title":"「艦これ」2018三月作戦rank13","text":"转载请注明出处：http://tokitsukaze.live/","path":"2018/04/28/KancolleSenka2018.03/","date":"04-28","excerpt":""},{"title":"「艦これ」「2018冬」捷号決戦！邀撃、レイテ沖海戦(後篇)","text":"转载请注明出处：http://tokitsukaze.live/ ——————————————————E7——————————————————「E7P1斩杀」 「E7P2斩杀」 —————————————————完结撒花—————————————————","path":"2018/02/24/KancolleInvent2018winter/","date":"02-24","excerpt":""},{"title":"2017ICPC上海ECL-Final","text":"转载请注明出处：http://tokitsukaze.live/ 在杭州ccpc区域赛丢人后，这次又去上海ECL-final丢人了。换了个队友。第一天热身赛，编译器炸了一个多小时...体验极差。然后发的里面有80元的饭卡，吃了两餐剩50多，于是晚上去洗劫超市，提了一袋吃的回来...第二天正式赛，我从前往后读题，zyf从后往前，chy开编译器。A题排列组合，翻了一下数学手册，理论AC，上去打了一发假代码，贡献了一发罚时。这时候chy上来切掉了M。然后换我改了改A，过了。然后他们告诉我K读不懂，我接手K。他们L（是个博弈题）推了一波，打了一发，WA。这时候我看懂了K，想了想不就是二分一下前缀和，上来打了一发，超时，又贡献了一发罚时。这时候我发现我把n范围1e9看成了1e5，加了个条件break，过了。然后让我接手L，他们看J。我推了20分钟，放弃（博弈实在不行），他们J也陷入僵局。我看了一下榜，决定开B，让他们开C。然后我瞎打了一发B，没过案例，被chy抢走键盘，莽了一发C，WA。跟chy说了一下B，纠正了思路，我继续调B。然后案例过了，莽了一发，WA。这时候chy又莽来一发C，AC。这时已经快封榜了，我和chy继续搞B，zyf想J。最后半小时，chy改了改B，WA。换zyf打J，WA。又换chy改了改B，又WA，接着又换zyf改了改J，又WA。于是最后4题打铁。赛后题解，B大体思路对，不知道哪有问题。J最开始方向也是对的，但是没有细想很快就被枪毙掉了。L这个博弈，结论对了一半，要是暴力一发找规律，说不定能过。只能怪自己太菜（他们怎么都会啊...）。不过毕竟是final，虽然参赛队比较多，但牌也不是那么好拿的。然后就是，上海大学真tm有钱，还有这个狗牌也做的相当不错（甚至还能用来洗劫超市，emmmm）。PS:丢人丢到gym上了榜：http://codeforces.com/gym/101775/standings","path":"2017/12/17/2017ICPCshanghaiECL-Final/","date":"12-17","excerpt":""},{"title":"2017CCPC杭州赛区","text":"转载请注明出处：http://tokitsukaze.live/ 第一次区域赛，杭州赛区丢人打铁，被数学题按在地上摩擦。起手慢了，队友16分钟过了A，然后分别看BCD，过了一会儿系统提示J案例翻车要重判，看了一眼发现提交了一堆人，看了一下题，跟队友讨论了两分钟，我上去切了，在51分钟过了J。然后B要用到欧拉函数，我拍了个板子上去给队友找规律，D是随机构造树，随机一个节点求子树节点和的期望，直觉可做，就去看D。推了半小时D，上来打了10几分钟，在120分钟切了D，期间队友在讨论C，是个博弈。然后队友C写了个假算法wa了一发后接着推B，我接手C。C陷入僵局，看了眼K，直觉二分或者三分，但是有个式子不会处理，放弃K继续想C（赛后据说K是树状数组+二分答案）。然后继续陷入僵局。240分钟左右，B稍微有点成型，队友瞎敲一波，我帮忙debug。在280分钟过了案例，然后tle了..赛后出来交流了一波，思路没错，可惜没时间优化，最后3题首离铜线差6名...","path":"2017/11/05/2017CCPChangzhou/","date":"11-05","excerpt":""},{"title":"2017宁波市市赛","text":"转载请注明出处：http://tokitsukaze.live/ A忘longlong C忘特判n=1 Ewa几发 GwaN发 唯一一道1A的J bfs水过（我的首A 不！！.jgp） 然后最后翻车在F上 算了一下罚时好像就算A出来也拿不到银 （强行安慰） 保铜冲银 最终还是咸鱼...","path":"2017/05/13/2017ningboshisai/","date":"05-13","excerpt":""},{"title":"2017浙江大学校赛","text":"转载请注明出处：http://tokitsukaze.live/ 公费旅游+骗吃骗喝+日常翻车 1小时a掉2题 然后C题我的思路太繁琐了 强行分类讨论 打一半就不想打然后队友接盘 然后我去看G wa了一发发现思路不对 然后其他题又不是很好做 于是三个人就开始肛C 然后各种翻车...学了两个月算法结果在xjb搞的题上翻车..人生如此艰难.jpg","path":"2017/04/09/2017ZJUxiaosai/","date":"04-09","excerpt":""},{"title":"「艦これ」2017一月作戦rank20","text":"转载请注明出处：http://tokitsukaze.live/","path":"2017/02/25/KancolleSenka2017.01/","date":"02-25","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2016/09/23/hello-world/","date":"09-23","excerpt":""}]}