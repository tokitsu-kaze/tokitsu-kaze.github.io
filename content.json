{"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-14","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-14","excerpt":""}],"posts":[{"title":"hexo 文章中插入图片","text":"1.把博客根目录配置文件_config.yml里的post_asset_folder:这个选项设置为true 2.在你的博客根目录下执行这样一句话npm install hexo-asset-image --save 3.等待一小段时间后，再运行hexo n \"xxxx\"来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4.最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![xxxx](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。xxxx和图片名最好用英文，不要有空格。","path":"2018/06/15/hexo 文章中插入图片/","date":"06-15","excerpt":""},{"title":"NIT 448 逆序数 (树状数组)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=448 逆序数 狗风给你一个长度为n的序列，这个序列是1到n的一种排列。然后狗风会进行q次操作。每次操作会给你L R k这三个数，表示区间[L,R]往右移动k次。移动一次的定义是：一个数的位置是P(L≤P≤R-1)，它往右移动后就会在P+1这个位置上；如果一个数在R这个位置，它会移动到L这个位置。在每次操作结束后，狗风想让你算出现在这个序列的逆序数的多少，简单起见，你只需要告诉狗风现在这个序列的逆序数是奇数还是偶数就行了。 提示：序列的逆序数指的是：a[i]&gt;aj，满足条件的(i,j)的个数。 Input第一行包括一个正整数T(T≤5)，表示案例个数。 对于每个案例： 第一行包括一个正整数n(1≤n≤50000)。 接下来一行，包括一个长度为n的序列，序列为1到n的一种排列。 第三行包括一个正整数q(1≤q≤50000)。 接下来q行，每行包括三个正整数L,R,k(1≤L≤R≤n，1≤k≤n)。 所有变量的含义题面均有给出。 Output在每次操作后，逆序数如果是奇数，就输出1，如果是偶数，就输出0。 Sample Input142 3 1 431 3 22 4 12 3 1 Sample Output001 Hint对于第一个案例： 原序列为：2 3 1 4 第一次操作后，序列变为：3 1 2 4，逆序数为2，所以答案为0。 第二次操作后，序列变为：3 4 1 2，逆序数为4，所以答案为0。 第三次操作后，序列变为：3 1 4 2，逆序数为3，所以答案为1。 Source2017级新生选拔#4 Authortokitsukaze 题解：先树状数组求逆序数，然后有个结论。 结论：1到n的排列，任意交换两个数，逆序数奇偶性发生改变。 所以ans=（操作前的序列的逆序数+需要交换多少次才能变成操作后的序列（不需要求最小操作次数））%2。 结论的证明：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=5e4+10;const ll mod=1e9+7;int bit[MAX],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int v)&#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125;&#125;int getsum(int x)&#123; int res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res;&#125;int a[MAX];int main()&#123;// freopen(\"in.txt\",\"r\",stdin);// freopen(\"out.txt\",\"w\",stdout); int t,i,ans,q,l,r,k,len; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); mem(bit,0); ans=0; for(i=n;i&gt;=1;i--) &#123; ans+=getsum(a[i]); update(a[i],1); &#125; ans%=2; scanf(\"%d\",&amp;q); while(q--) &#123; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k); len=r-l+1; k%=len; ans+=(len-1)*k; ans%=2; printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT448/","date":"06-15","excerpt":""},{"title":"NIT 449 帅气的ES(改) (STL/线段树/主席树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=449 帅气的ES(改) 前略 现在ES又有骚操作，他有长度为N的数列，每次他会查询一段区间的和，以及区间内有多少个值 等于 V。 后略 Input输入多组数据，对于每组数据：第一行输入两个整数N，M，M代表有M个询问(1&lt;=N,M&lt;=100000) 。 接下来一行有N个数a[i]，1&lt;=a[i]&lt;=10000000。 接下来M行，每行输入三个整数，L，R，V，代表询问的区间为[L, R]，值是V，1&lt;=L&lt;=R&lt;=N,1&lt;=V&lt;=10000000注：对于N=100000，M=100000，数据有10组。 Output对于每组数据：对于每个询问，输出两个数，第一个数代表区间[L, R]有多少个值等于V，第二个数代表区间[L, R]的和。 Sample Input5 31 1 3 4 41 3 12 4 41 5 1 Sample Output2 51 82 13 Source2017级新生选拔#4 Authortokitsukaze 题解： 因为没有修改，区间和可以用前缀和解决。对于查询区间有多少个数值等于V，有很多种做法。 我的做法（没输入输出外挂，1700+ms）：离散化一下，建n棵动态开点线段树，每次查询直接查V所在的那棵线段树即可。 比较快的做法：开个map&lt;int,vector&lt;int&gt; &gt;，vector里存的是每一种值的下标，查询直接二分vector。 比较慢的做法：主席树(好像能过)，分块(TLE)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;struct Segment_Tree&#123; int tot,ls[MAX*24],rs[MAX*24],v[MAX*24],ql,qr,qv; void init() &#123; ls[0]=rs[0]=0; v[0]=0; tot=1; &#125; int newnode() &#123; ls[tot]=rs[tot]=0; v[tot]=0; return tot++; &#125; void pushup(int id) &#123; v[id]=v[ls[id]]+v[rs[id]]; &#125; void insert(int l,int r,int &amp;id,int pos) &#123; int mid; if(!id) id=newnode(); if(l==r) &#123; v[id]++; return; &#125; mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(l,mid,ls[id],pos); else if(pos&gt;=mid+1) insert(mid+1,r,rs[id],pos); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=0; if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res+=query(l,mid,ls[id]); if(qr&gt;mid) res+=query(mid+1,r,rs[id]); return res; &#125;&#125;tr;ll bit[MAX];int main()&#123; int n,q,i,x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; map&lt;int,int&gt; root; tr.init(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); if(!root.count(x)) root[x]=0; tr.insert(1,n,root[x],i); bit[i]=x; bit[i]+=bit[i-1]; &#125; while(q--) &#123; scanf(\"%d%d%d\",&amp;tr.ql,&amp;tr.qr,&amp;x); printf(\"%d %lld\\n\",tr.query(1,n,root[x]),bit[tr.qr]-bit[tr.ql-1]); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT449/","date":"06-15","excerpt":""},{"title":"NIT 450 极致色彩 (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=450 极致色彩 狗风要在一个n*n的棋盘里摆放放棋子。有a个红色的棋子和b个蓝色的棋子，要求任意两个相同颜色的棋子不相邻，允许有空的格子。狗风想知道棋盘的边长n至少多大，才能摆放完a个红色的棋子和b个蓝色的棋子。 Input多组案例。 第一行包括两个整数a,b(0≤a,b≤10^9)，a和b至少有一个不为零。 Output对于每个案例，输出一个正整数，表示答案。 Sample Input4 50 6 Sample Output34 Hint第一个案例，我们只能这样摆： 蓝红蓝 红蓝红 蓝红蓝 第二个案例，我们可以这样摆： 蓝空蓝空 空蓝空蓝 蓝空蓝空 空空空空 Source2017级新生选拔#4 Authortokitsukaze 题解： 枚举答案，check可行性。复杂度O(sqrt(a+b))。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int a,b;int main()&#123; ll i,now; while(~scanf(\"%d%d\",&amp;a,&amp;b)) &#123; assert(a||b); for(i=1;;i++) &#123; now=i*(i/2); if(i&amp;1) now+=(i+1)/2; if(now&gt;=max(a,b)&amp;&amp;i*i&gt;=a+b) &#123; printf(\"%lld\\n\",i); break; &#125; &#125; &#125; return 0;&#125;/*4 50 6*/","path":"2018/06/15/NIT450/","date":"06-15","excerpt":""},{"title":"NIT 451 等差序列 (FFT计数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=451 等差序列 给你一个长度为n的序列a，你的任务是找到有多少种不同的三元组(i,j,k)，(i,j,k互不相等)，使得a[i]，a[j]，a[k]，为等差序列。 注意：(i,j,k)，(i,k,j)，(j,i,k)，(j,k,i)，(k,i,j)，(k,j,i)视为同一种方案。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)。 第二行包括n个正整数ai。 Output对于每组数据，输出一行，表示答案，答案对10^9+7取模。 Sample Input51 2 3 3 332 1 341 1 1 1366 666 666611 Sample Output41400 Hint第一个案例：(1,2,3),(1,2,4),(1,2,5),(3,4,5)。所以答案为4。 第二个案例：(2,1,3)。所以答案为1。 第三个案例：(1,2,3),(1,2,4),(1,3,4),(2,3,4)。所以答案为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：FFT计数，与hdu 4609做法类似。注意如果在做FFT时取模，去重时除法要逆元。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) const double pi=acos(-1); const int p=1e9+7; const int maxn=(1&lt;&lt;18)+10; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],int k,int v) &#123; int i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,int l1,int l2) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]%p; rep(i,0,l1+l2)a[i]%=p; return; &#125; int K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,l1+l2)a[i]=((ll)(z[i].a+0.5))%p; &#125;&#125;;ll fac[MAX];void init(int n)&#123; ll i; fac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; &#125;&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*inv(fac[m]*fac[n-m]%mod)%mod;&#125;ll cnt[MAX],res[MAX&lt;&lt;1];int main()&#123; int n,i,x,maxx,cas; ll ans; char s[111]; init(1e5); ll inv2=inv(2); while(~scanf(\"%d\",&amp;n)) &#123; assert(n&gt;=1); assert(n&lt;=MAX-10); mem(cnt,0); maxx=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); assert(x&gt;=1); assert(x&lt;=MAX-10); cnt[x]++; maxx=max(maxx,x); &#125; FFT::mul(res,cnt,cnt,maxx,maxx); ans=0; maxx&lt;&lt;=1; for(i=2;i&lt;=maxx;i+=2) &#123; if(!res[i]) continue; res[i]-=cnt[i/2]; res[i]=(res[i]+mod)%mod; res[i]=res[i]*inv2%mod; res[i]-=cnt[i/2]*(cnt[i/2]-1)/2; res[i]=(res[i]+mod)%mod; ans+=res[i]*cnt[i/2]; ans%=mod; ans+=C(cnt[i/2],3); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/14/NIT451/","date":"06-14","excerpt":""},{"title":"NIT 452 Thue–Morse 序列 (模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=452 Thue–Morse 序列 这是一个有趣的二进制序列。F[0]=0，F[1]=01，F[2]=0110，F[3]=01101001，F[4]=0110100110010110…观察可知，这个序列的第n项是由第n-1项与第n-1项按位取反后得到的序列拼接而成。现在狗风得到了第x项的序列(x为正无穷)，她想知道这个序列的前n个字符是什么。 Input第一行包括一个正整数T(T≤1000)，表示T个案例。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 Output对于每个案例，输出一行长度为n的01串。 Sample Input61234532 Sample Output00101101100110101101001100101101001011001101001 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可。这里提供一个非常规写法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int t,n; string s=\"\"; for(int i=0;i&lt;100000;i++) s+='0'+__builtin_popcount(i)%2; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); cout&lt;&lt;s.substr(0,n)&lt;&lt;\"\\n\"; &#125; return 0;&#125;","path":"2018/06/14/NIT452/","date":"06-14","excerpt":""},{"title":"NIT 453 相似字符串 (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=453 相似字符串 狗风获得了一个长度为n，由a-z小写字母组成的字符串。 我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。 操作是这样的：选择一个字符串，把字符串的每个字母都+1(例如‘a’变成‘b’，’z’变成’a’)。比如选择“acdz”，操作一次后变为“bdea”。 现在狗风从字符串中任取两个子串，狗风想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤105)，表示字符串长度。 第二行包括一个长度为n的字符串。 接下来一行包括一个正整数q(1≤q≤105)，表示询问次数。 接下来q行，每行包括3个正整数x，y，len。(1≤x，y≤n)，(1≤len≤n并且1≤x+len-1，y+len-1≤n)。表示查询子串[x…x+len-1]和子串[y…y+len-1]。 n=105，q=105的数据大约有10组。 Output对于每个查询，输出一行，表示答案。 Sample Input10aabbcdedcz41 3 22 6 24 6 41 10 1 Sample Output13-11 Hint第一个查询的子串为“aa”和“bb”，“aa”变为“bb”需要1次操作，所以相似度为1。 第二个查询的子串为“ab”和“de”，“ab”变为“de”需要3次操作，所以相似度为3。 第三个查询的子串为“bcde”和“dedc”，“bcde”不能变为“dedc”，所以两个字符串不相似，输出-1。 第四个查询的子串为“a”和“z”，“z”变为“a”需要1次操作，所以相似度为1。 Source2017级新生选拔#4 Authortokitsukaze 题解： 预处理：对这个字符串的26种变化做hash。 查询：用差分的方式取出y子串的hash值，然后取出x子串26种变化的hash值，判断有没有一种变化能使x子串的hash值等于y子串的hash值，如果有，假设是第i种变化，那么答案就是min(i,26-i)，如果没有，答案就是-1。 代码： 这里给出双hash的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct hash_table&#123; ll seed,p; ll Hash[26][MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;26;j++) &#123; Hash[j][i]=(Hash[j][i-1]*seed%p+(s[i]-&apos;a&apos;+j)%26)%p; &#125; &#125; &#125; ll get(int l,int r,int id) &#123; return (Hash[id][r]-Hash[id][l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;ha[2];char s[MAX];int main()&#123; int n,i,q,x,y,len,ans; ll tmp; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; assert(n&gt;=1&amp;&amp;n&lt;=100000); scanf(&quot; %[a-z]&quot;,s+1); assert(strlen(s+1)==n); ha[0].set(233333,1e9+7); ha[1].set(19260817,998244353); for(i=0;i&lt;2;i++) ha[i].work(s,n); scanf(&quot;%d&quot;,&amp;q); assert(q&gt;=1&amp;&amp;q&lt;=100000); while(q--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); assert(len&gt;=1); assert(x&gt;=1&amp;&amp;x+len-1&lt;=n); assert(y&gt;=1&amp;&amp;y+len-1&lt;=n); vector&lt;int&gt; res; ans=INF; tmp=ha[0].get(y,y+len-1,0); for(i=0;i&lt;26;i++) if(ha[0].get(x,x+len-1,i)==tmp) res.pb(i); tmp=ha[1].get(y,y+len-1,0); for(i=0;i&lt;sz(res);i++) &#123; if(ha[1].get(x,x+len-1,res[i])==tmp) &#123; ans=min(ans,res[i]); ans=min(ans,26-res[i]); &#125; &#125; if(ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2018/06/14/NIT453/","date":"06-14","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/06/13/hello-world/","date":"06-13","excerpt":""}]}