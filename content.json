{"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-14","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-14","excerpt":""}],"posts":[{"title":"NIT 451 等差序列(FFT计数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=451 等差序列 给你一个长度为n的序列a，你的任务是找到有多少种不同的三元组(i,j,k)，(i,j,k互不相等)，使得a[i]，a[j]，a[k]，为等差序列。 注意：(i,j,k)，(i,k,j)，(j,i,k)，(j,k,i)，(k,i,j)，(k,j,i)视为同一种方案。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)。 第二行包括n个正整数ai。 Output对于每组数据，输出一行，表示答案，答案对10^9+7取模。 Sample Input51 2 3 3 332 1 341 1 1 1366 666 666611 Sample Output41400 Hint第一个案例：(1,2,3),(1,2,4),(1,2,5),(3,4,5)。所以答案为4。 第二个案例：(2,1,3)。所以答案为1。 第三个案例：(1,2,3),(1,2,4),(1,3,4),(2,3,4)。所以答案为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：FFT计数，与hdu 4609做法类似。注意如果在做FFT时取模，去重时除法要逆元。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) const double pi=acos(-1); const int p=1e9+7; const int maxn=(1&lt;&lt;18)+10; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],int k,int v) &#123; int i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,int l1,int l2) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]%p; rep(i,0,l1+l2)a[i]%=p; return; &#125; int K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,l1+l2)a[i]=((ll)(z[i].a+0.5))%p; &#125;&#125;;ll fac[MAX];void init(int n)&#123; ll i; fac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; &#125;&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*inv(fac[m]*fac[n-m]%mod)%mod;&#125;ll cnt[MAX],res[MAX&lt;&lt;1];int main()&#123; int n,i,x,maxx,cas; ll ans; char s[111]; init(1e5); ll inv2=inv(2); while(~scanf(\"%d\",&amp;n)) &#123; assert(n&gt;=1); assert(n&lt;=MAX-10); mem(cnt,0); maxx=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); assert(x&gt;=1); assert(x&lt;=MAX-10); cnt[x]++; maxx=max(maxx,x); &#125; FFT::mul(res,cnt,cnt,maxx,maxx); ans=0; maxx&lt;&lt;=1; for(i=2;i&lt;=maxx;i+=2) &#123; if(!res[i]) continue; res[i]-=cnt[i/2]; res[i]=(res[i]+mod)%mod; res[i]=res[i]*inv2%mod; res[i]-=cnt[i/2]*(cnt[i/2]-1)/2; res[i]=(res[i]+mod)%mod; ans+=res[i]*cnt[i/2]; ans%=mod; ans+=C(cnt[i/2],3); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/14/NIT 451 等差序列(FFT计数)/","date":"06-14","excerpt":""},{"title":"NIT 452 Thue–Morse 序列(模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=452 Thue–Morse 序列 这是一个有趣的二进制序列。F[0]=0，F[1]=01，F[2]=0110，F[3]=01101001，F[4]=0110100110010110…观察可知，这个序列的第n项是由第n-1项与第n-1项按位取反后得到的序列拼接而成。现在狗风得到了第x项的序列(x为正无穷)，她想知道这个序列的前n个字符是什么。 Input第一行包括一个正整数T(T≤1000)，表示T个案例。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 Output对于每个案例，输出一行长度为n的01串。 Sample Input61234532 Sample Output00101101100110101101001100101101001011001101001 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可。这里提供一个非常规写法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int t,n; string s=\"\"; for(int i=0;i&lt;100000;i++) s+='0'+__builtin_popcount(i)%2; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); cout&lt;&lt;s.substr(0,n)&lt;&lt;\"\\n\"; &#125; return 0;&#125;","path":"2018/06/14/NIT 452 Thue–Morse 序列(模拟)/","date":"06-14","excerpt":""},{"title":"NIT 453 相似字符串(hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=453 相似字符串 狗风获得了一个长度为n，由a-z小写字母组成的字符串。 我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。 操作是这样的：选择一个字符串，把字符串的每个字母都+1(例如‘a’变成‘b’，’z’变成’a’)。比如选择“acdz”，操作一次后变为“bdea”。 现在狗风从字符串中任取两个子串，狗风想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤105)，表示字符串长度。 第二行包括一个长度为n的字符串。 接下来一行包括一个正整数q(1≤q≤105)，表示询问次数。 接下来q行，每行包括3个正整数x，y，len。(1≤x，y≤n)，(1≤len≤n并且1≤x+len-1，y+len-1≤n)。表示查询子串[x…x+len-1]和子串[y…y+len-1]。 n=105，q=105的数据大约有10组。 Output对于每个查询，输出一行，表示答案。 Sample Input10aabbcdedcz41 3 22 6 24 6 41 10 1 Sample Output13-11 Hint第一个查询的子串为“aa”和“bb”，“aa”变为“bb”需要1次操作，所以相似度为1。 第二个查询的子串为“ab”和“de”，“ab”变为“de”需要3次操作，所以相似度为3。 第三个查询的子串为“bcde”和“dedc”，“bcde”不能变为“dedc”，所以两个字符串不相似，输出-1。 第四个查询的子串为“a”和“z”，“z”变为“a”需要1次操作，所以相似度为1。 Source2017级新生选拔#4 Authortokitsukaze 题解： 预处理：对这个字符串的26种变化做hash。 查询：用差分的方式取出y子串的hash值，然后取出x子串26种变化的hash值，判断有没有一种变化能使x子串的hash值等于y子串的hash值，如果有，假设是第i种变化，那么答案就是min(i,26-i)，如果没有，答案就是-1。 代码： 这里给出双hash的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct hash_table&#123; ll seed,p; ll Hash[26][MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;26;j++) &#123; Hash[j][i]=(Hash[j][i-1]*seed%p+(s[i]-&apos;a&apos;+j)%26)%p; &#125; &#125; &#125; ll get(int l,int r,int id) &#123; return (Hash[id][r]-Hash[id][l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;ha[2];char s[MAX];int main()&#123; int n,i,q,x,y,len,ans; ll tmp; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; assert(n&gt;=1&amp;&amp;n&lt;=100000); scanf(&quot; %[a-z]&quot;,s+1); assert(strlen(s+1)==n); ha[0].set(233333,1e9+7); ha[1].set(19260817,998244353); for(i=0;i&lt;2;i++) ha[i].work(s,n); scanf(&quot;%d&quot;,&amp;q); assert(q&gt;=1&amp;&amp;q&lt;=100000); while(q--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); assert(len&gt;=1); assert(x&gt;=1&amp;&amp;x+len-1&lt;=n); assert(y&gt;=1&amp;&amp;y+len-1&lt;=n); vector&lt;int&gt; res; ans=INF; tmp=ha[0].get(y,y+len-1,0); for(i=0;i&lt;26;i++) if(ha[0].get(x,x+len-1,i)==tmp) res.pb(i); tmp=ha[1].get(y,y+len-1,0); for(i=0;i&lt;sz(res);i++) &#123; if(ha[1].get(x,x+len-1,res[i])==tmp) &#123; ans=min(ans,res[i]); ans=min(ans,26-res[i]); &#125; &#125; if(ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2018/06/14/NIT 453 相似字符串(hash)/","date":"06-14","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/06/13/hello-world/","date":"06-13","excerpt":""}]}