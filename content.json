{"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-14","excerpt":""},{"title":"message","text":"","path":"about/index.html","date":"09-23","excerpt":""},{"title":"Category","text":"","path":"categories/index.html","date":"03-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-14","excerpt":""},{"title":"Tag","text":"","path":"tags/index.html","date":"06-20","excerpt":""}],"posts":[{"title":"The 15th Ningbo Institute of Technology, ZJU Programming Contest","text":"转载请注明出处：http://tokitsukaze.live/ 比赛链接：https://ac.nowcoder.com/acm/contest/303 The 15th Ningbo Institute of Technology, ZJU Programming Contest 出题：tokitsukaze，winterzz1，teitoku 验题：ConferenceCall，ProphetStorm，Heaven_，tender，yuzuko，Darkcat，2014CAIS01，TommyShelby，NITGhost。 题面修订：doge233，tender，Darkcat —————————————————————————————————————— 难度预期： (1)对于新生： easy：AJIB medium：DEK hard：HFL very hard：CG &nbsp; (2)对于牛逼网友： easy：ABDEFHIJKL medium：C hard：G &nbsp; 下注： 现场赛：1h可能有4题的，rk1应该能有9题。 网络赛：ak的可能会有1，2个。 —————————————————————————————————————— 赛前出题： 本来只有几个题题面是星际争霸，然后winterzz1：不然出一套吧。然后就全改成星际争霸了。 第一轮验题，yuzuko：这是什么星际争霸科普赛吗。 验题时普遍反映D和E题面表述不清。于是让doge233第一轮修题面。 第二轮验题，还是反映D和E题面表述不清，于是请了大学语文及格的tender，和她队友：星际玩家Darkcat来修题面。 第三轮验题，没啥毛病，就这样吧。 —————————————————————————————————————— 现场赛准备： 本周突变因子：5楼机房，电脑随机蓝屏。给5楼的选手们增加了一些游戏难度。 &nbsp; 网络赛前一天： 看到西电跟我们撞了，感觉剧本写好了：这什么沙雕学校的沙雕比赛 题还这么长 走了走了 去打西电的了。 —————————————————————————————————————— 现场赛： J居然这么快就被发现了… 紧接着E被秒了… 然后K也很快就被秒了，1h出头就有5题的了…然后发现K不用建树dfs也能做… 接着H也被秒了.. I看来藏的不错。 为什么没人过D？？写7层for也能过吧… 有位外校老哥，A签到-33，旁边坐着一个rk2，5题的小学生，被打跑了… rk2的小学生最后7题，还是rk2。(小学生牛逼) rk1只有7题。 &nbsp; 现场赛过题情况： —————————————————————————————————————— 网络赛： 惊现qls。 qls1h秒了9个。 qls被C卡住了。 qls发现没看见字典序最小。 qls走了。 验题人2014CAIS01拿了G的一血，过分！ G过的似乎有点多。 qls在最后1min1Y了G，跳到了rk1。 看隔壁西电的榜似乎有点惨，还是我们的简单.jpg &nbsp; 网络赛过题情况： —————————————————————————————————————— A.StarCraft Author：tokitsukaze。 ans=n-20+2018 &nbsp; B.Fibonacci and Counting Author：winterzz1。 ans=n+1 证明： 定理：任意相邻两项的斐波那契数互质。假设F(n)与F(n+1)（n&gt;2）有公约数的话，不妨设为a，应有a大于1。那么再根据F（n+1）=F(n)+F(n-1),a应能整除F（n-1），即a|F（n-1），再结合a|F（n），a|F（n+1），可知a|F（n-2），以此类推，我们会发现a|F（2）和a|F（1），而F（1）=F（2）=1。这是不可能的，假设不成立。所以斐波那契数列邻近项互质。根据辗转相除法，gcd(a,b)=gcd(b,a%b)，而斐波那契数的后一项不大于前一项的2倍，所以这里的模其实就是减法。也就是：gcd(a,b)=gcd(b,a-b)。观察一下就会发现，这个式子就是斐波那契数列运算的逆运算。所以使用几次斐波那契运算过去，就得使用几次辗转相除回来，再算上第一次调用的一次，答案为n+1。 &nbsp; C.LCPS Author：tokitsukaze。 把第一个串建回文树，回文树的每个节点记录下第一次出现的下标。 第二个串在回文树上匹配，匹配时更新最大长度，并记录下出现的下标。 然后把子串暴力取出来，直接比较字典序即可。因为本质不同的回文串是O(n)的，所以卡不掉暴力比较字典序。 &nbsp; D.Campaign Author：teitoku。 二进制枚举答案，然后维护一个可行的l,r，当可行的l,r包含了输入的个数的时候，就是满足条件的，然后从所有答案中选出最大的就行。 &nbsp; E.Build Pylons Author：tokitsukaze。 题意：现在有个人在数轴上从左到右依次经过一些点，他每走一步时的花费都是等差数列1,3,5,7,9…然后一旦他经过某个点等差数列就会从1开始重新计数。 根据等差数列求和公式可得走k步的花费总共为k^2，所以先对输入的a数组进行排序。然后依次计算sum+=(a[i]-a[i-1])*(a[i]-a[i-1])(i&gt;1)即可。最后再加上最后一个建筑的建造时间就是答案。 &nbsp; F.Pylon Link Author：tokitsukaze。 solution (1)：二分答案，check连通性。O(log(1.5e9)*n^2)。 solution (2)：n^2建图，求最小瓶颈生成树。prim：O(n^2)，kruskal：O(log(n^2)*n^2)。 &nbsp; G.Rubik’s Cube Author：winterzz1。 三阶魔方翻楞公式：MU2M’UMU’M’（F面下侧楞块翻转，D面其他块不变）三阶魔方翻角公式：RUR’U’RUR’(F面右下角块顺时针旋转单次，D面其他块不变）所以只要求在一个面上拼数字的话，只要数字不在同一个块中，就一定能够放在同一面上。一个魔方由8个角块，6个中心块，12个棱块组成。拼好的一个面上有4个角块，4个楞块，1个中心块。所以使用分组背包处理一个块中不同面的互斥关系，然后从8个角块中选4个，12个棱块中选4个，6个中心块中选1个放入背包。 &nbsp; H.Protoss and Zerg Author：tokitsukaze。 加法原理与乘法原理，需要会快速幂。(解法在样例解释就给出了) &nbsp; I.Race Sorting Author：tokitsukaze。 开几个数组直接扫，按题意模拟即可。 &nbsp; J.Carrier Author：tokitsukaze。 if else讨论一下，过样例应该就能过。 &nbsp; K.Technology Tree Author：tokitsukaze。 建树直接dfs即可。 &nbsp; L.The Last Stand Author：winterzz1。 题意：从最左边走到最右边，每个物品可以取或者不取，取东西的时候首先会获得一个val权值，然后接下来会持续的获得或者减少该物品dalta属性的权值。 dp[i]表示取第i个物品能获得的最大权值。然后设置两个虚点0和n+1，这两个虚点的val属性和delta属性均为0dp转移方程为：dp[i]=max(dp[i],dp[j]+delta[j]*(pos[i]-pos[j])+val[i]);(i&gt;j)注意条件要求过程中权值不能为负，所以需要先判断是否可以转移再进行状态转移。","path":"2018/12/08/2018NIT15thProgrammingContest/","date":"12-08","excerpt":""},{"title":"Nowcoder Practice Contest 33","text":"转载请注明出处：http://tokitsukaze.live/ 比赛链接：https://ac.nowcoder.com/acm/contest/308 Nowcoder Practice Contest 33 出题：tokitsukaze，winterzz1 验题：calabash_boy，meopass_0v0，Heaven_，tender，yuzuko，applese。 赛前： 验完题感觉A和E太水了，本来想换，想想还是算了，A就当个签到，E就当个hash练习题好了。 本场代码量最大的估计是C。 当时缺个F，winterzz1提供了F的1e6版本，我嫌太水，就加了3个0，m改为100。 结果验题时，calabash_boy：一个大大的矩阵快速幂。m^3*log1e9，似乎刚刚好？ 牛客那边派出了牛逼网友zzq验题，zzq：半小时ak。 预测：估计至少有30个ak吧。 &nbsp; 赛后： 验题人calabash_boy把F一血拿了，过分！ 这个A是什么情况…其他的不说，怎么有一堆tle的。 C过了100个，感觉海星。 只有16人ak。 A.tokitsukaze and Counting Author：tokitsukaze。 题解： ans=r/x-(l-1)/x &nbsp; B.tokitsukaze and RPG Author：tokitsukaze。 题解： 数数xi的个数，用埃筛的方式计数。然后for一遍找到最大值，再for一遍统计最大值数量即可。 时间复杂度O(nlogn)。 &nbsp; C.tokitsukaze and Number Game Author：tokitsukaze。 题解： 首先一个结论：若后三位能被8整除，那么这个数就能被8整除。 那么做法就是贪心，前面的数尽量大，后三位的每位都尽量小，而且排列后能被8整除。 实现方式比较多(？)，这里仅说一下std做法。 特判掉只有1位和2位，这里注意不能直接判能不能被8整除，比如23-&gt;32。 预处理后3位能被8整除的所有情况，每种情况按字典序降序后，再总体按字典序升序。 比如：104-&gt;410，112-&gt;211。字典序211&lt;410。 然后数数每个数字的个数。从小到大(指的是字典序)枚举预处理的3位数，看看数字够不够拼，够就用这3位当末尾的3位。(都不够就是-1了) 然后把这3位取出来。其他的数从大到小sort。这3位做个全排列，取个最大能被8整除的数，拼起来就是答案。 &nbsp; D.tokitsukaze and Inverse Number Author：tokitsukaze。 题解： 先树状数组求逆序数，然后有个结论。 结论：1到n的排列，任意交换两个数，逆序数奇偶性发生改变。 ans=（操作前的序列的逆序数+需要交换多少次才能变成操作后的序列（不需要求最小操作次数））%2。 证明： &nbsp; E.tokitsukaze and Similar String Author：tokitsukaze。 题解： hash练习题。 预处理所有26种变化的hash表，用hash表来判断子串是否相等。 假设x的第i种变化与y相等，ans=min(i,26-i)。 都不相等就-1。 &nbsp; F.tokitsukaze and Unlimited Array Author： winterzz1(牛客练习赛34出题人)，n=1e6。 tokitsukaze：n=1e6 —&gt; n=1e9。 题意：给你一个最高项为n的多项式数列，问你它的第n+1阶差分数组非0项的和是多少 题解：通过暴力程序可以找到规律，答案等于A*n!，A为最高项的系数。1e9!可以用分块打表实现。暴力打表，存下1e7,2e7,3e7,…,1e9-1e7,1e9。总共100个数。然后比如要求(2e7-1)!，那就从表中2e7开始往下接着算。时间复杂度为O(1e7)。 证明：多项式数列求差分可以类比一下多项式求微分。我们先看一下多项式函数求微分的过程。△y=f(x+△x)-f(x)=f(x)’△x+o(△x)然后lim △x-&gt;0的时候o(△x)/△x充分小所以等于0，因为o(△x)对于△x是高阶无穷小。也就是△y=f(x)’△x。这个也就是微分公式。然后离散条件下△x=1。这时候虽然△y≠f(x)’△x，因为在△y=f(x)’△x+o(△x)这一步的时候，△x不充分小（等于1），o(△x)不可忽略。但是我们也可以把它写成△y=f(x)’△x+o(△x)的形式，把△x=1代入得△y=f(x)’+α。余项α是一个最高项的幂次小于f(x)’最高项幂次的多项式。那么在利用△y=f(x)’+α迭代求差分的时候，余项α先比f(x)’差分成0。也就是不用考虑α对第n阶差分产生的贡献。则最终产生贡献的式子为△y=f(x)’。答案的贡献就是n阶多项式的n阶导数，记为f(x)^(n)。由多项式高阶求导公式得f(x)^(n)=A*n!。","path":"2018/12/07/NowcoderPracticeContest33/","date":"12-07","excerpt":""},{"title":"2018-2019 ICPC, NEERC, Northern Eurasia Finals","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/contest/1089 Solved：4/13。 &nbsp; E.Easy Chess solved by yozuko. 就算多少个16就往右到头，然后在上一行从右到左，然后如果是16的倍数，最后剩0步的话，就得提前一格停在到第八行再到终点，分剩多少步的情况写一下。 &nbsp; F.Fractions 最开始想暴力看看，后面发现只要减一次，能约分，剩下的就是答案。 所以大胆猜测了一下，YES的一定能分成两个分数的和。于是暴力枚举第一个分数，check第二个。 复杂度不太会算(应该挺对的)。 &nbsp; G.Guest Student 枚举一个1作为起点，然后大力算，取个min即可。 &nbsp; L.Lazyland 简单贪心。 每种出现过的，留下时间最长的。然后把其他的全丢进vector里，sort一下，从小开始分配给没出现过的。 &nbsp; &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/Codeforces/2018-2019%20ICPC%2C%20NEERC%2C%20Northern%20Eurasia%20Finals","path":"2018/12/03/2018_NEERC_Northern_Eurasia_Finals/","date":"12-03","excerpt":""},{"title":"2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest (gym102012)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/102012 Solved：2/13。 &nbsp; A.Rikka with Minimum Spanning Trees 数据是随机生成器生成，边权相同的概率无限接近于0。所以直接跑一次最小生成树即可。 注意：特判不存在生成树的情况，输出0。 &nbsp; G.Rikka with Intersections of Paths 考虑到去重，容斥，都是不存在的。那么只能每次加进一些链，计算增加的贡献。想到这基本就会做了。 统计一个节点被覆盖了几次，用树上差分做，记为cnt[]。 然后统计增加的链数，在lca处进行标记，记为tag[]。 那么dfs到节点x，新增加的链的贡献就是C(cnt[x],k)-C(cnt[x]-tag[x],k)。 &nbsp; &nbsp; &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/gym/2018-2019%20ACM-ICPC%2C%20Asia%20Xuzhou%20Regional%20Contest","path":"2018/12/02/gym102012/","date":"12-02","excerpt":""},{"title":"Educational Codeforces Round 55","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/contest/1082 Solved：6/7 &nbsp; A.Vasya and Book 3种情况。 1.x-&gt;y 2.x-&gt;1-&gt;y 3.x-&gt;n-&gt;y &nbsp; B.Vova and Trophies 维护两串G。注意中间不能有两个S。 &nbsp; C.Multi-Subject Competition sum[i]表示每种科目选i个人的最大值。对于每种科目，从水平大的开始加，如果当前和是正的，就加入sum[]。 最后遍历一遍sum[]，取max即可。 &nbsp; D.Maximum Diameter Graph 判断度的和小于树的度的和，就是NO。否则答案为非叶子节点数-1+min(叶子节点数，2)。 把叶子节点拿出来，非叶子节点连成一条链，然后叶子节点往上接即可。 &nbsp; E.Increasing Frequency 对于等于c的数的个数，做一个前缀和pre[]与后缀和suf[]。 mx[i]表示第i个数必选的前缀最大值。last[a[i]]表示上一次a[i]出现的位置。 mx[i]=max(pre[i-1],max[last[a[i]]])+1。 ans=max{mx[i]+suf[i+1]}。 &nbsp; G.Petya and Graph 最大权闭合子图裸题。 &nbsp; &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/Codeforces/Educational%20Codeforces%20Round%2055","path":"2018/11/29/cfedu55/","date":"11-29","excerpt":""},{"title":"2018-2019 ACM-ICPC, Asia Shenyang Regional Contest (gym101955)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101955 补题进度：7/13。 &nbsp; C.Insertion Sort 打表找规律 or 推公式。 &nbsp; E.The Kouga Ninja Scrolls http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.E/ &nbsp;&nbsp; G.Best ACMer Solves the Hardest Problem http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.G/ &nbsp; I.Distance Between Sweethearts http://tokitsukaze.live/2018/11/15/2018ICPCShenyangOnsite.I/ &nbsp; J.How Much Memory Your Code Is Using? 签到题。直接模拟即可。 &nbsp; K.Let the Flames Begin 学不会，扒个板子走了.. &nbsp; L.Machining Disc Rotors http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.L/ &nbsp; &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/gym/2018-2019%20ACM-ICPC%2C%20Asia%20Shenyang%20Regional%20Contest","path":"2018/11/28/gym101955/","date":"11-28","excerpt":""},{"title":"2018ICPC焦作赛区","text":"转载请注明出处：http://tokitsukaze.live/ day1： 热身赛。 键盘有点迷。退格键巨小，退格键旁边居然是\\。 开场我先上去切了个A。B只有100种情况，枚举提交就能过。然后chy上去写D，是个数位dp。C是个牛逼题，不太会就扔了。然后D调了1h，最后被我发现输出少打个冒号…中间各种跟手算的不一样，过了之后发现手算的是错的…然后B看有人30+发过，猜前10+后10+，不然就是前30+后30+，最后试到3 1过了。 day2： 正赛。发完题怎么都开始看了…于是提前看题。chy发现A是签到，上去切了。我看了I，感觉也是个签到，解法秒出，但是没想好怎么算，甩锅给chy。zyf看了F，是个画图bfs，画图要点时间。于是我先上机处理好输入，把样例抄上去，后来发现样例可以贴…这时chy也算不清I，甩锅给zyf，看E去了…然后我也继续算I。此时I已经过了一大片了。zyf也算不清….于是上机码F。之后chy上机试试I，没过样例。我可能算清楚了，上机调了调，过了样例，1A。此时已经1.5h了。E找到了规律，chy上java切了。之后zyf继续码F。F.wa，发现我处理输入的时候，调试没删…接着F.tle，看了看复杂度应该没问题，把map去掉就过了。D是个初中数学？他们讨论了之后，chy上机瞎调，凑过样例，D.wa。然后边界判断重写了一下，过了。此时还剩1h。期间我看了BCHL的题意，看了榜，决定开B。B分两种情况，讨论了之后，我先上机敲了第一种情况，接着他们上机敲第二种，然后wa到了最后… 开场脑子不清楚，I卡太久了，罚时不太行，导致只有铜。需要增强纸上能力。","path":"2018/11/25/2018ICPCjiaozuo/","date":"11-25","excerpt":""},{"title":"2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest (gym101986)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101986 Solved：3/11 &nbsp; A.Secret of Chocolate Poles dp[i][]表示第i层用哪种木板，转移枚举一下即可。 &nbsp; C.Medical Checkup 等待时间是一个一次函数。 k=max{t[i]}，b是sum{t[i]}。 当k变化的时候，b要讨论一下。 &nbsp; F.Pizza Delivery 起点1开始跑正向图最短路，终点2开始跑反向图最短路。 记录cnt[]表示最短路条数。 如果这条边在起点到终点的最短路上，判断这条边是否是必经边，用最短路条数判断，是就SAD，不是就SOSO。 如果这条边不是在起点到终点的最短路上，判断最短是是否会变短，是就HAPPY，不是的话没影响，就SOSO。 &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/gym/2016-2017%20ACM-ICPC%2C%20Asia%20Tsukuba%20Regional%20Contest","path":"2018/11/19/gym101986/","date":"11-19","excerpt":""},{"title":"2018-2019 ACM-ICPC, Asia Nanjing Regional Contest (gym101981)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/gym/101981 补题进度：8/13。 &nbsp; A.Adrien and Austin 考虑对称操作。先手能拿中间，必胜。 n为奇数，先手只需把中间一个拿了，所以先手必胜。 n为偶数，先手需要拿中间的两个，所以k=1时先手必败，否则先手必胜。 注意特判n=0是先手必败。 &nbsp; D.Country Meow 最小包围球。模拟退火的时候往最远点靠近即可。 &nbsp; E.Eva and Euro coins 注意题意是能连续翻k个状态相同的硬币。 qls：一个观察是你可以把每个 1 在不跨越其他 1 的情况下往左右移 k 个位置。尽可能把 1 往左靠，出现连续 k 个 1 就消掉。check 两个串处理之后的串是否相同。 一个1能往左移k个位置，那么中间肯定有k个0。所以就变成了消消乐，把连续的k个1或者0都消掉，用栈模拟即可。 &nbsp; G.Pyramid ans=C(n+3,4)。不会推。 &nbsp; 有位牛逼网友看了说： 于是这位牛逼网友补充了推导： 对于一个正着的正三角形，他的内部会有边长-1个正三角形，和他本身一共就会有边长个正三角形， 一个边长为n的大三角形，他内部会有从边长从1到n的正三角形， 对于边长为i的正三角形，会有(1+(n-i+1)) * (n-i+1) /2 个， 则他的贡献为(1+(n-i+1)) * (n-i+1) /2 * i, 则答案为Σ(1+(n-i+1)) * (n-i+1) /2 * I （i从1到n） 把sigma展开，就是一个x的三次方和x的二次方和x的求和公式化简。 化简结果是 (n^4+6*n^3+11*n^2+6*n) / 24; 至于他为什么恰好就是C(n+3,4), 我也不知道。 大小为4的例子： &nbsp; I.Magic Potion 源点与每个英雄连边，容量1。 源点与中转点连边，容量k。 中转点与每个英雄连边，容量1。 每个英雄与能打的怪物连边，容量1。 每个怪物与汇点连边，容量1。 然后跑最大流。 &nbsp; J.Prime Game 每种质因数分开算贡献。 记录每种质因数出现的位置。比如第pos位出现了，那么第pos位的贡献为(pos-pre)*(nex-pos+1)。 &nbsp; K.Kangaroo Puzzle solution(1)：dfs预处理每只袋鼠到其他袋鼠的第一步的方向。每次随便选两只袋鼠，其中一只向另一只走，直到合并。每走一次，都把其他袋鼠都动一下，直到只剩一只袋鼠。 solution(2)：随机输出5e4个’L’,’R’,’D’,’U’。据说卡不掉。 &nbsp; M.Mediocre String Problem 题意：给S串与T串。S[i..j]+T[1..k]为回文串，且|S[i..j]|&gt;|T[1..k]|，求(i,j,k)个数。 将S[i..j]分为两个部分，S[i..p]为T[1..k]的反转，S[p+1..j]为回文串。 由于|S[i..j]|&gt;|T[1..k]|，所以S[p+1..j]必须不为空。 枚举回文串的起始点p+1，那么我们要求的是： 1.由于S[i..p]为T[1..k]的反转，我们只要求有多少个(i,k)。这个部分是exkmp的基础。 将S反转，跟T跑exkmp，求出ex[]，再把ex[]反过来即可。 2.S[p+1..j]为回文串，我们只要求有多少个j，即求的是以p+1为起点的回文串个数cnt[]。 那么只要把S串倒着插入回文自动机，cnt[i]=插入第i个字符后，fail树的深度。 &nbsp; 最后枚举回文串起点p+1，算出ex[p]*cnt[p+1]，求和即为答案。 &nbsp; &nbsp; 代码： https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/gym/2018-2019%20ACM-ICPC%2C%20Asia%20Nanjing%20Regional%20Contest","path":"2018/11/18/gym101981/","date":"11-18","excerpt":""},{"title":"Codeforces Round#521","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/contest/1077 A：ans=(a-b)*(k/2)+a*(k%2) B：贪心。从前往后判断，如果要关灯，先关后面的。 C：预处理前缀max与后缀max，求出整个数组的和。枚举每个数直接判断即可。 D：二分答案，check是否合法，最后把序列弄出来即可。 E：出现个数最多的肯定当最后一项，第二多的肯定当倒数第二项…从多往少枚举，每次调整整个序列的值，取max即可。复杂度O(n)。 F1&amp;F2：dp[i][j]表示前i个数，ai必选，共选了j个的最大值。 转移：dp[i][j]=max(dp[l][j-1]+a[i]), (i-k≤l＜i)。 ans=max(dp[i][x]), (n-k+1≤i≤n)。 转移用单调队列优化。 代码：https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/Codeforces/Codeforces%20Round%20%23521","path":"2018/11/18/cf521/","date":"11-18","excerpt":""},{"title":"Codeforces Round#520","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/contest/1062 A：前面补个0，后面补个1001，然后直接n*1000暴力，最后输出max(0,ans-2)。 B：最小答案肯定是质因子的乘积。 最小次数为x+flag。x为出现最多质因子的出现次数，转换为二进制的长度减1。flag为0或者1，表示是否要补。 C：cnt0表示区间0的个数。cnt1表示区间1的个数。 ans=2^cnt1+(2^cnt1-1)*(2^cnt0-1)-1 D： x -&gt; y -&gt; -x -&gt; -y -&gt; x，贡献是4*(y/x)。若x与x的倍数连边，所有边都能走到。 所以直接埃氏筛暴力枚举x的倍数统计答案。 E：题意：给一棵树，q次询问，每次询问节点[l,r]中，只删除一个节点，剩下节点求LCA深度最深，输出删除的节点编号和LCA的深度。 dfn越接近，LCA越深。所以删一个点，只可能删这个区间的dfn最小或者最大的点。 线段树维护区间dfn的最值与次值。删最小的话，LCA就是dfn次小和最大的LCA。删最大的话，就是次大和最小。 代码：https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/Codeforces/Codeforces%20Round%20%23520","path":"2018/11/18/cf520/","date":"11-18","excerpt":""},{"title":"Educational Codeforces Round 54","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/contest/1076 A：简单模拟。 B：是奇数，直接模拟。是偶数，每次减2，直接得出答案。 C：求a+b=d且a*b=d。b=d-a，二分a即可。 D：弄出最短路树，优先删叶子。 E：离线。对deep做差分，相同deep同时更新，更新的时候对dfs序做差分。 F：题意：文章有n页，每页有x[i]个1和y[i]个0，问你能不能给每一页搞个序列，把所有页的序列前后接起来，使得连续的1和0不超过k个。题解：用1去分割0，看看够不够，不够的加到下一页。用0去分割1同理。每次check一下不够的是否不超过k。 代码：https://github.com/tokitsu-kaze/ACM-Solved-Problems/tree/master/Codeforces/Educational%20Codeforces%20Round%2054","path":"2018/11/18/cfedu54/","date":"11-18","excerpt":""},{"title":"2018ICPC沈阳现场赛I.Distance Between Sweethearts","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101955/problem/I 题意： 题解：枚举max，max那一坨里面的东西，把每个绝对值展开，用cnt数组记录个数。后面那一坨看作fwt下标，做完fwt后，即可求出max里面三个绝对值恰好都等于max的方案数。但是题目求的是至少一个绝对值等于max。于是用pre数组记录之前fwt的结果，pre与cnt不要清空，每次fwt后，减掉pre，就是至少一个等于max的方案数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/namespace FWT&#123; void fwt(ll *a,int n,int f,int v) &#123; for(int d=1;d&lt;n;d&lt;&lt;=1) &#123; for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m) &#123; for(int j=0;j&lt;d;j++) &#123; ll x=a[i+j],y=a[i+j+d]; if(!v) &#123; if(f==1) a[i+j]=(x+y),a[i+j+d]=(x-y); &#125; else &#123; if(f==1) a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2; &#125; &#125; &#125; &#125; &#125; void XOR(ll *res,ll *a,ll *b,ll *c,int n) &#123; int len; for(len=1;len&lt;n;len&lt;&lt;=1); fwt(a,len,1,0); fwt(b,len,1,0); fwt(c,len,1,0); for(int i=0;i&lt;len;i++) res[i]=a[i]*b[i]*c[i]; fwt(res,len,1,1); &#125;&#125;;ll cnt[3][2222],pre[2222],tmp[3][2222],res[2222];void go()&#123; int t,cas=1; ll I[2],A[2],G[2],i,j,mx; ull ans; read(t); while(t--) &#123; read(I[0],A[0],G[0],I[1],A[1],G[1]); mem(cnt,0); mem(pre,0); ans=0; for(mx=0;mx&lt;=2000;mx++) &#123; for(i=0;i&lt;=I[0]&amp;&amp;i+mx&lt;=I[1];i++) cnt[0][i^(i+mx)]++; for(i=0;i&lt;=A[0]&amp;&amp;i+mx&lt;=A[1];i++) cnt[1][i^(i+mx)]++; for(i=0;i&lt;=G[0]&amp;&amp;i+mx&lt;=G[1];i++) cnt[2][i^(i+mx)]++; if(mx) &#123; for(i=0;i&lt;=I[1]&amp;&amp;i+mx&lt;=I[0];i++) cnt[0][i^(i+mx)]++; for(i=0;i&lt;=A[1]&amp;&amp;i+mx&lt;=A[0];i++) cnt[1][i^(i+mx)]++; for(i=0;i&lt;=G[1]&amp;&amp;i+mx&lt;=G[0];i++) cnt[2][i^(i+mx)]++; &#125; for(i=0;i&lt;3;i++) &#123; for(j=0;j&lt;2048;j++) &#123; tmp[i][j]=cnt[i][j]; &#125; &#125; FWT::XOR(res,tmp[0],tmp[1],tmp[2],2048); for(i=0;i&lt;2048;i++) &#123; ans+=(res[i]-pre[i])*(i^mx); pre[i]=res[i]; &#125; &#125; printf(\"Case #%d: %llu\\n\",cas++,ans); &#125;&#125;","path":"2018/11/15/2018ICPCShenyangOnsite.I/","date":"11-15","excerpt":""},{"title":"2018ICPC沈阳现场赛E.The Kouga Ninja Scrolls","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101955/problem/E 题意：平面上n个点，每个点有一个颜色c。m次操作。操作1：第k个点的坐标变为(x0+x,y0+y)。操作2：第k个点的颜色变为c。操作3：询问区间[l,r]中，最远的两个不同颜色的点的距离。这里的距离为曼哈顿距离。 题解：把曼哈顿距离转换为切比雪夫距离，注意操作1的时候也要变化。 答案就变成max(|X1-X2|,|Y1-Y2|)且c1!=c2。 脱掉绝对值，变成max(Xmax-Xmin,Ymax-Ymin)且c1!=c2。 然后x和y就可以分开维护。开两个线段树，分别维护x和y的最大值，次大值，最小值，次小值。 注意最大值与次大值的颜色不同，最小值与次小值同理。 最大值与次大值，对应最小值与次小值，如果有颜色不同的组合，答案肯定在这里面，否则答案为0。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Segment_Tree&#123; #define type PLL #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; type a[MAX],mx[2][MAX&lt;&lt;2],mn[2][MAX&lt;&lt;2]; type rmx[2],rmn[2]; void upmx(int id) &#123; ll tx[4]=&#123;mx[0][id].fi,mx[1][id].fi,rmx[0].fi,rmx[1].fi&#125;; ll tc[4]=&#123;mx[0][id].se,mx[1][id].se,rmx[0].se,rmx[1].se&#125;; int idx[4]=&#123;0,1,2,3&#125;,cnt=0; sort(idx,idx+4,[&amp;](int a,int b)&#123;return tx[a]&gt;tx[b];&#125;); for(int i=0;i&lt;4&amp;&amp;cnt&lt;2;i++) &#123; if(i==0||tc[idx[i]]!=tc[idx[i-1]]) &#123; rmx[cnt].fi=tx[idx[i]]; rmx[cnt++].se=tc[idx[i]]; &#125; &#125; for(int i=cnt;i&lt;2;i++) &#123; rmx[i].fi=-LLINF; rmx[i].se=-LLINF; &#125; &#125; void upmn(int id) &#123; ll tx[4]=&#123;mn[0][id].fi,mn[1][id].fi,rmn[0].fi,rmn[1].fi&#125;; ll tc[4]=&#123;mn[0][id].se,mn[1][id].se,rmn[0].se,rmn[1].se&#125;; int idx[4]=&#123;0,1,2,3&#125;,cnt=0; sort(idx,idx+4,[&amp;](int a,int b)&#123;return tx[a]&lt;tx[b];&#125;); for(int i=0;i&lt;4&amp;&amp;cnt&lt;2;i++) &#123; if(i==0||tc[idx[i]]!=tc[idx[i-1]]) &#123; rmn[cnt].fi=tx[idx[i]]; rmn[cnt++].se=tc[idx[i]]; &#125; &#125; for(int i=cnt;i&lt;2;i++) &#123; rmn[i].fi=LLINF; rmn[i].se=-LLINF; &#125; &#125; void pushup(int id) &#123; mx[0][id]=mx[0][ls]; rmx[0]=mx[0][rs]; mx[1][id]=mx[1][ls]; rmx[1]=mx[1][rs]; upmx(id); mx[0][id]=rmx[0]; mx[1][id]=rmx[1]; mn[0][id]=mn[0][ls]; rmn[0]=mn[0][rs]; mn[1][id]=mn[1][ls]; rmn[1]=mn[1][rs]; upmn(id); mn[0][id]=rmn[0]; mn[1][id]=rmn[1]; &#125; void build(int l,int r,int id) &#123; mx[1][id]=MP(-LLINF,-LLINF); mn[1][id]=MP(LLINF,-LLINF); if(l==r) &#123; mx[0][id]=mn[0][id]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); pushup(id); &#125; void update(int l,int r,int id) &#123; mx[1][id]=MP(-LLINF,-LLINF); mn[1][id]=MP(LLINF,-LLINF); if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; mx[0][id]=mn[0][id]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; void query(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; upmx(id); upmn(id); return ; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) query(l,mid,ls); if(qr&gt;mid) query(mid+1,r,rs); &#125; void build(int _n)&#123;n=_n;build(1,n,1);&#125; void upd(int l,int r) &#123; ql=l; qr=r; update(1,n,1); &#125; ll ask(int l,int r) &#123; rmx[0]=rmx[1]=MP(-LLINF,-LLINF); rmn[0]=rmn[1]=MP(LLINF,-LLINF); ql=l; qr=r; query(1,n,1); ll res=0; if(rmx[0].se!=rmn[0].se) res=max(res,rmx[0].fi-rmn[0].fi); if(rmn[1].se!=-LLINF&amp;&amp;rmx[0].se!=rmn[1].se) res=max(res,rmx[0].fi-rmn[1].fi); if(rmx[1].se!=-LLINF&amp;&amp;rmx[1].se!=rmn[0].se) res=max(res,rmx[1].fi-rmn[0].fi); if(rmx[1].se!=-LLINF&amp;&amp;rmn[1].se!=-LLINF&amp;&amp;rmx[1].se!=rmn[1].se) res=max(res,rmx[1].fi-rmn[1].fi); return res; &#125; #undef type #undef ls #undef rs&#125;tx,ty;void go()&#123; int t,cas=1,n,q,i,op,l,r; ll x,y,c,k; read(t); while(t--) &#123; read(n,q); for(i=1;i&lt;=n;i++) &#123; read(x,y,c); tx.a[i]=MP(x+y,c); ty.a[i]=MP(x-y,c); &#125; tx.build(n); ty.build(n); printf(\"Case #%d:\\n\",cas++); while(q--) &#123; read(op); if(op==1) &#123; read(k,x,y); tx.a[k].fi+=x+y; ty.a[k].fi+=x-y; tx.upd(k,k); ty.upd(k,k); &#125; else if(op==2) &#123; read(k,c); tx.a[k].se=c; ty.a[k].se=c; tx.upd(k,k); ty.upd(k,k); &#125; else &#123; read(l,r); printf(\"%lld\\n\",max(tx.ask(l,r),ty.ask(l,r))); &#125; &#125; &#125;&#125;","path":"2018/11/02/2018ICPCShenyangOnsite.E/","date":"11-02","excerpt":""},{"title":"2018ICPC沈阳现场赛L.Machining Disc Rotors","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101955/problem/L 题意：有一个圆O，圆心(0,0)，半径R。用n个没有交叉的圆，去切割这个圆，问剩下的图形的最远距离是多少。 题解：最远距离有三种情况。1.n个圆与圆O的交点，其中两个交点距离取max。2.n个圆与圆O的其中一个交点与交点所对应的直径的点，不在n个圆中任意一个内，那么答案就是直径。3.n个圆都与圆O无交点，那么答案也是直径。 要注意的是，n个没有交叉的圆，不代表没有内含。所以要把内含的圆先去掉。 还有就是一个圆与圆O的两个交点的距离可能也是答案，所以要把所有交点存在一个数组，然后两两枚举。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef long double db;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-10;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/int sgn(db x)&#123; if(fabsl(x)&lt;eps) return 0; else return x&gt;0?1:-1; &#125;struct Point&#123; db x,y; Point()&#123;&#125; Point(db a,db b) :x(a),y(b)&#123;&#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,db p)&#123;return Vector(a.x*p,a.y*p);&#125;bool operator ==(Point a,Point b)&#123;return sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0;&#125;db dot(Vector a,Vector b)&#123;return a.x*b.x+a.y*b.y;&#125;db length(Vector a)&#123;return sqrtl(dot(a,a));&#125;db dist(Point a,Point b)&#123;return sqrtl(dot(a-b,a-b));&#125;struct Line&#123; Point p; Vector v; db ang; Line()&#123;&#125; Line(Point a,Vector b) &#123; p=a; v=b; ang=atan2l(v.y,v.x); &#125; void twopoint(Point a,Point b) &#123; p=a; v=b-a; ang=atan2l(v.y,v.x); &#125; Point getpoint(db a) &#123; return p+(v*a); &#125;&#125;;struct Circle &#123; Point c; db r; Circle()&#123;&#125; Circle(Point a,db b) :c(a),r(b)&#123;&#125; Point getpoint(db a) &#123; return Point(c.x+cos(a)*r,c.y+sin(a)*r); &#125; &#125;; bool OnCircle(Point x,Circle c)&#123;return sgn(c.r-length(c.c-x))==0;&#125;bool InCircle(Point x,Circle c)&#123;return sgn(c.r-length(c.c-x))&gt;0;&#125;int getCircleInter(Circle c1,Circle c2,Point *sol)&#123; db r1,r2,x1,y1,x2,y2,d; r1=c1.r; r2=c2.r; x1=c1.c.x; y1=c1.c.y; x2=c2.c.x; y2=c2.c.y; d=length(c1.c-c2.c); if(sgn(fabsl(r1-r2)-d)&gt;0) return -1; if(sgn(r1+r2-d)&lt;0) return 0; db a,b,c,p,q,r; a=r1*(x1-x2)*2; b=r1*(y1-y2)*2; c=r2*r2-r1*r1-d*d; p=a*a+b*b; q=-a*c*2; r=c*c-b*b; db cosa,sina,cosb,sinb; if(sgn(d-(r1+r2))== 0||sgn(d-fabs(r1-r2))==0) &#123; cosa=-q/p/2; sina=sqrt(1-cosa*cosa); Point p(x1+c1.r*cosa,y1+c1.r*sina); if(!OnCircle(p,c2)) p.y=y1-c1.r*sina; sol[0]=p; return 1; &#125; db delta=sqrt(q*q-p*r*4); cosa=(delta-q)/p/2; cosb=(-delta-q)/p/2; sina=sqrt(1-cosa*cosa); sinb=sqrt(1-cosb*cosb); Point p1(x1+c1.r*cosa,y1+c1.r*sina); Point p2(x1+c1.r*cosb,y1+c1.r*sinb); if(!OnCircle(p1,c2)) p1.y=y1-c1.r*sina; if(!OnCircle(p2,c2)) p2.y=y1-c1.r*sinb; if(p1==p2) p1.y=y1-c1.r*sina; sol[0]=p1; sol[1]=p2; return 2;&#125;int getLineCircleInter(Line l,Circle cc,Point *sol)&#123; db a,b,c,d,e,f,g,delta,t; a=l.v.x; b=l.p.x-cc.c.x; c=l.v.y; d=l.p.y-cc.c.y; e=a*a+c*c; f=2*(a*b+c*d); g=b*b+d*d-cc.r*cc.r; delta=f*f-4*e*g; if(sgn(delta)&lt;0) return 0; if(sgn(delta)==0) &#123; t=-f/(2*e); sol[0]=l.getpoint(t); return 1; &#125; else &#123; t=(-f-sqrtl(delta))/(2*e); sol[0]=l.getpoint(t); t=(-f+sqrt(delta))/(2*e); sol[1]=l.getpoint(t); return 2; &#125;&#125;void go()&#123; int t,n,i,j,k,h,cas=1,flag; Circle a,c[111]; db x,y,r,ans; read(t); while(t--) &#123; read(n,r); a=Circle(Point(0,0),r); for(i=0;i&lt;n;i++) &#123; read(x,y,r); c[i]=Circle(Point(x,y),r); &#125; ans=0; vector&lt;Circle&gt; res; for(i=0;i&lt;n;i++) &#123; flag=0; for(j=0;j&lt;n;j++) &#123; if(i==j) continue; if(InCircle(c[i].c,c[j])&amp;&amp;c[i].r&lt;c[j].r) flag=1; &#125; if(!flag) res.pb(c[i]); &#125; vector&lt;Point&gt; ins[105],insall; Point sol[5]; int cnt; flag=0; for(i=0;i&lt;sz(res);i++) &#123; cnt=getCircleInter(a,res[i],sol); flag|=(cnt&gt;=2); for(j=0;j&lt;cnt;j++) &#123; ins[i].pb(sol[j]); &#125; &#125; if(!flag) ans=2*a.r; Line l; for(i=0;i&lt;sz(res);i++) &#123; for(j=0;j&lt;sz(ins[i]);j++) &#123; l.twopoint(Point(0,0),ins[i][j]); cnt=getLineCircleInter(l,a,sol); for(h=0;h&lt;cnt;h++) &#123; if(sol[h]==ins[i][j]) continue; flag=0; for(k=0;k&lt;sz(res);k++) &#123; if(InCircle(sol[h],res[k])) flag=1; &#125; if(!flag) ans=max(ans,2*a.r); &#125; &#125; &#125; for(i=0;i&lt;sz(res);i++) &#123; for(j=0;j&lt;sz(ins[i]);j++) &#123; insall.pb(ins[i][j]); &#125; &#125; for(i=0;i&lt;sz(insall);i++) &#123; for(j=i+1;j&lt;sz(insall);j++) &#123; ans=max(ans,dist(insall[i],insall[j])); &#125; &#125; printf(\"Case #%d: %.15f\\n\",cas++,(double)ans); &#125;&#125;","path":"2018/11/02/2018ICPCShenyangOnsite.L/","date":"11-02","excerpt":""},{"title":"2018ICPC沈阳现场赛G.Best ACMer Solves the Hardest Problem","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://codeforces.com/gym/101955/problem/G 题意： 6000x6000的平面上有n个点，每个点有点权。m次操作。操作1：插入一个点。操作2：删除一个点。操作3：给出一个圆心(x,y)，半径为sqrt(k)的圆，当前圆上存在的点，点权+w。操作4：询问圆心(x,y)，半径为sqrt(k)的圆，当前圆上存在的点的点权和。强制在线。 题解：由于题目给的都是整数点，在圆上的整数格点很少，所以对于操作3和操作4暴力枚举圆上的整数点即可。 那么先预处理出所有的a^2 +b^2=c^2，对应每个c^2，把符合条件的(a,b)存到vector里。 对于操作3和4，即(x-x0)^2+(y-y0)^2=k，展开|x-x0|和|y-y0|的绝对值，判断存不存在(x0,y0)即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e7+10;const ll mod=1e9+7;/********************************* head *********************************/vector&lt;PII &gt; res[MAX],cl;void init()&#123; int i,j; for(i=0;i&lt;=6000;i++) &#123; for(j=0;j&lt;=6000;j++) &#123; if(i*i+j*j&lt;=MAX-10) res[i*i+j*j].pb(MP(i,j)); else break; &#125; &#125;&#125;bool check(int x,int y)&#123; if(x&lt;0||y&lt;0||x&gt;6000||y&gt;6000) return 0; return 1;&#125; ll pre,ans;void change(int &amp;x,int &amp;y)&#123; x=(x+pre)%6000+1; y=(y+pre)%6000+1;&#125;bool exist[6010][6010]=&#123;0&#125;;int mp[6010][6010]=&#123;0&#125;;int dir[4][2]=&#123;1,1,1,-1,-1,1,-1,-1&#125;;void go()&#123; int i,t,cas=1,x,y,w,n,q,op,k,tx,ty; init(); read(t); while(t--) &#123; cl.clear(); read(n,q); for(i=1;i&lt;=n;i++) &#123; read(x,y,w); exist[x][y]=1; mp[x][y]=w; cl.pb(MP(x,y)); &#125; pre=0; set&lt;PII &gt; s; printf(\"Case #%d:\\n\",cas++); while(q--) &#123; read(op,x,y); change(x,y); if(op==1) &#123; read(w); exist[x][y]=1; mp[x][y]=w; cl.pb(MP(x,y)); &#125; else if(op==2) &#123; exist[x][y]=0; mp[x][y]=0; &#125; else if(op==3) &#123; read(k,w); s.clear(); for(auto it:res[k]) &#123; for(i=0;i&lt;4;i++) &#123; tx=x-it.fi*dir[i][0]; ty=y-it.se*dir[i][1]; if(!check(tx,ty)) continue; if(exist[tx][ty]) s.insert(MP(tx,ty)); &#125; &#125; for(auto it:s) mp[it.fi][it.se]+=w; &#125; else &#123; read(k); s.clear(); for(auto it:res[k]) &#123; for(i=0;i&lt;4;i++) &#123; tx=x-it.fi*dir[i][0]; ty=y-it.se*dir[i][1]; if(!check(tx,ty)) continue; if(exist[tx][ty]) s.insert(MP(tx,ty)); &#125; &#125; ans=0; for(auto it:s) ans+=mp[it.fi][it.se]; printf(\"%lld\\n\",ans); pre=ans; &#125; &#125; for(auto it:cl) &#123; exist[it.fi][it.se]=0; mp[it.fi][it.se]=0; &#125; &#125;&#125;","path":"2018/11/02/2018ICPCShenyangOnsite.G/","date":"11-02","excerpt":""},{"title":"2018CCPC桂林赛区","text":"转载请注明出处：http://tokitsukaze.live/ day0： 还是提前一天起飞，带上3ds继续爬树。 day1： 热身赛。据说有队伍1小时没登进去，结果是网线没插海星。A是个old题，结论有的条件记漏了，后来想起来，加了个gcd就能用结论了。然后D是个比较裸的网络流，抄完板子1A。C估计是什么积分，反正不会。B是大模拟，chy上去暴敲一波，没过样例…最后居然是在金牌区(然后被群里各种奶，奶死了)。 然后回酒店的时候被chy带着绕了一大圈…出发从酒店左边出发，回来从酒店右边回来？？？(证明了地球是圆的 (雾)) day2： 正赛。开场chy读了A，猜了个”字典序尽量大”的结论，说后缀数组可以做，先放着。我读了H，6分钟有人过，我上去敲了个假算法，wa。然后chy上D，我和zyf讨论H。这时zyf有了H的解法(假)，说答案只可能包含’a’,’b’,’c’，然后我听完觉得海星？(其实样例就过不去，我居然没注意)这时chy的Dwa，zyf上H。我跟chy讨论了D，很快指出判-1的情况漏了，改完过了。然后看榜，我们开G，很快有了做法，让zyf先下，chy上G，我看J。然后Gwa，打印发现有个地方需要加绝对值，改完还是wa。然后又发现，有个地方要判，改完又wa。这时候zyf打完，测一下样例立马发现假了。然后3个人一起调G，zyf测出问题，改完继续wa。然后我看了看，发现我锅了，调试没删…删了调试，过了。然后chy读J，提供了个假题意。J是个博弈，于是我看J，他们搞H。H有了个二分的做法，wa。J(假题意)我很快有了做法(新生赛题get)，上机敲。然后他们发现了H有个细节有问题，改完过了。然后我交了一发J，wa。感觉没什么问题，重新读了一下题，看到个“neighbor”，才发现题意假了。然后看榜，发现4题有一排，得再过两题才行。于是他们搞J，我开新题。首先思考了一下A，毕竟首A13min，能不后缀数组就尽量不上。贪了贪，发现不太行。然后看L，是个几何。zyf空闲的时候和他讨论了一下，弄出4个向量极角排序一下，感觉可行，但是时间不多，没敢上。他们J搞到封榜还是wa，差不多是凉了。电脑有空闲的时候我帮忙抄了后缀数组，首先被卡了一下内存，然后t了一发，改了初始化，最后get了一个wa，可能猜的结论有问题。然后就结束了。 赛后zyf问了一下，J似乎思路大致是对的，可能哪炸了。颁奖没来得及参加，赶飞机(暗示打铁)。于是离铜线差了2名，真实铁首。 胡乱分析一波，发现又死在大家都会的博弈上。去年杭州，去年ec…看来得在这方面努力一下了。(为什么去的这么多场现场赛都有大家都会的博弈，自己训练都没遇到过..) 最后丢个狗牌好了。","path":"2018/10/28/2018CCPCguilin/","date":"10-28","excerpt":""},{"title":"2018ICPC沈阳赛区","text":"转载请注明出处：http://tokitsukaze.live/ day0： 提前一天飞沈阳(估计是机票便宜)，思考了一下就两个晚上，带电脑麻烦，就带上3ds，爬了一天新树2。 day1： 热身赛3个题。好几次，我们写着写着，cb未响应…然后没保存的代码就飞了(体验极差)。于是只能边打随手ctrl+s了。对面zju神仙队。开场就来了一个人，写了签到半小时后，另外两个人来，再半小时后，就ak了？？B题看上去是个n^2dp，然后对面过了后去转了一圈回来，说：”看起来大家写的都是n^2记忆化”。然后被彻底带歪了…我提出了个O(n)做法，chy出了个假数据，把我插了？？？然后出来zyf知道了做法，说是正解(确实是正解)… day2： 正赛。开场zyf读了J，说是大(?)模拟。我读了D，发现做不来。然后16分钟J一血出现，发现是个小模拟签到，zyf和chy切之。期间20+分钟的时候有人切了K，我看K，K是问约瑟夫环第k个出队的人是谁。观察到数据范围sum(min(m,k))≤1e6，思考了一下，没想法。J大概40+分钟的时候切了，然后他们开始思考K，我看其他题。期间chy告诉我E题意，没啥想法，扔了。他们思考一段时间后，没啥办法，看榜，C过的多，他们开C。然后我看G，没仔细想，感觉kd-tree能做，电脑也是空着的，我就上机抄了4页kd-tree板子，30分钟差不多抄完了(板子抄的真开心，期间cb闪退了一次..不过问题不大。)，他们要上C，我下机。仔细读了一下G，思考怎么写query，然后看到题面上说kd-tree能被卡成n^2，我想了想还tm真是…然后放弃kd-tree做法。这时候听到他们C开始打暴力凑答案了？？发现跟暴力的答案差了一个n!的等差数列？？？加上去过了？？？这时候已经3h过了。看榜发现G过的比K多，于是集火G。仔细分析了一下题目，是网格图，修改查询只跟圆上整数点有关，而圆上整数点相当少。我暴力了一下勾股数，发现对于每个c^2，符合a^2+b^2=c^2的(a,b)确实比较少，可以直接暴力。然后chy上机写，写的时候发现数据组数多，不能memset初始化，我说等你写完给我改(伏笔)。然后我就帮忙写了一下强制在线的转换，调了调，样例过了！交tm的！刚交上去，马上想起来，memset没改….改了之后马上补交，过了。这时候是刚封榜不久。看了看榜，几何有排名后面的队伍过了，当时时间不多，不敢开，只能强行开K，在最后zyf似乎知道了做法，没打完。 赛后听题解： 我：什么？E线段树？切比雪夫距离还不会转..什么？拉格朗日插值？FWT？我们差的是这个板子吗，不差，这锅不背！傻逼几何题？行了行了，是我输了。 chy：什么？后缀数组？ zyf：什么？？M是可逆背包？？ 看起来还是我的锅比较多… 看榜发现大部分没过G的队伍都交了G，我想他们肯定都过了！铜首稳了！结果他们都没过..摸了个银尾。 至于对面的zju神仙，似乎开场被FWT卡了，用CRT合并模数，后来还开始怀疑CRT板子错了(结论：开始怀疑板子有问题的时候，肯定凉了)。然后K递归爆栈。反正总之就是，太惨了.. update： E题题解：http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.E/ G题题解：http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.G/ L题题解：http://tokitsukaze.live/2018/11/02/2018ICPCShenyangOnsite.L/ I题题解：http://tokitsukaze.live/2018/11/15/2018ICPCShenyangOnsite.I/","path":"2018/10/21/2018ICPCshenyang/","date":"10-21","excerpt":""},{"title":"2018 CCPC-Wannafly Camp Day3 G.Stones (sg函数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/203/G 题意： 题解：0到a-1为必败点，sg值为0。a到b，只要出现就直接Yes，无需考虑，设为不可达点，sg值为-1，表示不转移。大于b的直接转移即可。由于x很大，暴力打sg表后找规律即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=1e9+7;/********************************* head *********************************//*int f[1111],sg[MAX];void SG(int n,int a,int b)&#123; int i,j,flag[111]; mem(sg,0); for(i=a;i&lt;=b;i++) sg[i]=-1; for(i=b+1;i&lt;=n;i++) &#123; mem(flag,0); for(j=a;j&lt;=i&amp;&amp;j&lt;=b;j++) &#123; if(i-j&gt;=0&amp;&amp;sg[i-j]!=-1) flag[sg[i-j]]=1; &#125; for(j=0;;j++) &#123; if(!flag[j]) &#123; sg[i]=j; break; &#125; &#125; &#125;// for(i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;sg[i]&lt;&lt;endl; cout&lt;&lt;sg[n]&lt;&lt;endl;&#125;void go()&#123; SG(4,1,3); SG(6,1,3); SG(100,1,15); SG(100,5,21); SG(145,23,54); SG(654,98,137); SG(234,98,137); SG(235,98,137); SG(332,98,137); SG(333,98,137);&#125;*/void go()&#123; int t,n,a,b,sg,f1,f2,x,tmp,i; read(t); while(t--) &#123; read(n,a,b); sg=0; f1=1; f2=0; for(i=1;i&lt;=n;i++) &#123; read(x); f1&amp;=(x&lt;a); f2|=(x&gt;=a&amp;&amp;x&lt;=b); if(a==1) sg^=(x-b-1)%(a+b); else if(x&gt;b) &#123; x-=b; x%=(a+b); x/=a; if(x==0||x==1) x^=1; sg^=x; &#125; &#125; if(f1) puts(\"No\"); else if(f2) puts(\"Yes\"); else &#123; // debug(sg) if(sg) puts(\"Yes\"); else puts(\"No\"); &#125; &#125;&#125;","path":"2018/10/04/2018CCPC-Wannafly-Camp-Day3.G/","date":"10-04","excerpt":""},{"title":"2018 CCPC-Wannafly Camp Day6 A.矩阵乘法","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/202/A 题意：给出两个矩阵。矩阵A为n*p，矩阵B为p*m，其中矩阵B为01矩阵。求矩阵C=A*B，输出矩阵C中所有元素的异或和。n,m≤4096，p≤64。 题解：直接模拟矩阵乘法：4096*4096*64，TLE。 把矩阵B的4096列，每列分成8块，每块8位。预处理出每块转换成0~255的十进制数。 把矩阵A的4096行，每行分成8块，每块8个元素，对应着矩阵B的4096列的每列。二进制枚举预处理出所有256种情况，存在表里。 然后做矩阵乘法，每块直接查表。 预处理打表：4096*8*256*8。矩阵乘法：4096*4096*8。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e6+10;const ll mod=1e9+7;/********************************* head *********************************/int a[4111][66],b[4111][11][266],res[4111][11];void go()&#123; int n,p,m,i,j,k,l,len,ans,tmp; char s[66]; while(~scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;m)) &#123; mem(a,0); mem(b,0); for(i=0;i&lt;n;i++) &#123; for(j=p-1;~j;j--) &#123; scanf(\"%X\",&amp;a[i][j]); &#125; for(l=0;l&lt;8;l++) &#123; for(j=0;j&lt;256;j++) &#123; for(k=0;k&lt;8;k++) &#123; if(j&amp;(1&lt;&lt;k)) b[i][l][j]+=a[i][l*8+k]; &#125; &#125; &#125; &#125; mem(res,0); for(i=0;i&lt;m;i++) &#123; scanf(\"%s\",s); len=strlen(s); tmp=1; k=0; for(j=len-1;~j;j--) &#123; if(s[j]=='1') res[i][k]+=tmp; if(tmp==128) &#123; k++; tmp=1; &#125; else tmp*=2; &#125; &#125; ans=0; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; tmp=0; for(k=0;k&lt;8;k++) &#123; tmp+=b[i][k][res[j][k]]; &#125; ans^=tmp; &#125; &#125; /* for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; tmp=0; for(k=0;k&lt;8;k++) &#123; tmp+=b[i][k][res[j][k]]; &#125; printf(\"%d \",tmp); &#125; puts(\"\"); &#125;*/ printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/10/03/2018CCPC-Wannafly-Camp-Day6.A/","date":"10-03","excerpt":""},{"title":"2018 CCPC-Wannafly Camp Day2 I.Steins;Gate (原根+FFT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/201/I 题意： 题解：求出模数P的原根，打个指标表I[]。根据指标法则：I(a*b)≡I(a)+I(b) (mod P-1)。于是把乘法转换成加法，就变成了一个FFT计数了。注意0要单独统计。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=1e9+7;/********************************* head *********************************/int p[MAX],tot,prime[MAX];void init(int n)&#123; int i,j; tot=0; mem(prime,0); prime[1]=1; for(i=2;i&lt;=n;i++) &#123; if(!prime[i]) prime[i]=p[tot++]=i; for(j=0;j&lt;tot&amp;&amp;p[j]*i&lt;=n;j++) &#123; prime[i*p[j]]=p[j]; if(i%p[j]==0) break; &#125; &#125;&#125;ll pow2(ll a,ll b,ll p)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int tp[MAX];int find_root(int x)&#123; if(x==2) return 1; int f,phi=x-1; tp[0]=0; for(int i=0;phi&amp;&amp;i&lt;tot;i++) &#123; if(phi%p[i]==0) &#123; tp[++tp[0]]=p[i]; while(phi%p[i]==0) phi/=p[i]; &#125; &#125; if(phi!=1) tp[++tp[0]]=phi; phi=x-1; for(int g=2;g&lt;=x-1;g++) &#123; f=1; for(int i=1;i&lt;=tp[0];i++) &#123; if(pow2(g,phi/tp[i],x)==1) &#123; f=0; break; &#125; &#125; if(f) return g; &#125; return 0;&#125;int I[MAX];void get_I(int p)&#123; int g,now; g=find_root(p); now=1; for(int i=1;i&lt;p;i++) &#123; now=now*g%p; I[now]=i; &#125;&#125;namespace FFT&#123; #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) const double pi=acos(-1); const int maxn=1&lt;&lt;19; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],int k,int v) &#123; int i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,int l1,int l2) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]; return; &#125; int K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,l1+l2)a[i]=(ll)(z[i].a+0.5); &#125;&#125;;ll a[MAX&lt;&lt;1],x[MAX],res[MAX&lt;&lt;1];void go()&#123; init(200000); int n,i,p; ll cnt; while(read(n,p)) &#123; get_I(p); mem(a,0); cnt=0; for(i=1;i&lt;=n;i++) &#123; read(x[i]); if(x[i]%p) a[I[x[i]%p]%(p-1)]++; else cnt++; &#125; mem(res,0); FFT::mul(res,a,a,p-1,p-1); for(i=p-1;i&lt;2*p;i++) res[i-(p-1)]+=res[i]; for(i=1;i&lt;=n;i++) &#123; if(x[i]&gt;=p) puts(\"0\"); else if(x[i]==0) printf(\"%lld\\n\",cnt*(n-cnt)*2+cnt*cnt); else printf(\"%lld\\n\",res[I[x[i]]%(p-1)]); &#125; &#125;&#125;","path":"2018/10/02/2018CCPC-Wannafly-Camp-Day2.I/","date":"10-02","excerpt":""},{"title":"ACM-ICPC 2018 青岛赛区网络预赛 B. Red Black Tree (二分答案+LCA)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4048 题意：给一棵有根树，根为1。边有边权。其中m个节点是红色，其他节点是黑色。有q次询问，每次查询给k个节点。然后你可以选择树上最多一个节点变成红色。设d[x]为节点x到离他最近的红色节点的距离，还要求红色节点必须是节点x的祖先。如果x是红色，那么d[x]=0。求出k个节点的max{d[i]}，使这个值最小化。 题解：考虑答案是单调的，我们可以二分答案。然后check，把询问的节点，如果满足就扔掉。最后把剩下这些不满足的，求个他们共同的LCA，那个点设为红点肯定最优，然后再判断是否满足。 dfs一遍可以预处理每个点的d[x]，用来判断是否满足。O(nlogn)预处理ST表，LCA就能O(1)查询了。然后求共同的LCA，可以直接for一遍，对当前LCA和点求LCA就行。(或者取出dfn(dfs序)最小和最大的点求一次LCA，一定就是所有的点的共同LCA。这样的话查询次数较少，可以O(n)做树链剖分，然后每次查询O(logn)。) 复杂度nlogn级别的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct node&#123; int to; ll w; node()&#123;&#125; node(int _to,ll _w) :to(_to),w(_w)&#123;&#125;&#125;;ll dis[MAX],disred[MAX];int path[2*MAX],deep[2*MAX],first[MAX],tot;int dp[2*MAX][20];bool flag[MAX];vector&lt;node&gt; mp[MAX];void dfs(int x,int pre,int h)&#123; int i; path[++tot]=x; first[x]=tot; deep[tot]=h; for(i=0;i&lt;mp[x].size();i++) &#123; int to=mp[x][i].to; if(to==pre) continue; disred[to]=min(disred[to],disred[x]+mp[x][i].w); dis[to]=dis[x]+mp[x][i].w; dfs(to,x,h+1); path[++tot]=x; deep[tot]=h; &#125;&#125;void ST(int n)&#123; int i,j,x,y; for(i=1;i&lt;=n;i++) &#123; dp[i][0]=i; &#125; for(j=1;(1&lt;&lt;j)&lt;=n;j++) &#123; for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; x=dp[i][j-1]; y=dp[i+(1&lt;&lt;(j-1))][j-1]; dp[i][j]=deep[x]&lt;deep[y]?x:y; &#125; &#125;&#125;int query(int l,int r)&#123; int len,x,y; len=(int)log2(r-l+1); x=dp[l][len]; y=dp[r-(1&lt;&lt;len)+1][len]; return deep[x]&lt;deep[y]?x:y;&#125;int LCA(int x,int y)&#123; int l,r,pos; l=first[x]; r=first[y]; if(l&gt;r) swap(l,r); pos=query(l,r); return path[pos];&#125; int getdist(int a,int b)&#123; return dis[a]+dis[b]-2*dis[LCA(a,b)];&#125;void work(int n)&#123; int i; for(i=1;i&lt;=n;i++) dis[i]=0; tot=0; dfs(1,0,0); ST(2*n-1);&#125;int tmp[MAX];void go()&#123; int t,n,m,q,i,a,b,w,k; ll l,r,mid; read(t); while(t--) &#123; read(n,m,q); for(i=1;i&lt;=n;i++) &#123; mp[i].clear(); disred[i]=LLINF; &#125; while(m--) &#123; read(a); disred[a]=0; &#125; for(i=1;i&lt;n;i++) &#123; read(a,b,w); mp[a].pb(node(b,w)); mp[b].pb(node(a,w)); &#125; work(n); while(q--) &#123; read(k); l=r=0; for(i=1;i&lt;=k;i++) &#123; read(tmp[i]); r=max(r,dis[tmp[i]]); &#125; VI res; auto check=[&amp;](ll x)-&gt;int &#123; res.clear(); for(i=1;i&lt;=k;i++) &#123; if(disred[tmp[i]]&gt;x) res.pb(tmp[i]); &#125; if(sz(res)&lt;=1) return 1; int lca=res[0]; for(i=1;i&lt;sz(res);i++) lca=LCA(lca,res[i]); for(i=0;i&lt;sz(res);i++) &#123; if(dis[res[i]]-dis[lca]&gt;x) return 0; &#125; return 1; &#125;; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid; else l=mid+1; &#125; printf(\"%lld\\n\",l); &#125; &#125;&#125;","path":"2018/09/16/2018QingdaoOnline.B/","date":"09-16","excerpt":""},{"title":"ACM-ICPC 2018 焦作赛区网络预赛 E. Jiu Yuan Wants to Eat (树链剖分+线段树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://nanti.jisuanke.com/t/31714 题意：给一棵有根树，根为1。每个节点初始值为0。4种操作：1 u v x：路径u到v上，每个节点的值乘x。2 u v x：路径u到v上，每个节点的值加x。3 u v：路径u到v上，每个节点的值按位取反。4 u v：求路径u到v上，每个节点的值的和mod 2^64。 题解：由于答案mod 2^64，也就是要ull，第3个操作可以转换为每个节点的值v，v=v*(-1)-1。所以先做个树剖，然后就变成有加有乘的双tag线段树了。复杂度O(q*(logn)^2)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Segment_Tree&#123; #define type ull #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr,op; type v[MAX&lt;&lt;2],tag[MAX&lt;&lt;2],qv,mul[MAX&lt;&lt;2]; void pushup(int id) &#123; v[id]=v[ls]+v[rs]; &#125; void pushdown(int id,int l,int r) &#123; if(mul[id]!=1) &#123; mul[ls]*=mul[id]; mul[rs]*=mul[id]; v[ls]*=mul[id]; v[rs]*=mul[id]; tag[ls]*=mul[id]; tag[rs]*=mul[id]; mul[id]=1; &#125; if(tag[id]) &#123; tag[ls]+=tag[id]; tag[rs]+=tag[id]; ll mid=(l+r)&gt;&gt;1; v[ls]+=(mid-l+1)*tag[id]; v[rs]+=(r-mid)*tag[id]; tag[id]=0; &#125; &#125; void build(int l,int r,int id) &#123; tag[id]=v[id]=0; mul[id]=1; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); pushup(id); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; if(op==1)//mul &#123; v[id]*=qv; mul[id]*=qv; tag[id]*=qv; &#125; else if(op==2)//add &#123; v[id]+=(r-l+1)*qv; tag[id]+=qv; &#125; else//mul(-1) add-1 &#123; v[id]*=-1; mul[id]*=-1; tag[id]*=-1; v[id]+=(r-l+1)*(-1); tag[id]+=(-1); &#125; return; &#125; pushdown(id,l,r); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; type query(int l,int r,int id) &#123; type res=0; if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; pushdown(id,l,r); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res+=query(l,mid,ls); if(qr&gt;mid) res+=query(mid+1,r,rs); return res; &#125; void build(int _n)&#123;n=_n;build(1,n,1);&#125; void upd(int l,int r,type v,int _op) &#123; ql=l; qr=r; qv=v; op=_op; update(1,n,1); &#125; type ask(int l,int r) &#123; ql=l; qr=r; return query(1,n,1); &#125; #undef type #undef ls #undef rs&#125;tr;struct HLD&#123; #define type ull struct edge&#123;int a,b;type v;edge(int _a,int _b,type _v=0):a(_a),b(_b),v(_v)&#123;&#125;&#125;; vector&lt;int&gt; mp[MAX]; vector&lt;edge&gt; e; int deep[MAX],fa[MAX],size[MAX],son[MAX]; int rnk[MAX],top[MAX],idx[MAX],tot; int n,rt; void init(int _n) &#123; n=_n; for(int i=1;i&lt;=n;i++) mp[i].clear(); e.clear(); e.pb(edge(0,0)); &#125; void add_edge(int a,int b,type v=0) &#123; mp[a].pb(b); mp[b].pb(a); &#125; void dfs1(int x,int pre,int h) &#123; int i,to; deep[x]=h; fa[x]=pre; size[x]=1; for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to==pre) continue; dfs1(to,x,h+1); size[x]+=size[to]; if(son[x]==-1||size[to]&gt;size[son[x]]) son[x]=to; &#125; &#125; void dfs2(int x,int tp) &#123; int i,to; top[x]=tp; idx[x]=++tot; rnk[idx[x]]=x; if(son[x]==-1) return; dfs2(son[x],tp); for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to!=son[x]&amp;&amp;to!=fa[x]) dfs2(to,to); &#125; &#125; void work(int _rt) &#123; int i; rt=_rt; mem(son,-1); tot=0; dfs1(rt,0,0); dfs2(rt,rt); &#125; //node void init_node() &#123; tr.build(n); &#125; void modify_node(int x,int y,type val,int op) &#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); tr.upd(idx[top[x]],idx[x],val,op); x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); tr.upd(idx[x],idx[y],val,op); &#125; type query_node(int x,int y) &#123; type res=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); res+=tr.ask(idx[top[x]],idx[x]); x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); res+=tr.ask(idx[x],idx[y]); return res; &#125; #undef type&#125;hld; //hld.init(n)void go()&#123; int n,i,q,a,b,op; ull x; while(read(n)) &#123; hld.init(n); for(i=2;i&lt;=n;i++) &#123; read(q); hld.add_edge(i,q); &#125; hld.work(1); hld.init_node(); read(q); while(q--) &#123; read(op,a,b); if(op==4) printf(\"%llu\\n\",hld.query_node(a,b)); else &#123; if(op!=3) read(x); else x=0; hld.modify_node(a,b,x,op); &#125; &#125; &#125;&#125;","path":"2018/09/16/2018JiaozuoOnline.E/","date":"09-16","excerpt":""},{"title":"「艦これ」「2018初秋」抜錨！連合艦隊、西へ！","text":"转载请注明出处：http://tokitsukaze.live/ 目前进度：活动结束。注意： 1.？表示不确定。 2.制空值是本人攻略时候的制空值，仅供参考。 3.所有配置仅供参考。 —————————————————作戦準備————————————————— —————————————————前段作戦————————————————— E1 作戦準備！後方兵站線確保E2 海峡奪還作戦E3 西方敵前線泊地を叩け！ ————————————————前段作戦结束———————————————— —————————————————後段作戦————————————————— E4 ジェノヴァの風 E5 全力出撃！新ライン演習作戦 ————————————————后段作戦结束————————————————","path":"2018/09/09/KancolleInvent2018summer/","date":"09-09","excerpt":""},{"title":"ACM-ICPC 2018 沈阳赛区网络预赛 J. Ka Chang (dfs序+树状数组+根号分治)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://nanti.jisuanke.com/t/31451 题意：给一棵有根树，根为1。根的深度为0。每个节点初始值为0。两种操作：1 L X：把深度为L的节点的值增加X。2 X：询问X的子树的和。 题解：做个dfs序，开个树状数组维护。设定阈值sq=sqrt(n)。对于深度L：1.深度为L的节点个数小于等于sq时，我们可以暴力枚举每个节点在树状数组内更新。2.深度为L的节点个数大于sq时，记录这个深度的修改量，查询的时候，遍历有修改过的深度，二分查询有多少个节点在子树中，乘上这个深度的修改量即可。 这么做均摊了一下复杂度，复杂度是根号级别的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Fenwick_Tree&#123; #define type ll type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res; &#125; type query(int l,int r) &#123; return get(r)-get(l-1); &#125; #undef type&#125;tr;VI mp[MAX],h[MAX];ll tag[MAX];int l[MAX],r[MAX],tot,deep[MAX];void dfs(int x,int fa,int dep)&#123; deep[x]=dep; l[x]=++tot; h[dep].pb(l[x]); for(auto to:mp[x]) &#123; if(to==fa) continue; dfs(to,x,dep+1); &#125; r[x]=tot;&#125;void go()&#123; int n,q,i,a,b,op,L; ll x; while(read(n,q)) &#123; for(i=0;i&lt;=n;i++) &#123; h[i].clear(); mp[i].clear(); tag[i]=0; &#125; for(i=1;i&lt;n;i++) &#123; read(a,b); mp[a].pb(b); &#125; tot=0; dfs(1,0,0); for(i=0;i&lt;=n;i++) sort(all(h[i])); tr.init(n); int sq=sqrt(n+0.5); set&lt;int&gt; s; while(q--) &#123; read(op); if(op==1) &#123; read(L,x); if(L&gt;n) continue; if(sz(h[L])&lt;=sq) &#123; for(auto it:h[L]) &#123; tr.insert(it,x); &#125; &#125; else &#123; s.insert(L); tag[L]+=x; &#125; &#125; else &#123; read(x); ll ans=tr.query(l[x],r[x]); for(auto it:s) &#123; if(it&lt;deep[x]) continue; int tl,tr; tr=upper_bound(all(h[it]),r[x])-h[it].begin(); tl=lower_bound(all(h[it]),l[x])-h[it].begin(); ans+=tag[it]*(tr-tl); &#125; printf(\"%lld\\n\",ans); &#125; &#125; &#125;&#125;","path":"2018/09/09/2018shenyangonline.J/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E5 全力出撃！新ライン演習作戦","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E5甲 P1，P2，各自单独锁。 注意：1.P1贴蓝条，P2贴紫条，P3只能用蓝条或者紫条，不能混用。2.？表示不确定P1 路线：道中2战1鱼(1空袭)。 配置：机动。我的配置是要打空袭的，空袭很菜，不需要刻意回避。全高速回避空袭？(划掉，好像还有其他条件)。厌战有倍卡。方舟带剑鱼有倍卡？ 支援：双支援。 路航：两队13丢boss，一队防空。 P2 路线：2战1鱼。 配置：水打。T-&gt;R条件：欧洲船&gt;=6？Q-&gt;P条件：bb&lt;=2 支援：双支援。 路航：两队13丢boss，另一队可以选择炸鱼，斩杀时必须13/04丢boss。 P3 开路阶段： 1.H，I点S胜。用P1配置即可。 此时开出boss点。 2.S，T点S胜+守家白字2次。S和T都是鱼。配置：水打一队3bb2ca1cv 二队炸鱼。T-&gt;S：欧洲船&lt;6？好像还有其他条件。一队只有1bb1ca时，T-&gt;R。(所以才上了那么多船，一队其实没用的) 3.K点空袭空优两次。用P2配置，一队3bb可以进k，一队ca换个cav背水战。路航压制k，航程4。 开出Z3。开路完成。 削甲/攻略阶段： 1.磨血，进斩杀线。配置：我用的是水打，走的不是最短路。猜测M-&gt;X条件为bb&lt;=2。X-&gt;Z3条件为一队吨位轻，cl+cvl可以走，否则走Y(Y为普通战斗)。参考配置：P3水打磨血参考配置。此配置路线为X-&gt;Z3。 2.进斩杀线后，水打进bossA胜。参考配置：P3水打斩杀参考配置。此配置路线为X-&gt;Z3。 3.进斩杀线后，机动进bossA胜。参考配置：P3机动斩杀参考配置。此配置路线为X-&gt;Y。此配置的2bb换成1cl1dd，路线为X-&gt;Z3？ 4.z3空优？(我没有这一步，削甲就成功了，所以没有配置。) 削甲成功，回港会听到任务完成提示音。 5.斩杀。削完甲就随便打了，机动水打都行。懒得换水打，直接机动两把斩了。 支援：双支援。 路航：三队13飞boss，航程7。 注意：斩杀制空要求大概490左右。(削甲后貌似低了点？机动410出门，boss能空优。) 奖励：勋章*2，螺丝*10，Ju87C改二(KMX熟练)*1，Mk.I+FCR*1，甲章*1。新船：Nelson。 P1 P1参考配置： P2 P2参考配置： P3 磨血： 削甲前的斩杀： 削甲后斩杀： P3水打： 路线： 磨血参考配置： 斩杀参考配置： P3机动： 路线： 磨血参考配置：无。 斩杀参考配置：","path":"2018/09/09/KancolleInvent2018summerE5/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E4 ジェノヴァの風","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ e4甲 单独锁。 P1运输 路线：道中2战/3战。 配置：运输一队1av+大鹰+4大发dd 二队1cl+libeccio+zara/pola+3dd。出门随机？个人配置制空190，道中I概率空优，boss空优线比这低。 支援：道中。 路航：13或者04。 P2 开路阶段： 1.R点S胜。配置：2bb2cv2dd。R点是鱼，2dd开幕反潜。 2.O点A胜。配置：2bb1cv1ca2dd。O点是陆基。 此时开出S点和boss点。 3.S点A胜。配置：水打一队2bb2ca1dd1cv 二队随意。道中有潜水鸡，二队可以带点开幕反潜。 此时开出门神V点(红雷，概率单纵..)，开路结束。 注意：开路用的bb和ca都是意大利级。cv用的是Aquila和云龙级。 攻略阶段： 路线：道中2战2空袭。 配置：意大利+罗马+zara+Aquila+2dd。boss不是陆基，一个dd打ci。boss点配置有个集地，一个dd赛艇，可以三件套，也可以2炮+11连队(boss点有个pt，洞里塞机枪打pt)。带340而不是910的原因是夜战可能会被集地吸火力，910打不动。 支援：道中随意，决战最好上一下。 路航：04洗boss，注意航程9。 奖励：勋章*1，女神*3，打洞*1，Bofors15.2 +5 *1，Osprey +5 *1,。新船：Maestrale。 P1： P1参考配置： P2： 开路阶段： 1.R点S胜参考配置： 2.O点A胜参考配置： 3.S点A胜参考配置： 攻略阶段： 参考配置：","path":"2018/09/09/KancolleInvent2018summerE4/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E3 西方敵前線泊地を叩け！","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E3甲 单独锁。 P1 路线：道中2战，门神屌阵怂不过就单纵干。 配置：1bb1cav1cv1cl2dd，出门制空160左右。 支援：道中。 路航：两队04丢boss。 P2 路线：道中2战1鱼。 配置：机动一队1bb2cv1ca2cav 二队1cl1ca2clt2dd，出门制空&lt;=420。 支援：道中。 路航：路航两队04丢boss，注意航程是9。 P3 路线：同P2。 配置：机动一队双龙吃撑1cav1ca1ssv 二队同P2，cav4水战，ssv提速2水战。出门制空&lt;=510，若路航是两队04，则需要更高？ 支援：道中，斩杀上个决战。 路航：一队大艇拖64队+54队+34型，二队同P2。 奖励：勋章*1，详报*1，97舰攻931空熟练*1，Ju87C改二(KXM) *1。新船：神鹰。 P1 P1参考配置：(这里不该交由良，E5P3需要2个背水战的cl。交了也无妨就是了。) P2 P2参考配置： P3 P3参考配置：","path":"2018/09/09/KancolleInvent2018summerE3/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E2 海峡奪還作戦","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E2甲 单独锁。 P1运输 路线：道中2战，继续屌阵怂过去，无需支援，路航04丢boss，对面无制空。 配置：1ca1cav4dd，cacav正常配装，dd全赛艇，门神索敌沟，索敌大约16能进。 P2 路线：道中2战1空袭，无需支援，路航04丢boss。 配置：1bb1cav1cvl3dd，2dd三件套，1dd打飞机，出门制空150左右。 奖励：甲板*1，伊良湖*3，间宫*3，油桶*3，12.7B型改四(战时改修)+高射装置*1，水侦11型乙(熟练)*1 P1 P1参考配置： P2 P2参考配置：","path":"2018/09/09/KancolleInvent2018summerE2/","date":"09-09","excerpt":""},{"title":"「艦これ」「2018初秋」E1 作戦準備！後方兵站線確保","text":"转载请注明出处：http://tokitsukaze.live/ 「2018初秋」抜錨！連合艦隊、西へ！ E1甲 单独锁。 路线：道中2战，屌阵怂过去。无需支援。 配置：1cl4dd全对潜，5船回避H(漩涡)，斩杀有困难可上6船。 奖励：职人*1，饭团*2，22改四后期型*1，火箭弹*1，大发*1，内火*1","path":"2018/09/09/KancolleInvent2018summerE1/","date":"09-09","excerpt":""},{"title":"hdu 6447 YJJ's Salesman (dp+树状数组)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6447 题意：从 (0,0) 往 (1e9,1e9)走，每次只能从 (x,y)走到 (x+1,y) 或者 (x,y+1)或者 (x+1,y+1)。某些点(x,y)有价值v，当且仅当从 (x−1,y−1)走到(x,y)时，才能获得v，求获得的价值总和最大是多少。 题解：点只有1e5个。dp[i]表示走到第i个点能获得的最大价值。转移：dp[i]=max(dp[j])+v[i]，需要满足条件x[j]&lt;=x[i]-1且y[j]&lt;=y[i]-1。 对x进行从小到大sort，然后扫描线扫过去。这样保证了转移的第一个条件。 对y离散化一下，开一个树状数组，下标表示y。每次通过树状数组查询前缀最大值进行dp转移。转移之后把dp值插入树状数组。这样保证了转移的第二个条件。 注意：因为x[j]&lt;=x[i]-1，所以当x相同的时候，dp转移完不能马上插入树状数组，马上插入的话会导致转移条件变为x[j]&lt;=x[i]，这样就错了。所以当x相同的时候，我们先开个vector存放一下，等到碰到不同的x的时候，再全部一起插入。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=3.1415926;const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct Fenwick_Tree&#123; #define type int type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]=max(bit[x],v); x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res=max(res,bit[x]); x-=lowbit(x); &#125; return res; &#125; #undef type&#125;tr;struct node&#123; int x,y,v; node()&#123;&#125; friend bool operator &lt;(node a,node b)&#123;return a.x&lt;b.x;&#125; void input()&#123;read(x,y,v);&#125;&#125;a[MAX];int y[MAX];void go()&#123; int t,i,n,tot,ans; read(t); while(t--) &#123; read(n); for(i=0;i&lt;n;i++) &#123; a[i].input(); y[i]=a[i].y; &#125; sort(a,a+n); sort(y,y+n); tot=unique(y,y+n)-y; tr.init(tot+5); ans=-INF; VI tmp; for(i=0;i&lt;n;i++) &#123; a[i].y=lower_bound(y,y+tot,a[i].y)-y+1; if(sz(tmp)&amp;&amp;a[i].x!=a[tmp[0]].x) &#123; for(auto &amp;j:tmp) tr.insert(a[j].y+1,a[j].v); tmp.clear(); &#125; a[i].v+=tr.get(a[i].y); ans=max(ans,a[i].v); tmp.pb(i); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/28/hdu6447/","date":"08-28","excerpt":""},{"title":"hdu 6444 Neko's loop (单调队列)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6444 题意：给出一个 n 个元素的环、可以任意选择起点、选完起点后、可以行走 m 步、每次前进 k 个单位、所走到的点将产生正或负贡献、问你一开始得准备多少才能使得初始资金加上在环上获取最大利益不少于给定的 s。 题解：其实就是找走m步的途中获得的最大值mx。如果大于等于s，ans=0，否则ans=s-mx。先暴力把每个环找出来。对于每个环，我们考虑以下几个事情：1.找到环的最优起点。2.m步可以走很多次环。如果整个环的贡献为正，那么多的环的贡献就直接乘一下加进来，如果为负，可以只选择从最优起点开始走，或者甚至不走。 那么如何找到环的最优起点。其实这个问题就是找一个和最大的连续子序列且长度不超过len，len为单独考虑的步数。那么我们可以先做前缀和，数组为bit，问题就变成求bit[i]-bit[j-1]的最大值，且i-j+1&lt;=len。然后控制窗口长度为len，进行滑窗，对于每个j-1，用单调队列来维护bit[i]的最大值，所以应该倒着for。代码中维护的窗口长度是len+1，这样就变成求bit[i]-bit[j]的最大值，会好写一点。注意bit[0]=0，而且碰到bit[0]时默认入队，因为bit[1]可能是负的，所以这里要特判一下。 对于len的选取： 首先有一种情况是这样的：5 100 12 1-10 1 2 3 5整个环的贡献是+1。最优走法肯定是：-10 {1 2 3 5}如果我们选择2个整环+2步的话(len=2)，最大值只能达到10。但如果我们选择1个整环+7步的话(len=7)，最大值可以达到12。走法：-10 {1 2 3 5，-10 1 2 3 5} 然后我的写法会出现第二种情况：6 100 12 51 2 3 4 -5 6整个环的贡献是+11。如果我们选择2个整环+0步(len=0)，最大值只能达到22。但如果我们选择1个整环+6步(len=6)，最大值可以达到27。但是走法是这样的：1 2 3 4 -5 {6 ，1 2 3 4 -5 6 ，1 2 3 4} -5 6跨越了3个环。所以对于我这种写法，这里的len要取12。要把环的数组复制3遍后再做前缀和。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=3.1415926;const double eps=1e-6;const int MAX=3e4+10;const ll mod=1e9+7;/********************************* head *********************************/ll res[MAX],tmp[MAX],a[MAX],bit[MAX],dq[MAX];int flag[MAX],tot;ll n,s,m,k;void gao(int pos)&#123; int i,j,tag=pos+1,top=0,len; ll cnt; for(i=pos;flag[i]!=tag;i=(i+k)%n) &#123; tmp[++top]=a[i]; flag[i]=tag; &#125; for(i=1;i&lt;=top;i++) tmp[i+top]=tmp[i+top*2]=tmp[i]; cnt=m/top; len=m%top; if(!len&amp;&amp;cnt) &#123; len=top; cnt--; &#125; if(cnt) &#123; cnt--; len+=top; &#125; top=top*3; res[++tot]=0; bit[0]=0; for(i=1;i&lt;=top;i++) bit[i]=bit[i-1]+tmp[i]; int l,r; l=r=0; for(i=j=top;i;i--) &#123; while(~j&amp;&amp;i-j&lt;=len) &#123; while(r-l&amp;&amp;j&amp;&amp;bit[dq[r-1]]&lt;bit[j]) r--; dq[r++]=j--; &#125; while(r-l&amp;&amp;dq[l]&gt;i) l++; res[tot]=max(res[tot],bit[dq[l]]-bit[dq[r-1]]); &#125; if(bit[top/3]&gt;=0) res[tot]+=bit[top/3]*cnt;&#125;void go()&#123; int t,cas=1,i; read(t); while(t--) &#123; read(n,s,m,k); for(i=0;i&lt;n;i++) read(a[i]); mem(flag,0); tot=0; for(i=0;i&lt;n;i++) &#123; if(flag[i]) continue; gao(i); &#125; ll ans=-LLINF; for(i=1;i&lt;=tot;i++) ans=max(ans,res[i]); printf(\"Case #%d: %lld\\n\",cas++,max(0LL,s-ans)); &#125;&#125;/*25 100 12 1-10 1 2 3 56 100 12 51 2 3 4 -5 6ans:8873*/","path":"2018/08/27/hdu6444/","date":"08-27","excerpt":""},{"title":"hdu 6438 Buy and Resell (贪心)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6438 题意：在一个数轴上有n个点，为1到n。每个点上有个值v。你可以在一个点上选择：买入一个商品花费v，卖出一个商品赚取v(如果手持有商品的话)，什么都不干。问从1走到n最多赚多少，在保证赚取最多的情况下，输出最少的交易次数。 题解：用优先队列维护一个结构体{v,cnt}。v表示某个点的价值，cnt表示那个点是不是卖出点。优先队列先出v小的，v相同先出cnt=1的。因为要求交易次数最少，价格相同时，把卖出点作为中转点，先出队，就能满足这个要求。每次走到一个点，如果点的价值v比优先队列中最小值大，就更新答案，然后推入{v,1}。然后每个点固定推入{v,0}。最后统计优先队列中cnt=1的个数*2就是最少交易次数。 比如：1 2 5。第1个点：入{1,0}第2个点：出{1,0}，ans+=2-1=1，入{2,1}，入{2,0}。第3个点：出{2,1}，ans+=5-2=4，入{5,1}，入{5,0}。最后优先队列中有：{2,0}，{5,1}，{5,0}。最少交易次数为2。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct node&#123; ll v,cnt; node()&#123;&#125; node(ll _v,ll _cnt):v(_v),cnt(_cnt)&#123;&#125; friend bool operator &lt;(node a,node b) &#123; if(a.v==b.v) return a.cnt&lt;b.cnt; return a.v&gt;b.v; &#125;&#125;;ll a[MAX];void go()&#123; int t,n,i; ll ans,cnt; node tmp; read(t); while(t--) &#123; read(n); for(i=0;i&lt;n;i++) read(a[i]); ans=0; priority_queue&lt;node&gt; q; for(i=0;i&lt;n;i++) &#123; if(sz(q)) &#123; tmp=q.top(); if(tmp.v&lt;a[i]) &#123; q.pop(); ans+=a[i]-tmp.v; q.push(node(a[i],1)); &#125; &#125; q.push(node(a[i],0)); &#125; cnt=0; while(!q.empty()) &#123; cnt+=(q.top()).cnt; q.pop(); &#125; printf(\"%lld %lld\\n\",ans,cnt*2); &#125;&#125;","path":"2018/08/26/hdu6438/","date":"08-26","excerpt":""},{"title":"hdu 6441 Find Integer (费马大定理)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6441 题意：a^n+b^n=c^n，现在给出n和a，输出一组b，c的正整数解，无解输出-1 -1。 题解：由费马大定理可知，n&gt;2无正整数解。又易知，n=0时也无正整数解。n=1时必有正整数解，任意输出一组可行解即可。n=2时，使用费马大定理的”a值奇偶数列法则”求解。“a值奇偶数列法则”：1.当a为奇数时，b=c-1。2.当a为偶数时，b=c-2。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/void go()&#123; int t; ll n,a,b,c; read(t); while(t--) &#123; read(n,a); if(n&gt;2||n==0) &#123; puts(\"-1 -1\"); continue; &#125; if(n==1) &#123; b=1; c=a+1; printf(\"%lld %lld\\n\",b,c); &#125; else if(n==2) &#123; if(a&amp;1) &#123; b=a*a/2; c=b+1; &#125; else &#123; b=a*a/4-1; c=b+2; &#125; if(b&gt;1000000000||c&gt;1000000000) puts(\"-1 -1\"); else printf(\"%lld %lld\\n\",b,c); &#125; &#125;&#125;","path":"2018/08/26/hdu6441/","date":"08-26","excerpt":""},{"title":"Codeforces edu#49 F. Session in BSU","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1027/F 题意：给n条边，每个点的编号范围[1,1e9]，求一个点集，使每条边至少有一个点在这个点集里，求点集中最大编号最小。不可行输出-1。 题解：对于一个连通块：1.如果没有环，其实就是树，取次大的点。2.如果只有1个环，其实就是基环树，取最大的点。3.如果有2个以上的环，直接输出-1。 先对点离散化，然后用并查集搞搞，判每个连通块有几个环。如果可行，对每个连通块判断是情况1还是情况2，然后取max就是答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e6+10;const ll mod=1e9+7;/********************************* head *********************************/struct dsu&#123; int pre[MAX]; void init(int n) &#123; int i; for(i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; &#125; int find(int x) &#123; if(pre[x]!=x) pre[x]=find(pre[x]); return pre[x]; &#125; int merge(int a,int b) &#123; int ra,rb; ra=find(a); rb=find(b); if(ra!=rb) pre[ra]=rb; if(ra!=rb) return 0; else return ra; &#125;&#125;dsu;int cnt[MAX],v[MAX],belong[MAX];priority_queue&lt;int&gt; q[MAX];void go()&#123; int n,i,a,b,tot,tmp,ans,flag; while(read(n)) &#123; tot=0; hash_map&lt;int,int&gt; mp; dsu.init(2*n); for(i=1;i&lt;=2*n;i++) belong[i]=cnt[i]=0; for(i=1;i&lt;=n;i++) &#123; read(a,b); if(!mp[a]) &#123; mp[a]=++tot; v[tot]=a; &#125; a=mp[a]; if(!mp[b]) &#123; mp[b]=++tot; v[tot]=b; &#125; b=mp[b]; tmp=dsu.merge(a,b); if(tmp) belong[tmp]++; &#125; for(i=1;i&lt;=tot;i++) cnt[dsu.find(i)]+=belong[i]; flag=0; for(i=1;i&lt;=tot;i++) &#123; if(cnt[i]&gt;=2) flag=1; while(!q[i].empty()) q[i].pop(); &#125; if(flag) &#123; puts(\"-1\"); continue; &#125; ans=0; for(i=1;i&lt;=tot;i++) &#123; tmp=dsu.find(i); if(sz(q[tmp])&lt;2) q[tmp].push(-v[i]); else &#123; if(v[i]&gt;-q[tmp].top()) &#123; q[tmp].pop(); q[tmp].push(-v[i]); &#125; &#125; &#125; for(int it=1;it&lt;=tot;it++) &#123; if(sz(q[it])==0) continue; tmp=q[it].top(); q[it].pop(); if(cnt[it]==0) &#123; if(sz(q[it])&gt;=1) ans=max(ans,-tmp); else ans=max(ans,-q[it].top()); &#125; else if(cnt[it]==1) ans=max(ans,-q[it].top()); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/25/cfedu49.F/","date":"08-25","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第九场）G.Longest Common Subsequence (kd-tree)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/147/G 题意：给4个长度为n的数组a,b,c,d，求LCS。数字范围在[1,n]，其中a,b,c中的相同数字不超过2个。 题解：对于每种数字在a,b,c,d中的下标，可以看成一组点(pa,pb,pc,pd)，这样就把LCS转换成了下标的LIS。然后这个是一个四维偏序。我们可以从小到大枚举d数组，这样保证了pd是严格递增的，所以变成三维偏序。因为a,b,c中的相同数字不超过2个，所以点(pa,pb,pc)的个数最多为8n。假设dp[i]表示选第i个点的LIS值，有转移：dp[i]=d[j]+1 其中(pa[j]&lt;pa[i]&amp;&amp;pb[j]&lt;pb[i]&amp;&amp;pb[j]&lt;pb[i])。我们把dp[i]当做点(pa[i],pb[i],pc[i])的值插入kd-tree，然后每次转移从kd-tree里查询即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=8e4+10;const ll mod=1e9+7;/********************************* head *********************************/namespace kd_tree&#123; const double alpha=0.75; const int dim=3; #define type int struct kdtnode &#123; type x[dim],mx[dim],mn[dim],v,sum; int l,r,sz; kdtnode()&#123;&#125; void initval() &#123; sz=1;sum=v; for(int i=0;i&lt;dim;i++) mn[i]=mx[i]=x[i]; &#125; void init(type val)&#123;l=r=0;v=val;initval();&#125; void set(int a,int b,int c,type d=0)&#123;x[0]=a,x[1]=b,x[2]=c;init(d);&#125; kdtnode(int a,int b,int c,type d=0)&#123;set(a,b,c,d);&#125; &#125;; struct KDT &#123; #define ls t[id].l #define rs t[id].r kdtnode t[MAX]; int tot,idx,root; inline void pushup(int id) &#123; t[id].initval(); t[id].sz=t[ls].sz+t[rs].sz+1; if(ls) t[id].sum=max(t[id].sum,t[ls].sum); if(rs) t[id].sum=max(t[id].sum,t[rs].sum); for(int i=0;i&lt;dim;i++) &#123; if(ls) &#123; t[id].mx[i]=max(t[id].mx[i],t[ls].mx[i]); t[id].mn[i]=min(t[id].mn[i],t[ls].mn[i]); &#125; if(rs) &#123; t[id].mx[i]=max(t[id].mx[i],t[rs].mx[i]); t[id].mn[i]=min(t[id].mn[i],t[rs].mn[i]); &#125; &#125; &#125; int st[MAX],top; void build(int &amp;id,int l,int r,int dep=0) &#123; id=0;if(l&gt;r) return; int m=(l+r)&gt;&gt;1; idx=dep; nth_element(st+l,st+m,st+r+1,[&amp;](int x,int y)&#123;return t[x].x[idx]&lt;t[y].x[idx];&#125;); id=st[m]; build(ls,l,m-1,(dep+1)%dim); build(rs,m+1,r,(dep+1)%dim); pushup(id); &#125; inline void init(int n=0) &#123; root=0; t[0].sz=0; for(int i=0;i&lt;dim;i++) &#123; t[0].mx[i]=-INF; t[0].mn[i]=INF; &#125; for(int i=1;i&lt;=n;i++) st[i]=i; if(n) build(root,1,n); tot=n+1; &#125; void travel(int id) &#123; if(!id) return; st[++top]=id; travel(ls); travel(rs); &#125; void rebuild(int &amp;id,int dep) &#123; top=0;travel(id); build(id,1,top,dep); &#125; void insert(int &amp;id,int now,int dep=0) &#123; if(!id)&#123;id=now;return;&#125; idx=dep; if(t[now].x[idx]&lt;t[id].x[idx]) insert(ls,now,(dep+1)%dim); else insert(rs,now,(dep+1)%dim); pushup(id); if(t[id].sz*alpha+3&lt;max(t[ls].sz,t[rs].sz)) rebuild(id,dep); &#125; inline void insert(kdtnode &amp;x)&#123;t[++tot]=x;insert(root,tot);&#125; kdtnode q; inline int check(kdtnode &amp;x) &#123; int ok=1; for(int i=0;i&lt;dim;i++) ok&amp;=(x.x[i]&lt;=q.x[i]); return ok; &#125; inline int allin(kdtnode &amp;x) &#123; int ok=1; for(int i=0;i&lt;dim;i++) ok&amp;=(x.mx[i]&lt;=q.x[i]); return ok; &#125; inline int allout(kdtnode &amp;x) &#123; int ok=0; for(int i=0;i&lt;dim;i++) ok|=(x.mn[i]&gt;q.x[i]); return ok; &#125; type query(int id) &#123; if(!id) return 0; type res=0; if(allin(t[id])) return t[id].sum; if(allout(t[id])) return 0; if(check(t[id])) res=max(res,t[id].v); int l=ls,r=rs; if(t[l].sum&lt;t[r].sum) swap(l,r); if(t[l].sum&gt;res) res=max(res,query(l)); if(t[r].sum&gt;res) res=max(res,query(r)); return res; &#125; inline type query(kdtnode _q)&#123;q=_q;return query(root);&#125; &#125;kd; #undef type #undef ls #undef rs&#125;using namespace kd_tree;VI a[MAX],b[MAX],c[MAX];int d[MAX];void go()&#123; int n,i,x,ans; while(read(n)) &#123; for(i=1;i&lt;=n;i++) &#123; a[i].clear(); b[i].clear(); c[i].clear(); &#125; for(i=1;i&lt;=n;i++) read(x),a[x].pb(i); for(i=1;i&lt;=n;i++) read(x),b[x].pb(i); for(i=1;i&lt;=n;i++) read(x),c[x].pb(i); for(i=1;i&lt;=n;i++) read(d[i]); ans=0; kd.init(); kdtnode tmp; vector&lt;kdtnode&gt; res; for(i=1;i&lt;=n;i++) &#123; res.clear(); for(auto &amp;ai:a[d[i]]) &#123; for(auto &amp;bi:b[d[i]]) &#123; for(auto &amp;ci:c[d[i]]) &#123; tmp.set(ai,bi,ci,kd.query(kdtnode(ai-1,bi-1,ci-1))+1); ans=max(ans,tmp.v); res.pb(tmp); &#125; &#125; &#125; for(auto &amp;it:res) kd.insert(it); &#125; printf(\"%d\\n\",ans); &#125;&#125;","path":"2018/08/17/2018niuke9.G/","date":"08-17","excerpt":""},{"title":"hdu 6406 Taotao Picks Apples (离线+二分+RMQ)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6406 题意：一个数轴上有n个苹果，放在位置1到n。刚开始篮子里没有苹果，一个人从1走到n，如果第i个位置的苹果严格大于篮子里所有苹果，就把那个苹果放进篮子。然后有q个询问，每次询问如果把位置x的苹果替换成大小为y的苹果，那么从1走到n，篮子里会有多少苹果。注意询问的替换不是真正的替换。 题解：因为没有修改(不是真正的替换)，所以离线做。先预处理出一个dp数组。dp[i]表示区间[i,n]的答案。倒着for，从区间[i+1,n]中找出第一个比v[i]大的数的位置转移过来，不存在的话dp[i]=1。对询问按x从小到大排序，然后扫过去。对于查询的一个位置x：区间[1,x-1]的最大值记为mx。1.对于区间[1,x-1]的答案是确定，记为now。2.考虑x这个位置修改后的数字val：(1)如果val大于mx，那么ans=now+1+dp[pos]。pos为区间[x+1,n]中第一个比val大的数的位置。(2)如果val小于等于mx，那么ans=now+dp[pos]。pos为区间[x+1,n]中第一个比mx大的数的位置。 至于怎么找区间中第一个比x大的数的位置，我们可以预处理一下RMQ，然后二分区间，查询区间最大值调整二分边界。 总复杂度是O(nlogn+qlogn)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=998244353;/********************************* head *********************************/int v[MAX],maxx[MAX][20];void RMQ(int n)&#123; int i,j; for(i=1;i&lt;=n;i++) &#123; maxx[i][0]=v[i]; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) maxx[i][j]=0; &#125; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int t=1&lt;&lt;(j-1); maxx[i][j]=max(maxx[i][j-1],maxx[i+t][j-1]); &#125; &#125;&#125;int query(int l,int r)&#123; int j=(int)(log10(r-l+1)/log10(2))+1; int i=r-(1&lt;&lt;(j-1))+1; return max(maxx[l][j-1],maxx[i][j-1]);&#125;struct node&#123; int x,v,id; void input(int i) &#123; read(x,v); id=i; &#125; friend bool operator&lt;(node a,node b)&#123;return a.x&lt;b.x;&#125;&#125;qs[MAX];int ans[MAX],dp[MAX];void go()&#123; int t,i,j,n,q,now,mx,pos; read(t); while(t--) &#123; read(n,q); for(i=1;i&lt;=n;i++) read(v[i]); RMQ(n); auto getpos=[&amp;](int _l,int _r,int v)-&gt;int &#123; int l,r,mid; l=_l; r=_r; if(l&gt;r) return -1; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; if(query(l,mid)&lt;=v) l=mid+1; else r=mid; &#125; if(query(l,l)&lt;=v) return -1; return l; &#125;; dp[n]=1; for(i=n-1;i;i--) &#123; pos=getpos(i+1,n,v[i]); if(pos!=-1) dp[i]=dp[pos]+1; else dp[i]=1; &#125; for(i=1;i&lt;=q;i++) qs[i].input(i); sort(qs+1,qs+1+q); now=0; mx=-1; for(i=1,j=1;i&lt;=q;i++) &#123; while(j&lt;qs[i].x) &#123; if(v[j]&gt;mx) &#123; mx=v[j]; now++; &#125; j++; &#125; ans[qs[i].id]=now; if(qs[i].v&gt;mx) &#123; pos=getpos(j+1,n,qs[i].v); ans[qs[i].id]++; &#125; else pos=getpos(j+1,n,mx); if(pos!=-1) ans[qs[i].id]+=dp[pos]; &#125; for(i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); &#125;&#125;","path":"2018/08/16/hdu6406/","date":"08-16","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第九场）A.Circulant Matrix (FWT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/147/A 题意： 题解：观察样例感觉是个卷积，然后发现是个xor的FWT。题意转换成，给个a数组和c数组，求一个b数组，使得a数组和b数组做FWT后的结果为c数组。然后观察FWT的过程：对a，b数组做FWT，c[i]=a[i]*b[i]，然后对c数组做UFWT。我们把这个过程倒过来：先对c数组做UFWT，然后对a数组做FWT，然后b[i]=c[i]/a[i]，最后对b数组做FWT，就把b数组还原了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=6e5+10;const ll mod=1e9+7;/********************************* head *********************************/namespace FWT&#123; ll inv2; const ll p=1e9+7; ll pow2(ll a,ll b) &#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res; &#125; void fwt(ll *a,int n,int v) &#123; for(int d=1;d&lt;n;d&lt;&lt;=1) &#123; for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m) &#123; for(int j=0;j&lt;d;j++) &#123; ll x=a[i+j],y=a[i+j+d]; if(!v) a[i+j]=(x+y)%p,a[i+j+d]=(x-y+p)%p; else a[i+j]=(x+y)*inv2%p,a[i+j+d]=(x-y+p)%p*inv2%p; &#125; &#125; &#125; &#125; void XOR(ll *a,ll *b,int n) &#123; int len; for(len=1;len&lt;=n;len&lt;&lt;=1); fwt(a,len,0); fwt(b,len,0); for(int i=0;i&lt;len;i++) a[i]=a[i]*b[i]%p; inv2=pow2(2,p-2); fwt(a,len,1); &#125; void XOR_inv(ll *a,ll *b,int n) &#123; int len; for(len=1;len&lt;=n;len&lt;&lt;=1); inv2=pow2(2,p-2); fwt(a,len,1); fwt(b,len,0); for(int i=0;i&lt;len;i++) a[i]=a[i]*pow2(b[i]%p,p-2)%p; fwt(a,len,0); &#125;&#125;;ll a[MAX],b[MAX];void go()&#123; int n,i; while(read(n)) &#123; for(i=0;i&lt;n;i++) read(b[i]); for(i=0;i&lt;n;i++) read(a[i]); FWT::XOR_inv(a,b,n); for(i=0;i&lt;n;i++) printf(\"%lld\\n\",a[i]); &#125;&#125;","path":"2018/08/16/2018niuke9.A/","date":"08-16","excerpt":""},{"title":"hdu 6393 Traffic Network in Numazu (基环树+树链剖分)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6393 题意：给一个n个点，n条边的联通图，边有边权。有两个操作：操作0：修改一条边的边权。操作1：查询节点a到节点b的最短路。 题解：n个点n条边的连通图，可知给的图是一棵基环树。所以做法就是先断开一条环边，变成一棵树，然后做树剖，因为单点修改，用个bit维护。判断是不是环边可以用并查集。假设断开的边为x，y，边权为v。分三类讨论：1.树链a到b2.树链a到x+树链y到b+v3.树链a到y+树链x到b+v可能会有两类是重复的，为了方便就直接分三类。那么答案就是这三类取min。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct dsu&#123; int pre[MAX]; void init(int n) &#123; int i; for(i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; &#125; int find(int x) &#123; if(pre[x]!=x) pre[x]=find(pre[x]); return pre[x]; &#125; int merge(int a,int b) &#123; int ra,rb; ra=find(a); rb=find(b); if(ra!=rb) pre[ra]=rb; return ra!=rb; &#125;&#125;dsu; struct Fenwick_Tree&#123; #define type ll type bit[MAX]; int n; void init(int _n)&#123;n=_n;mem(bit,0);&#125; int lowbit(int x)&#123;return x&amp;(-x);&#125; void insert(int x,type v) &#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125; &#125; type get(int x) &#123; type res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res; &#125; type query(int l,int r) &#123; return get(r)-get(l-1); &#125; #undef type&#125;tr;struct HLD&#123; #define type ll struct edge&#123;int a,b;type v;edge(int _a,int _b,type _v=0):a(_a),b(_b),v(_v)&#123;&#125;&#125;; vector&lt;int&gt; mp[MAX]; vector&lt;edge&gt; e; int deep[MAX],fa[MAX],size[MAX],son[MAX]; int rnk[MAX],top[MAX],idx[MAX],tot; int n,rt; void init(int _n) &#123; n=_n; for(int i=1;i&lt;=n;i++) mp[i].clear(); e.clear(); e.pb(edge(0,0)); &#125; void add_edge(int a,int b,type v=0) &#123; e.pb(edge(a,b,v)); if(a==-1||b==-1) return; mp[a].pb(b); mp[b].pb(a); &#125; void dfs1(int x,int pre,int h) &#123; int i,to; deep[x]=h; fa[x]=pre; size[x]=1; for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to==pre) continue; dfs1(to,x,h+1); size[x]+=size[to]; if(son[x]==-1||size[to]&gt;size[son[x]]) son[x]=to; &#125; &#125; void dfs2(int x,int tp) &#123; int i,to; top[x]=tp; idx[x]=++tot; rnk[idx[x]]=x; if(son[x]==-1) return; dfs2(son[x],tp); for(i=0;i&lt;sz(mp[x]);i++) &#123; to=mp[x][i]; if(to!=son[x]&amp;&amp;to!=fa[x]) dfs2(to,to); &#125; &#125; void work(int _rt) &#123; int i; rt=_rt; mem(son,-1); tot=0; dfs1(rt,0,0); dfs2(rt,rt); &#125; //path void init_path() &#123; for(int i=1;i&lt;=n;i++) &#123; if(e[i].a==-1) continue; if(deep[e[i].a]&lt;deep[e[i].b]) swap(e[i].a,e[i].b); tr.insert(idx[e[i].a],e[i].v); &#125; &#125; void update(int x,type val) &#123; tr.insert(x,-tr.query(x,x)+val); &#125; void modify_edge(int id,type val) &#123; if(deep[e[id].a]&gt;deep[e[id].b]) update(idx[e[id].a],val); else update(idx[e[id].b],val); &#125; type query_path(int x,int y) &#123; type res=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); res+=tr.query(idx[top[x]],idx[x]); x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); if(x!=y) res+=tr.query(idx[x]+1,idx[y]); return res; &#125; #undef type&#125;hld; //hld.init(n)void go()&#123; int t,n,q,i,op,a,b,c; ll ans; int x,y,v,id; read(t); while(t--) &#123; read(n,q); hld.init(n); tr.init(n); dsu.init(n); for(i=1;i&lt;=n;i++) &#123; read(a,b,c); if(!dsu.merge(a,b)) &#123; id=i; x=a; y=b; v=c; hld.add_edge(-1,-1,-1); &#125; else hld.add_edge(a,b,c); &#125; hld.work(1); hld.init_path(); while(q--) &#123; read(op,a,b); if(op==0) &#123; if(a==id) v=b; else hld.modify_edge(a,b); &#125; else &#123; ans=LLINF; ans=min(ans,hld.query_path(a,b)); ans=min(ans,hld.query_path(a,x)+hld.query_path(y,b)+v); ans=min(ans,hld.query_path(a,y)+hld.query_path(x,b)+v); printf(\"%lld\\n\",ans); &#125; &#125; &#125;&#125;","path":"2018/08/14/hdu6393/","date":"08-14","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第六场）I.Team Rocket(STL)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/144/I 题意：给n个列车和m个爆破点。每个列车有一个运行区间[L,R]。刚开始，所有列车都在运行。每次爆破一个点后输出有多少运行中的列车因为这次爆破而停止运行。然后那些列车就停止运行了。最后输出每个列车是因为第几次爆破而停止运行的。爆破点是加密的，所以强制在线。 题解：先把L从小到大离散化一下，然后开2e5个set存每个R和列车的id，注意R是要求从大到小存。然后每次爆破，暴力遍历每个set，遇到满足的就记录，并从set里删除，遇到第一个不满足的就break。但是这样每次可能会遍历2e5次。所以用一个双向链表维护，遍历的时候跳掉那些size等于0的set。 *赛后想了想，这种做法还是能被卡成n^2，所以仅供参考… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;/********************************* head *********************************/struct node&#123; int fi,se; node()&#123;&#125; node(int l,int r) :fi(l),se(r)&#123;&#125; friend bool operator&lt;(node a,node b) &#123; if(a.fi==b.fi) return a.se&lt;b.se; return a.fi&gt;b.fi; &#125; friend bool operator!=(node a,node b) &#123; return a.fi!=b.fi||a.se!=b.se; &#125;&#125;;set&lt;node&gt; mp[MAX];PII a[MAX];int res[MAX],nex[MAX],p[MAX];void go()&#123; int t,n,m,i,ans,x,tot,time,cas=1; node tmp; ll pre,now; read(t); while(t--) &#123; unordered_map&lt;int,int&gt; id; VI xx; read(n,m); for(i=1;i&lt;=n;i++) &#123; read(a[i].fi,a[i].se); xx.pb(a[i].fi); res[i]=0; nex[i]=i+1; p[i]=i-1; &#125; sort(all(xx)); xx.resize(unique(all(xx))-xx.begin()); for(i=0;i&lt;sz(xx);i++) id[xx[i]]=i+1; tot=sz(xx); for(i=1;i&lt;=tot;i++) mp[i].clear(); for(i=1;i&lt;=n;i++) mp[id[a[i].fi]].insert(node(a[i].se,i)); pre=0; printf(\"Case #%d:\\n\",cas++); for(time=1;time&lt;=m;time++) &#123; read(x); x=(x^pre); ans=0; now=1; for(i=1;i&lt;=tot;i=nex[i]) &#123; if(xx[i-1]&gt;x) break; tmp=node(-INF,-INF); for(auto &amp;it:mp[i]) &#123; if(tmp!=node(-INF,-INF)) mp[i].erase(tmp); if(it.fi&lt;x) break; ans++; res[it.se]=time; now=now*it.se%mod; tmp=it; &#125; if(tmp!=node(-INF,-INF)) mp[i].erase(tmp); if(sz(mp[i])==0) &#123; nex[p[i]]=nex[i]; p[nex[i]]=p[i]; &#125; &#125; if(now==1&amp;&amp;res[1]!=time) now=0; pre=now; printf(\"%d\\n\",ans); &#125; for(i=1;i&lt;=n;i++) printf(\"%d%c\",res[i],\" \\n\"[i==n]); &#125;&#125;","path":"2018/08/04/2018niuke6.I/","date":"08-04","excerpt":""},{"title":"hdu 6336 Problem E. Matrix from Arrays (二维前缀和)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6336 题意：给一个构造矩阵的代码，给一个长度为L的数组A，构造出一个无限大的矩阵，然后每次查询子矩阵的和。 题解：把矩阵构造出来后，观察发现，行和列的循环节都是2L(其实L为奇数的时候，循环节是L，为了方便这里统一为2L)，所以矩阵的循环节为2L*2L。 下图是L=4，A[]={1,2,3,4}的矩阵的一部分。红色矩阵都是一样的。假设我们要求蓝色矩阵的和。蓝色矩阵的和=6个1号矩阵+3个2号矩阵+2个3号矩阵+1个4号矩阵。 所以做法就是预处理一下2L*2L矩阵的二维前缀和。然后每次这么算一下就行了，结合图和代码理解一下。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;void go();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif go();return 0;&#125;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/void go()&#123; ll mp[111][111],i,j,a[22],L,t,q,x1,y1,x2,y2,now; read(t); while(t--) &#123; read(L); for(i=0;i&lt;L;i++) read(a[i]); now=0; for(i=0;i&lt;4*L;i++) &#123; for(j=0;j&lt;=i;j++) &#123; mp[j][i-j]=a[now++]; now%=L; &#125; &#125; L*=2; for(i=0;i&lt;L;i++) &#123; for(j=0;j&lt;L;j++) &#123; if(i) mp[i][j]+=mp[i-1][j]; if(j) mp[i][j]+=mp[i][j-1]; if(i&amp;&amp;j) mp[i][j]-=mp[i-1][j-1]; &#125; &#125; read(q); while(q--) &#123; read(x1,y1,x2,y2); auto gao=[&amp;](ll x,ll y) &#123; if(x&lt;0||y&lt;0) return 0LL; return mp[L-1][L-1]*(x/L)*(y/L) +mp[x%L][L-1]*(y/L) +mp[L-1][y%L]*(x/L) +mp[x%L][y%L]; &#125;; println(gao(x2,y2)-gao(x1-1,y2)-gao(x2,y1-1)+gao(x1-1,y1-1)); &#125; &#125;&#125;","path":"2018/08/01/hdu6336/","date":"08-01","excerpt":""},{"title":"容斥的原理及广义应用","text":"原文：https://blog.csdn.net/werkeytom_ftd/article/details/74701513","path":"2018/07/28/rongchi/","date":"07-28","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第三场）I.Expected Size of Random Convex Hull (随机+打表)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/141/I 题意：给一个三角形，让你在三角形内随机选n个点，问这n个点在凸包上的期望是多少。 题解：显然三角形长什么样，对答案没有影响。注意到n&lt;=10，所以做法就是：在三角形内随机n个点，求凸包，然后求多少个点在凸包上。随机次数越多，答案是准确率越高。最后打个表交上去就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;/********************************* head *********************************/int sgn(double x)&#123; if(fabs(x)&lt;eps) return 0; else return x&gt;0?1:-1; &#125;struct Point&#123; double x,y; Point()&#123;&#125; Point(double a,double b) &#123; x=a; y=b; &#125; void input() &#123; scanf(\"%lf%lf\",&amp;x,&amp;y); &#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,double p)&#123;return Vector(a.x*p,a.y*p);&#125; Vector operator /(Vector a,double p)&#123;return Vector(a.x/p,a.y/p);&#125;bool operator &lt;(Point a,Point b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;bool operator ==(Point a,Point b)&#123;return sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0;&#125;double cross(Vector a,Vector b)&#123;return a.x*b.y-a.y*b.x;&#125;vector&lt;Point&gt; graham(vector&lt;Point&gt; p)&#123; int n,m,k,i; sort(p.begin(),p.end()); p.erase(unique(p.begin(),p.end()),p.end()); n=p.size(); m=0; vector&lt;Point&gt; res(n+1); for(i=0;i&lt;n;i++) &#123; while(m&gt;1&amp;&amp;cross(res[m-1]-res[m-2],p[i]-res[m-2])&lt;=0) m--; res[m++]=p[i]; &#125; k=m; for(i=n-2;i&gt;=0;i--) &#123; while(m&gt;k&amp;&amp;cross(res[m-1]-res[m-2],p[i]-res[m-2])&lt;=0) m--; res[m++]=p[i]; &#125; if(n&gt;1) m--; res.resize(m); return res;&#125;Point randp()&#123; while(1) &#123; Point p(rand(),rand()); if(p.x+p.y&lt;=32766) return p; &#125; return Point(0,0);&#125;void gao()&#123; srand(time(0)); for(int i=4;i&lt;=10;i++) &#123; int t=20000000; double ans=0; while(t--) &#123; vector&lt;Point&gt; p; for(int j=0;j&lt;i;j++) p.pb(randp()); p=graham(p); ans+=sz(p); &#125; ans/=20000000; printf(\"%.6f,\",ans); &#125; puts(\"\");&#125;int main()&#123;// gao(); double ans[]=&#123;0,0,0,3,3.666724,4.166653,4.566743,4.900092,5.185803,5.435999,5.658361&#125;; int n,i; Point p; for(i=0;i&lt;3;i++) p.input(); scanf(\"%d\",&amp;n); printf(\"%.4f\\n\",ans[n]); return 0;&#125;","path":"2018/07/27/2018niuke3.I/","date":"07-27","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第三场）E.Sort String (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/141/E 题意：给一个字符串，复制前n-1个字符后，问有多少种长度n的子串，分类后按字典序输出下标。 题解：复制一遍字符串，然后预处理hash表。之后for每个起始位置，可以在O(1)的时间获取子串的hash值，然后扔进map分类即可。对于这种写法字典序不需要特殊处理。这个题卡常…有两个点要注意一下。1.mod取1e9+7会冲突(过了62.5%的数据)，而且每次%常数很大，会tle，这里选用了ull(自动%2^64)。2.要用unordered_map，不然会tle。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e6+10;const ll mod=1e9+7;/********************************* head *********************************/struct hash_table&#123; ull seed; ull Hash[MAX],tmp[MAX]; void set(ull _seed) &#123; seed=_seed; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; Hash[0]=0; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed; for(i=1;i&lt;=n;i++) Hash[i]=(Hash[i-1]*seed+(s[i]-'a')); &#125; ull get(int l,int r) &#123; return (Hash[r]-Hash[l-1]*tmp[r-l+1]); &#125;&#125;h;char s[MAX];VI res[MAX];int main()&#123; int i,j,len,tot; while(~scanf(\"%s\",s+1)) &#123; len=strlen(s+1); for(i=len+1,j=1;j&lt;=len;i++,j++) s[i]=s[j]; for(i=1;i&lt;=len;i++) res[i].clear(); h.set(23333); h.work(s,len*2); unordered_map&lt;ull,int&gt; mp; tot=0; for(i=1;i&lt;=len;i++) &#123; ull tmp=h.get(i,i+len-1); if(!mp.count(tmp)) mp[tmp]=++tot; res[mp[tmp]].pb(i-1); &#125; printf(\"%d\\n\",tot); for(i=1;i&lt;=tot;i++) &#123; printf(\"%d\",sz(res[i])); for(auto it:res[i]) printf(\" %d\",it); puts(\"\"); &#125; &#125; return 0;&#125;","path":"2018/07/26/2018niuke3.E/","date":"07-26","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）B.discount (基环树dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/B 题意：有n种饮料，你可以选择一下两种优惠策略1、打折购买，花费为p[x]-d[x]2、原价购买，但是会赠送给你一瓶类型为f[x]的饮料问你获得全部种类的饮料的最小花费为多少 题解(solved by winterzz1)：根据题意，可以建立从购买饮料到赠送饮料的有向边。建出的图每一个联通块都是一颗树多一条边。先预处理，枚举每一条边，如果两端点u,v还不在同一个联通块中，就把起点u与终点v用并查集并起来。否则记u为root，v为对应的ex节点，同时删去这条边，将图改造为树。例如 加入的边为5 12 52 42 36 76 2 那么在最后加入6-&gt;2这条边时，由于2,6已经属于同一个联通块，就记6为root，2为对应的ex节点。 因为整个图可能是不连通的，所以可能会产生多个root节点和对应的ex节点。 这样做完以后原图就被改造成了由多个树组成的森林。 先简化题目，不考虑root节点对ex节点的影响。 那么就是树形dp。dp数组两个维度dp[x][0]表示第x节点赠送父节点的最优解，dp[x][1]表示第x节点不赠送父节点的最优解。 dp[x][0]=min(p[x]-d[x]+Σdp[ch][0],dp[k][1]-dp[k][0]+ Σdp[ch][0])k∈ch。 对于dp[x][1]直接做一步贪心，因为赠送父节点就必须原价购买，而原价购买的价格一定高于其他情况。 dp[x][1]= p[x]+ Σdp[ch][0]。 现在考虑root节点对ex节点的影响，再扩个维度dp[x][k][0]表示root节点没有提供ex节点的饮料，dp[x][k][1]表示root节点提供了ex节点的饮料。 显然第三个维度仅仅对当前节点为ex节点时才有影响，否则这个维度无用。 那么如果当前节点不是ex节点，按照二维直接做，0转移到0,1转移到1即可。 即：dp[x][0][0]=min(p[x]-d[x]+Σdp[ch][0][0],dp[k][1][0]-dp[k][0][0]+ Σdp[ch][0][0])k∈ch。 dp[x][0][1]=min(p[x]-d[x]+Σdp[ch][0][1],dp[k][1][1]-dp[k][0][1]+ Σdp[ch][0][1])k∈ch。 如果当前节点为ex节点，需要特殊转移。dp[ex][0][0]=min(p[root]-d[root]+ Σdp[ch][0][0] dp[k][1][0]-dp[k][0][0]+ Σdp[ch][0][0]) k∈ch。 dp[ex][0][1]= Σdp[ch][0][1]（贪心，如果根节点提供ex节点的饮料，就不需要子树再提供） dp[ex][1][0]= Σdp[ch][0][0]+p[root]dp[ex][1][1]= Σdp[ch][0][1]+p[root] 注意转移到最后dp[root][0][1]和dp[root][1][0]是自相矛盾的非法状态，合法的只有dp[root][0][0]和dp[root][1][1]，所以答案为min(dp[root][0][0], dp[root][1][1])。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;int fa[MAXN],f[MAXN],root[MAXN],ex[MAXN],tot,n;long long ans,p[MAXN],d[MAXN],dp[MAXN][2][2];vector&lt;int&gt; G[MAXN];int findf(int x)&#123; if(x==fa[x])return x; return fa[x]=findf(fa[x]);&#125;void unions(int x,int y)&#123; if(findf(x)!=findf(y)) &#123; fa[findf(x)]=findf(y); &#125; return;&#125;void dp_dfs(int root,int ex)&#123; long long sum00=0; long long sum01=0; for(int i=0;i&lt;G[root].size();++i) &#123; dp_dfs(G[root][i],ex); sum00+=dp[G[root][i]][0][0]; sum01+=dp[G[root][i]][0][1]; &#125; if(root==ex) &#123; dp[root][0][0]=sum00+p[root]-d[root]; dp[root][0][1]=sum01; dp[root][1][0]=sum00+p[root]; dp[root][1][1]=sum01+p[root]; for(int i=0;i&lt;G[root].size();++i) &#123; dp[root][0][0]=min(dp[root][0][0],sum00-dp[G[root][i]][0][0]+dp[G[root][i]][1][0]); &#125; &#125; else &#123; dp[root][0][0]=sum00+p[root]-d[root]; dp[root][0][1]=sum01+p[root]-d[root]; dp[root][1][0]=sum00+p[root]; dp[root][1][1]=sum01+p[root]; for(int i=0;i&lt;G[root].size();++i) &#123; dp[root][0][0]=min(dp[root][0][0],sum00-dp[G[root][i]][0][0]+dp[G[root][i]][1][0]); dp[root][0][1]=min(dp[root][0][1],sum01-dp[G[root][i]][0][1]+dp[G[root][i]][1][1]); &#125; &#125; return;&#125;int main()&#123; while(scanf(\"%d\",&amp;n)!=EOF) &#123; ans=0; tot=0; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;p[i]); dp[i][0][0]=dp[i][0][1]=dp[i][1][0]=dp[i][1][1]=0; G[i].clear(); fa[i]=i; &#125; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;d[i]); &#125; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;f[i]); if(findf(i)!=findf(f[i])) &#123; G[f[i]].push_back(i); unions(f[i],i); &#125; else &#123; root[++tot]=i; ex[tot]=f[i]; &#125; &#125; for(int i=1;i&lt;=tot;++i) &#123; dp_dfs(root[i],ex[i]); ans+=min(dp[root[i]][0][0],dp[root[i]][1][1]); &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/24/2018niuke2.B/","date":"07-24","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）H.travel (树形dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/H 题意：给一棵树，在树上选3条不相交的树链，使点权和最大。 题解：对于dp数组：dp[x][y][k]表示在节点x，x节点的类型是y，现在已经选了k条链。其中：关于y，y的取值是[0,2]。0：表示节点x不选。或者选了节点x后，选择包括节点x的这条链。1：表示节点x是一条链的端点。即长这样： 2：表示节点x是一条链的拐点。即长这样： 关于k，k的取值是[0,3]。表示现在已选了0,1,2,3条树链。 那么答案就是dp[1][0][3]。 对于转移：关于k的转移，很显然，k=i+j，枚举k和i，求出j，直接转移就行了。 关于y的转移，我们要分类讨论。考虑y=2时，有两种转移。第一种：变为dp[x][2][k]=max(dp[x][2][k],dp[x][1][i]+dp[to][1][j])注意到dp[x][2][k]要从dp[x][1][i]转移过来，所以要先转移y=2，再转移y=1，不然会重复转移。 第二种就是本身已经是拐点了，然后把子节点已选的树链给加上来。dp[x][2][k]=max(dp[x][2][k],dp[x][2][i]+dp[to][0][j])注意到dp[x][2][k]要从dp[x][2][i]转移过来，所以k和i要从大到小枚举，不然会重复转移。 然后考虑y=1时，有两种转移。 第一种也是本身已经是端点了，然后把子节点已选的树链给加上来。dp[x][1][k]=max(dp[x][1][k],dp[x][1][i]+dp[to][0][j])同样注意到dp[x][1][k]要从dp[x][1][i]转移过来，所以k和i也要从大到小枚举，不然会重复转移。 第二种是子节点是端点，然后接上自己，自己还是端点。长这样：变成dp[x][1][k]=max(dp[x][1][k],dp[x][0][i]+dp[to][1][j]+v[x])注意到dp[x][1][k]要从dp[x][0][i]转移过来，所以要先转移y=1，再转移y=0，不然会重复转移。 然后考虑y=0时，有三种转移。 第一种是最基本的，就不用解释了。dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][0][j])同样注意到dp[x][0][k]要从dp[x][0][i]转移过来，所以k和i也要从大到小枚举，不然会重复转移。 第二种和第三种其实可以算一种。如果子节点是端点或者是拐点，我们选它，算作一条链。if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][2][j-1])if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][1][j-1]) 最后，我们把自己是端点或者是拐点，整合算作一条链，更新一下。dp[x][0][k]=max(dp[x][0][k],dp[x][1][k-1])dp[x][0][k]=max(dp[x][0][k],dp[x][2][k-1]) 大概这个题就这样，具体自己理解一下。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=4e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll dp[MAX][3][4],v[MAX];VI mp[MAX];void dfs(int x,int fa)&#123; int i,j,k; dp[x][1][0]=v[x]; for(auto to:mp[x]) &#123; if(to==fa) continue; dfs(to,x); for(k=2;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][2][k]=max(dp[x][2][k],dp[x][1][i]+dp[to][1][j]); dp[x][2][k]=max(dp[x][2][k],dp[x][2][i]+dp[to][0][j]); &#125; &#125; for(k=2;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][1][k]=max(dp[x][1][k],dp[x][1][i]+dp[to][0][j]); dp[x][1][k]=max(dp[x][1][k],dp[x][0][i]+dp[to][1][j]+v[x]); &#125; &#125; for(k=3;~k;k--) &#123; for(i=k;~i;i--) &#123; j=k-i; dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][0][j]); if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][2][j-1]); if(j) dp[x][0][k]=max(dp[x][0][k],dp[x][0][i]+dp[to][1][j-1]); &#125; &#125; &#125; for(k=1;k&lt;=3;k++) &#123; dp[x][0][k]=max(dp[x][0][k],dp[x][1][k-1]); dp[x][0][k]=max(dp[x][0][k],dp[x][2][k-1]); &#125;&#125;int main()&#123; int n,i,j,a,b; while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) &#123; mp[i].clear(); mem(dp[i],0); scanf(\"%lld\",&amp;v[i]); &#125; for(i=1;i&lt;n;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; dfs(1,-1); printf(\"%lld\\n\",dp[1][0][3]); &#125; return 0;&#125;","path":"2018/07/24/2018niuke2.H/","date":"07-24","excerpt":""},{"title":"hdu 6305 RMQ Similar Sequence(下标RMQ+分治)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6305 题意：给一个长度为n的序列A。有一个长度为n的序列B，B的每个元素都是在[0,1]内随机的实数。定义RMQ(A,l,r)为在A数组区间[l,r]内最大的那个元素的最小下标。求满足1≤l≤r≤n,RMQ(A,l,r)=RMQ(B,l,r)的所有B数组的$\\sum_{i=1}^n{b_i}$的期望。 题解：1.考虑到B中有元素相同的概率是0(因为是实数)，于是可以假设B里面元素互不相同，也就是说可以假定是一个排列。2.[0,1]内随机一个实数的期望是0.5，那么一个排列(n个数)的期望就是n/2。3.问题转换成：B为n的一个全排列，求满足1≤l≤r≤n,RMQ(A,l,r)=RMQ(B,l,r)的B数组的方案数，记为res。那么ans=(res/n!)*n/2。 所以现在的问题就是，怎么求满足条件的方案数。这个条件其实就是要满足B数组的大小关系跟A数组的一致。那么做法就是：用下标RMQ，然后分治。每次找RMQ(A,l,r)，记为pos。分配给B[pos]数组持有的数的最大值，因为如果B[pos]为最大值，那么RMQ(B,l,r)也一定返回pos。然后把剩下的数分配给区间[l,pos-1]和[pos+1,r]，那我们在剩下的数中选pos-l个数，分配给[l,pos-1]，剩下的数就分配给[pos+1,r]。所以分配的方案数就是C(r-l，pos-l)。连乘起来就是res。然后带入那个公式就是答案。 另外注意，需要贴读入挂。还有g++会爆栈，c++扩栈但是贴读入挂也是tle，所以要手写用栈模拟dfs。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e6+10;const ll mod=1e9+7;/**************************************** head ****************************************/struct FastIO &#123; static const int S=200; int wpos; char wbuf[S]; FastIO():wpos(0)&#123;&#125; inline int xchar() &#123; static char buf[S]; static int len=0,pos=0; if(pos==len) pos=0,len=fread(buf,1,S,stdin); if(pos==len) exit(0); return buf[pos++]; &#125; inline int read() &#123; int s=1,c=xchar(),x=0; while(c&lt;=32) c=xchar(); if(c=='-') s=-1,c=xchar(); for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=xchar()) x=x*10+c-'0'; return x*s; &#125; ~FastIO() &#123; if(wpos) fwrite(wbuf,1,wpos,stdout),wpos=0; &#125; &#125;io;int v[MAX],maxx[MAX][22];int pmax(int a,int b)&#123; if(v[a]==v[b]) return min(a,b); return v[a]&gt;v[b]?a:b;&#125;void RMQ(int n)&#123; int i,j; for(i=1;i&lt;=n;i++) &#123; maxx[i][0]=i; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; maxx[i][j]=0; &#125; &#125; for(j=1;1&lt;&lt;(j-1)&lt;=n;j++) &#123; for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) &#123; int t=1&lt;&lt;(j-1); maxx[i][j]=pmax(maxx[i][j-1],maxx[i+t][j-1]); &#125; &#125;&#125;int query(int l,int r)&#123; int j=(int)(log10(r-l+1)/log10(2))+1; int i=r-(1&lt;&lt;(j-1))+1; return pmax(maxx[l][j-1],maxx[i][j-1]);&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll fac[MAX],invfac[MAX];void init(int n)&#123; ll i; fac[0]=invfac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; invfac[i]=inv(fac[i]); &#125;&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*invfac[m]%mod*invfac[n-m]%mod;&#125;namespace DFS&#123; struct node&#123;int l,r;&#125;; int top; node st[MAX]; ll dfs(int mn,int mx) &#123; ll res=1; int l,r; l=mn; r=mx; top=0; st[top].l=l; st[top++].r=r; while(top) &#123; l=st[top-1].l; r=st[--top].r; if(l&gt;=r) continue; int pos=query(l,r); res=res*C(r-l,pos-l)%mod; st[top].l=l; st[top++].r=pos-1; st[top].l=pos+1; st[top++].r=r; &#125; return res; &#125;&#125;ll dfs(int l,int r)&#123; if(l&gt;=r) return 1LL; int pos=query(l,r); return dfs(l,pos-1)*dfs(pos+1,r)%mod*C(r-l,pos-l)%mod;&#125;int main()&#123; int n,t,i;// scanf(\"%d\",&amp;t); t=io.read(); init(MAX-10); ll ans; while(t--) &#123;// scanf(\"%d\",&amp;n); n=io.read(); for(i=1;i&lt;=n;i++) v[i]=io.read();//scanf(\"%d\",&amp;v[i]); RMQ(n); ans=DFS::dfs(1,n)*invfac[n]%mod*n%mod*inv(2)%mod; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/23/hdu6305/","date":"07-23","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）E.Removal (dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/E 题意：长度为n的序列，删掉m个数字后有多少种不同的序列。n&lt;=10^5，m&lt;=10。 题解：dp[i][j]表示加入第i个数字后，总共删掉j个数字时，有多少种不同的序列。假设不考虑有重复的情况，dp方程为：dp[i][j]=dp[i-1][j] (第i个数字不删)+dp[i-1][j-1] (第i个数字删)。现在考虑重复的情况。如果前面有与a[i]相同的数字a[k] (k小于i)，并且i-k&lt;=j，就会产生重复。比如：cdeaae(用字符串举例比较方便)当我们i=6,j=3时,a[3]=a[6],那么如果删掉中间的[eaa]字串就会变成[cde]，因为我们已经在前面i=3时算过了一次[cde]这种情况，所以我们需要dp[6][3]-dp[2][0]。那么为什么不是减掉dp[3][0]而是减掉dp[2][0]呢。举个比较好说明的例子。还是上面那个串，假设现在是i=6,j=4。那么我们需要dp[6][4]-dp[2][1]。那么为什么不是减掉dp[3][1]呢。因为dp[3][1]=dp[2][1]+dp[2][0]，也就是说dp[3][1]还包括了删掉a[3]的状态，而如果删掉a[3]，那么加入a[6]的时候就不会有重复了。所以减掉dp[2][1]，就是减掉了a[3]不删除的情况。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll dp[MAX][12];int last[12],pre[MAX],a[MAX];int main()&#123; int n,m,k,i,j; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k)) &#123; for(i=1;i&lt;=k;i++) last[i]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); pre[i]=last[a[i]]; last[a[i]]=i; &#125; for(i=0;i&lt;=m;i++) dp[i][i]=1; for(i=1;i&lt;=n;i++) &#123; dp[i][0]=1; for(j=1;j&lt;=min(i-1,m);j++) &#123; dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod; if(pre[i]&amp;&amp;i-pre[i]&lt;=j) &#123; dp[i][j]-=dp[pre[i]-1][j-(i-pre[i])]; dp[i][j]%=mod; dp[i][j]=(dp[i][j]+mod)%mod; &#125; &#125; &#125; printf(\"%lld\\n\",dp[n][m]); &#125; return 0;&#125;/*6 4 53 4 5 1 1 5*/","path":"2018/07/22/2018niuke1.E/","date":"07-22","excerpt":""},{"title":"AtCoder Grand Contest 026 C.String Coloring (折半搜索)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://agc026.contest.atcoder.jp/tasks/agc026_c 题意：给一个长度为2*n的字符串。每个字符可以选择涂成红色或者蓝色。从左往右涂成红色的字符组成一个字符串，记为a。从右往左涂成蓝色的字符组成一个字符串，记为b。求a==b的方案数。 题解：n最大只有18，显然是折半搜索。枚举前半段字符串，将方案用map存。枚举后半段字符串(这里把字符串反转一下，就又变成枚举前半段字符串了)，用map更新答案。复杂度O(log(2^18)*2^18)。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define len(x) (int) x.length()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/int n,flag;string s;ll ans;map&lt;pair&lt;string,string&gt;,int&gt; mp;void dfs(int p,string a,string b)&#123; if(p==n) &#123; if(flag) ans+=mp[MP(a,b)]; else mp[MP(a,b)]++; return; &#125; dfs(p+1,a+s[p],b); dfs(p+1,a,b+s[p]);&#125;int main()&#123; while(~scanf(\"%d\",&amp;n)) &#123; cin&gt;&gt;s; mp.clear(); flag=0; dfs(0,\"\",\"\"); flag=1; reverse(all(s)); ans=0; dfs(0,\"\",\"\"); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/22/agc026.C/","date":"07-22","excerpt":""},{"title":"Codeforces Round#498 div3F Xor-Paths (折半搜索)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1006/F 题意：给一个n*m的矩形，起点(1,1)。每次只能往右走或者往下走。求走到(n,m)时，走过的路径上的值异或起来等于k的方案数 题解：由于n和m只有20，也就是n+m&lt;=40，做法就很明显了。折半步长。第一次从(1,1)为起点走(n+m)/2步，最后走到的终点用map记录下异或值。然后再从(n,m)开始倒退剩下的步数，走到第一次走到的终点停下，用map更新答案。复杂度O(log(2^20)*2^20)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/ll mp[33][33],ans,k;map&lt;ll,ll&gt; cnt[33][33];int n,m,limt;void dfs1(int x,int y,ll now,int len)&#123; if(x&lt;1||y&lt;1||x&gt;n||y&gt;m) return; if(len==limt) &#123; now^=mp[x][y]; cnt[x][y][now]++;// cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;now&lt;&lt;endl; return; &#125; dfs1(x+1,y,now^mp[x][y],len+1); dfs1(x,y+1,now^mp[x][y],len+1);&#125;void dfs2(int x,int y,ll now,int len)&#123; if(x&lt;1||y&lt;1||x&gt;n||y&gt;m) return; if(len==limt+1) &#123; ans+=cnt[x][y][k^now]; // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;(now^k)&lt;&lt;endl; return; &#125; dfs2(x-1,y,now^mp[x][y],len+1); dfs2(x,y-1,now^mp[x][y],len+1);&#125;int main()&#123; int i,j; while(~scanf(\"%d%d%lld\",&amp;n,&amp;m,&amp;k)) &#123; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%lld\",&amp;mp[i][j]); cnt[i][j].clear(); &#125; &#125; if(n==1&amp;&amp;m==1) &#123; if(mp[1][1]==k) puts(\"1\"); else puts(\"0\"); continue; &#125; ans=0; limt=(n+m-1)/2; dfs1(1,1,0,1);// puts(\"**\"); limt=(n+m-1)-limt; dfs2(n,m,0,1); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/07/21/cf498.3F/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）J.Different Integers (主席树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/J 题意：给一个长度为n的序列和查询次数q。每次给出L和R，查询区间[1,L]和[R,n]中不同数的个数。 题解：把序列复制一遍，就能查询连续的区间，然后就变成了主席树模板题。注意L&gt;R的时候是查询整个序列。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//由于FastIO太长,就不贴出来了#include &lt;bits/stdc++.h&gt;using namespace std;void Main();int main()&#123; #ifdef tokitsukaze freopen(\"TEST.txt\",\"r\",stdin); #endif Main();return 0;&#125;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=1e9+7;/********************************* head *********************************/struct president_tree&#123; int root[MAX],ls[40*MAX],rs[40*MAX],sum[40*MAX],tot,ql,qr,qv; void init() &#123; mem(root,0); tot=1; ls[0]=rs[0]=sum[0]=0; &#125; int newnode(int x) &#123; ls[tot]=ls[x]; rs[tot]=rs[x]; sum[tot]=sum[x]; return tot++; &#125; void insert(int l,int r,int &amp;id,int pre) //set(ql,ql,v) &#123; id=newnode(pre); sum[id]+=qv; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) insert(l,mid,ls[id],ls[pre]); else insert(mid+1,r,rs[id],rs[pre]); &#125; int kindcnt(int l,int r,int id) //set(ql,qr) &#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[id]; int mid=(l+r)&gt;&gt;1; int res=0; if(ql&lt;=mid) res+=kindcnt(l,mid,ls[id]); if(qr&gt;=mid+1) res+=kindcnt(mid+1,r,rs[id]); return res; &#125; int kthsmall(int l,int r,int id,int pre,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int temp=sum[ls[id]]-sum[ls[pre]]; if(temp&gt;=k) return kthsmall(l,mid,ls[id],ls[pre],k); else return kthsmall(mid+1,r,rs[id],rs[pre],k-temp); &#125; int kthbig(int l,int r,int id,int pre,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int temp=sum[rs[id]]-sum[rs[pre]]; if(temp&gt;=k) return kthbig(mid+1,r,rs[id],rs[pre],k); else return kthbig(l,mid,ls[id],ls[pre],k-temp); &#125; void set(int l,int r,int v=0)&#123;ql=l;qr=r;qv=v;&#125;&#125;pt;int a[MAX],last[MAX];void Main()&#123; int n,q,i,j,l,r; while(read(n,q)) &#123; pt.init(); for(i=n,j=0;i&lt;=2*n-1;i++,j++) &#123; read(a[i]); last[a[i]]=-1; a[j]=a[i]; &#125;/* for(i=1;i&lt;=2*n-1;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; puts(\"\");*/ for(i=2*n-1;i&gt;=1;i--) &#123; if(last[a[i]]==-1) &#123; pt.set(i,i,1); pt.insert(1,2*n-1,pt.root[i],pt.root[i+1]); &#125; else &#123; int tmp; pt.set(last[a[i]],last[a[i]],-1); pt.insert(1,2*n-1,tmp,pt.root[i+1]); pt.set(i,i,1); pt.insert(1,2*n-1,pt.root[i],tmp); &#125; last[a[i]]=i; &#125; while(q--) &#123; read(l,r); if(l&lt;r-1) &#123; l+=n-1; r=n-(n-r+1); swap(l,r);// cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; pt.set(l,r); print(pt.kindcnt(1,2*n-1,pt.root[l]),'\\n'); &#125; else &#123; pt.set(1,2*n-1); print(pt.kindcnt(1,2*n-1,pt.root[1]),'\\n'); &#125; &#125; &#125;&#125;","path":"2018/07/21/2018niuke1.J/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第二场）J.farm (随机化)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/140/J 题意：有一个nm的矩形，每个位置有一个数。有T次操作，每次往一个子矩形的每个格子中放入一个数。求有多少个格子中被放入了至少一个与对应位置不相同的数。nm&lt;=1e6,T&lt;=1e6 题解：now[i][j]表示在T次操作后，第(i，j)个格子放的数的和。cnt[i][j]表示在T次操作后，第(i，j)个格子被更新的次数。v[i][j]表示第(i，j)个格子的初始值。now和cnt用二维前缀和更新。那么答案就是now[i][j]!=cnt[i][j]*v[i][j]的个数。 很明显这是假算法，出题人会构造数据卡你。所以对初始值随机打乱一下，被卡的概率就很低。复杂度O(n*m)。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e6+10;const ll mod=1e9+7;/**************************************** head ****************************************/VI v[MAX],cnt[MAX];VL now[MAX];int mp[MAX];int main()&#123; int n,m,q,i,j,x1,x2,y1,y2,vv; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(i=1;i&lt;=n*m;i++) mp[i]=i; random_shuffle(mp+1,mp+1+n*m); for(i=0;i&lt;=n+1;i++) &#123; v[i].resize(m+5); cnt[i].resize(m+5); now[i].resize(m+5); &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;v[i][j]); v[i][j]=mp[v[i][j]]; now[i][j]=0; cnt[i][j]=0; &#125; &#125; while(q--) &#123; scanf(\"%d%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;vv); now[x1][y1]+=mp[vv]; now[x1][y2+1]-=mp[vv]; now[x2+1][y1]-=mp[vv]; now[x2+1][y2+1]+=mp[vv]; cnt[x1][y1]++; cnt[x1][y2+1]--; cnt[x2+1][y1]--; cnt[x2+1][y2+1]++; &#125; int ans=0; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; now[i][j]+=now[i-1][j]+now[i][j-1]-now[i-1][j-1]; cnt[i][j]+=cnt[i-1][j]+cnt[i][j-1]-cnt[i-1][j-1]; if(now[i][j]!=1LL*cnt[i][j]*v[i][j]) ans++; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/07/21/2018niuke2.J/","date":"07-21","excerpt":""},{"title":"2018牛客网暑期ACM多校训练营（第一场）F.Sum of Maximum(组合数学+拉格朗日插值)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nowcoder.com/acm/contest/139/F 题意： 题解： 至于杜教的拉格朗日插值板子，是从这里扒的：http://codeforces.com/contest/995/submission/39615335 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=1e9+7;/**************************************** head ****************************************/namespace polysum &#123; #define rep(i,a,n) for (int i=a;i&lt;n;i++) #define per(i,a,n) for (int i=n-1;i&gt;=a;i--) const int D=101000; ll a[D],tmp[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125; ll calcn(int d,ll *a,ll n) &#123; // a[0].. a[d] a[n] if (n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1) &#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1) &#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans=0; rep(i,0,d+1) &#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if ((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; void init(int M) &#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=powmod(f[M+4],mod-2); per(i,1,M+4) g[i]=g[i+1]*(i+1)%mod; &#125; ll polysum(ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] rep(i,0,m+1) tmp[i]=a[i]; tmp[m+1]=calcn(m,tmp,m+1); rep(i,1,m+2) tmp[i]=(tmp[i-1]+tmp[i])%mod; return calcn(m+1,tmp,n-1); &#125; ll qpolysum(ll R,ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=powmod(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0;h[0][1]=1; rep(i,1,m+2) &#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2) &#123; ll t=g[i]*g[m+1-i]%mod; if (i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=powmod(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*powmod(R,n)-c)%mod; if (ans&lt;0) ans+=mod; return ans; &#125;&#125; // polysum::init();ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int t,n,i,j; ll ans,a[1111],now,b[1111]; polysum::init(1010); while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); ans=0; sort(a+1,a+1+n); a[0]=0; now=1; for(i=1;i&lt;=n;i++) &#123; if(a[i]==a[i-1]) &#123; (now*=a[i])%=mod; continue; &#125; b[0]=0; for(j=1;j&lt;=n-i+1;j++) &#123; b[j]=j*((pow2(j,n-i+1)-pow2(j-1,n-i+1)%mod)+mod)%mod; &#125; ll tmp=((polysum::polysum(a[i]+1,b,n-i+1)-polysum::polysum(a[i-1]+1,b,n-i+1))%mod+mod)%mod; (ans+=tmp*now%mod)%=mod; (now*=a[i])%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;/*52 3 3 3 5*/","path":"2018/07/19/2018niuke1.F/","date":"07-19","excerpt":""},{"title":"勾股数的性质","text":"转载请注明出处：http://tokitsukaze.live/ 勾股数的基本组及其性质","path":"2018/07/12/PythagoreanTriple/","date":"07-12","excerpt":""},{"title":"Codeforces Round#495 div2E Sonya and Ice Cream (树的直径+滑动窗口+单调队列)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1004/E 题意：给一棵n个顶点的树，树的每条边有权值。我们要找一条链，节点个数在[1,k]范围内，使得不在链上的节点到链上的距离(就是边长的和)的最大值最小。 题解：很明显，最优的链肯定在树的直径上。求出树的直径，对于直径上的每个点x，求出其他能到x的最大距离。然后对树的直径滑窗，用单调队列维护最大值，ans取个min即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/*************************************** head **********************************************/vector&lt;PII &gt; mp[MAX];int mx,rt,fa[MAX],dep[MAX],flag[MAX];void dfs(int x,int pre)&#123; fa[x]=pre; if(pre==-1) dep[x]=0; for(auto to:mp[x]) &#123; if(to.fi==pre) continue; if(flag[to.fi]) continue; dep[to.fi]=dep[x]+to.se; dfs(to.fi,x); &#125; if(mx&lt;dep[x]) &#123; rt=x; mx=dep[x]; &#125;&#125;int dq[MAX],l,r;int main()&#123; int n,k,i,j,a,b,w,ans; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); mem(flag,0); for(i=1;i&lt;n;i++) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;w); mp[a].pb(MP(b,w)); mp[b].pb(MP(a,w)); &#125; mx=0; rt=1; dfs(rt,-1); mx=0; dfs(rt,-1); vector&lt;PII &gt; res; while(~rt) &#123; res.pb(MP(rt,dep[rt])); flag[rt]=1; rt=fa[rt]; &#125; reverse(all(res)); VI len; for(auto it:res) &#123; mx=0; dfs(it.fi,-1); len.pb(mx); // cout&lt;&lt;it.fi&lt;&lt;\" \"&lt;&lt;it.se&lt;&lt;endl; &#125; l=r=0; k=min(k,sz(res)); ans=INF; for(i=0,j=0;i+k-1&lt;sz(res);i++) &#123; while(i+j&lt;k) &#123; while(r-l&amp;&amp;len[dq[r-1]]&lt;len[j]) r--; dq[r++]=j++; &#125; while(r-l&amp;&amp;dq[l]&lt;i) l++; ans=min(ans,max(&#123;res[i].se,res[sz(res)-1].se-res[i+k-1].se,len[dq[l]]&#125;)); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;/*8 61 4 102 4 13 4 14 5 105 6 103 7 12 8 1*/","path":"2018/07/09/cf495.2E/","date":"07-09","excerpt":""},{"title":"CS Academy Round#65 (Div. 2 only) C.Crossing Tree (树的直径+欧拉序)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://csacademy.com/contest/archive/task/crossing-tree/statement/ 题意：给一棵n个顶点的树，让你选择一个起点，把每个点都走一遍。边的长度为1，让你输出路径的长度并按走的顺序输出路径。 题解：记录树的直径，沿着树的直径走，到每个节点再向非树的直径的节点走，走完回到直径上。所以路径长度是(n-dia)*2-1+dia。dia是树的直接的节点个数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; PII;typedef pair&lt;ll,ll&gt; PLL;typedef vector&lt;int&gt; VI;typedef vector&lt;ll&gt; VL;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=1e5+10;const ll mod=1e9+7;/*************************************** head **********************************************/VI mp[MAX],res;int fa[MAX],flag[MAX],rt,mx;void dfs(int x,int pre,int h)&#123; fa[x]=pre; for(auto to:mp[x]) &#123; if(to==pre) continue; dfs(to,x,h+1); &#125; if(h&gt;mx) &#123; mx=h; rt=x; &#125;&#125;void gao(int x,int pre)&#123; res.pb(x); flag[x]=1; for(auto to:mp[x]) &#123; if(to==pre) continue; if(flag[to]) continue; gao(to,x); res.pb(x); &#125;&#125;int main()&#123; int n,i,a,b; while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); res.clear(); mem(flag,0); for(i=0;i&lt;n-1;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; rt=1; mx=-1; dfs(rt,-1,0); mx=-1; dfs(rt,-1,0); VI tmp; while(~rt) &#123; tmp.pb(rt); flag[rt]=1; rt=fa[rt]; &#125; mx++; assert(sz(tmp)==mx); for(auto it:tmp) gao(it,-1); assert(sz(res)-1==(n-mx)*2-1+mx); printf(\"%d\\n\",sz(res)-1); for(i=0;i&lt;sz(res);i++) printf(\"%d%c\",res[i],\" \\n\"[i==sz(res)-1]); &#125; return 0;&#125;","path":"2018/07/09/CSA65.C/","date":"07-09","excerpt":""},{"title":"Codeforces Round#492 div1F Cowmpany Cowmpensation (树形dp+拉格朗日插值法)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/F 题意：给一棵n个顶点的树，树的每个顶点可以赋值[1,d]。求方案数。 题解：可以证明答案为关于d的n次多项式。所以先求出多项式的n+1个点值，然后做拉格朗日插值即可。dp[x][i]表示节点x赋值为i的方案数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=3e3+10;const ll mod=1e9+7;namespace polysum &#123; #define rep(i,a,n) for (int i=a;i&lt;n;i++) #define per(i,a,n) for (int i=n-1;i&gt;=a;i--) const int D=101000; ll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125; ll calcn(int d,ll *a,ll n) &#123; // a[0].. a[d] a[n] if (n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1) &#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1) &#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans=0; rep(i,0,d+1) &#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if ((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; void init(int M) &#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=powmod(f[M+4],mod-2); per(i,1,M+4) g[i]=g[i+1]*(i+1)%mod; &#125; ll polysum(ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] a[m+1]=calcn(m,a,m+1); rep(i,1,m+2) a[i]=(a[i-1]+a[i])%mod; return calcn(m+1,a,n-1); &#125; ll qpolysum(ll R,ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=powmod(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0;h[0][1]=1; rep(i,1,m+2) &#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2) &#123; ll t=g[i]*g[m+1-i]%mod; if (i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=powmod(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*powmod(R,n)-c)%mod; if (ans&lt;0) ans+=mod; return ans; &#125;&#125;// polysum::init();ll dp[MAX][MAX];VI mp[MAX];int main()&#123; int n,d,i,x; polysum::init(3030); while(~scanf(\"%d%d\",&amp;n,&amp;d)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); for(i=2;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); mp[x].pb(i); &#125; function&lt;void(int)&gt; dfs=[&amp;](int x) &#123; ll tmp; for(i=1;i&lt;=n+1;i++) dp[x][i]=1; dp[x][0]=0; for(auto to:mp[x]) &#123; dfs(to); tmp=0; for(i=1;i&lt;=n+1;i++) &#123; (tmp+=dp[to][i])%=mod; (dp[x][i]*=tmp)%=mod; &#125; &#125; &#125;; dfs(1); for(i=1;i&lt;=n+1;i++) (dp[1][i]+=dp[1][i-1])%=mod; printf(\"%lld\\n\",polysum::calcn(n,dp[1]+1,d-1)); &#125; return 0;&#125;","path":"2018/07/07/cf492.1F/","date":"07-07","excerpt":""},{"title":"Codeforces Round#494 div3F Abbreviation (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1003/F 题意：给一篇文章，由n个单词组成。选择连续一段单词进行缩写，然后用缩写替换这篇文章，求替换后文章的最小长度。 题解：容易想到直接暴力，第一个for枚举长度，第二个for枚举缩写的起点，第三个for枚举现在的位置，第四个for是check是否能缩写。复杂度O(n^4)，优化一下可过。思考一下，发现第四个for可以用hash优化掉，复杂度O(n^3)。由于用了固定seed和固定mod，写了个双hash都被hack了…根据tls的建议，rand一下seed，然后mod用1e9+7和1e9+9比较稳(待测试)。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=2e5+10;const ll mod=998244353;struct hash_table&#123; ll seed,p; ll Hash[MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(string s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=0;i&lt;n;i++) Hash[i+1]=(Hash[i]*seed%p+(s[i]))%p; &#125; ll get(int l,int r) &#123; return (Hash[r]-Hash[l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;h1,h2;int bit[MAX];int main()&#123; ll hh1,hh2; int n,i,j,k,l,ans,flag,pos,f; string s[333],res,tmp; srand(time(0)); while(~scanf(\"%d\",&amp;n)) &#123; ans=0; bit[0]=0; tmp=\"\"; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i]; ans+=s[i].length(); tmp+=s[i]; if(i!=n) tmp+=' '; bit[i]=bit[i-1]+s[i].length(); if(i!=1) bit[i]++; &#125; ans+=n-1; h1.set(rand(),1e9+7); h1.work(tmp,tmp.length()); h2.set(rand(),1e9+9); h2.work(tmp,tmp.length()); for(i=1;i&lt;=n;i++) &#123; for(j=1;j+2*i-1&lt;=n;j++) &#123; res=\"\"; f=0; for(k=1;k&lt;j;k++) &#123; f=1; res+=s[k]; if(k!=j-1) res+=' '; &#125; for(k=j;k&lt;=j+i-1;k++) &#123; if(f) &#123; res+=' '; f=0; &#125; res+=s[k][0]-'a'+'A'; &#125; hh1=h1.get(bit[j-1]+(j==1?1:2),bit[j+i-1]); hh2=h2.get(bit[j-1]+(j==1?1:2),bit[j+i-1]); k=j+i; f=1; while(k&lt;=n) &#123; flag=0; if(k+i-1&gt;n) flag=1; else &#123; if(h1.get(bit[k-1]+(k==1?1:2),bit[k+i-1])!=hh1) flag=1; if(h2.get(bit[k-1]+(k==1?1:2),bit[k+i-1])!=hh2) flag=1; &#125; if(!flag) &#123; res+=' '; for(pos=k,l=j;pos&lt;=k+i-1&amp;&amp;pos&lt;=n;pos++,l++) &#123; res+=s[pos][0]-'a'+'A'; &#125; k=k+i; f++; &#125; else &#123; res+=' '; res+=s[k]; k++; &#125; &#125; if(f==1) continue; if(ans&gt;sz(res)) tmp=res; ans=min(ans,sz(res)); &#125; &#125; // cout&lt;&lt;tmp&lt;&lt;endl; printf(\"%d\\n\",ans); &#125; return 0;&#125;/*5a a a a a2aa aa*/","path":"2018/07/04/cf494.3F/","date":"07-04","excerpt":""},{"title":"Codeforces Round#494 div3E Tree Constructing (构造)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1003/E 题意：给n，d，k。让你构造一棵n个节点的树，树的直径恰好为d，树的每个节点的度&lt;=k。 题解：首先构造直径，如果不能构造直径就直接NO。h[x]表示到x这个节点的最长树链。in[x]表示x这个节点的度。然后dfs构造即可。最后check一下是不是满足题目要求，不满足就NO。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=4e5+10;const ll mod=998244353;int n,d,k,tot,in[MAX],h[MAX];vector&lt;PII &gt; res;void dfs(int x)&#123; while(1) &#123; if(h[x]+1&gt;d) return; if(in[x]+1&gt;k) return; if(tot==n) return; tot++; in[x]++; in[tot]++; h[tot]=h[x]+1; res.pb(MP(x,tot)); dfs(tot); &#125;&#125;int main()&#123; int i,j,flag; while(~scanf(\"%d%d%d\",&amp;n,&amp;d,&amp;k)) &#123; res.clear(); mem(in,0); mem(h,0); d++; tot=d; if(d&gt;n) &#123; puts(\"NO\"); continue; &#125; for(i=1;i&lt;d;i++) &#123; res.pb(MP(i,i+1)); in[i]++; in[i+1]++; h[i]=max(d-i+1,i); h[i+1]=max(d-i,i+1); &#125; for(i=1;i&lt;=tot;i++) dfs(i); flag=0; for(i=1;i&lt;=n;i++) &#123; if(in[i]&gt;k||h[i]&gt;d) flag=1; &#125; if(tot!=n) flag=1; if(flag) &#123; puts(\"NO\"); continue; &#125; puts(\"YES\"); assert(sz(res)==n-1); for(auto it:res) printf(\"%d %d\\n\",it.fi,it.se); &#125; return 0;&#125;","path":"2018/07/04/cf494.3E/","date":"07-04","excerpt":""},{"title":"Codeforces Round#492 div1E Number Clicker (双向bfs)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/E 题意：给u，v，p。让你从u变成v。有3种操作。1.u-&gt;(u+1)%p2.u-&gt;(u-1+p)%p3.u-&gt;(u^(p-2))%p请输出u变成v的操作过程，操作次数不能超过200次。保证p是素数。 题解：由于p是素数，所以操作3就是个逆元。即若x=(y^(p-2))%p，那么y=(x^(p-2))%p。然后直接双向bfs即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;ll x,y,p;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;map&lt;ll,PLL&gt; pre[2];map&lt;ll,int&gt; flag[2];queue&lt;ll&gt; q[2];void add(ll t,ll a,int id,ll tag)&#123; if(!flag[id][a]) &#123; q[id].push(a); flag[id][a]=1; pre[id][a]=MP(t,tag); &#125;&#125;VL res;void gao(ll t)&#123; ll tmp=t; while(t!=x) &#123; res.pb(pre[0][t].se); t=pre[0][t].fi; &#125; reverse(all(res)); t=tmp; while(t!=y) &#123; res.pb(pre[1][t].se); t=pre[1][t].fi; &#125;&#125; void bfs()&#123; ll t,sz; for(int i=0;i&lt;2;i++) &#123; pre[i].clear(); flag[i].clear(); while(sz(q[0])) q[0].pop(); while(sz(q[1])) q[1].pop(); &#125; q[0].push(x); q[1].push(y); flag[0][x]=1; flag[1][y]=1; pre[0][x]=MP(x,0); pre[1][y]=MP(y,0); res.clear(); while(!q[0].empty()||!q[1].empty()) &#123; sz=sz(q[0]); while(sz--) &#123; t=q[0].front(); q[0].pop(); if(flag[1][t]) &#123; gao(t); return; &#125; add(t,(t+1)%mod,0,1); add(t,(t-1+mod)%mod,0,2); add(t,pow2(t,p-2),0,3); &#125; sz=sz(q[1]); while(sz--) &#123; t=q[1].front(); q[1].pop(); if(flag[0][t]) &#123; gao(t); return; &#125; add(t,(t+1)%mod,1,2); add(t,(t-1+mod)%mod,1,1); add(t,pow2(t,p-2),1,3); &#125; &#125;&#125; int main()&#123; while(~scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;p)) &#123; bfs(); printf(\"%d\\n\",sz(res)); for(int i=0;i&lt;sz(res);i++) printf(\"%lld%c\",res[i],\" \\n\"[i==sz(res)-1]); &#125; return 0;&#125;","path":"2018/07/01/cf492.1E/","date":"07-01","excerpt":""},{"title":"Codeforces Round#492 div2F/div1D Game (数学)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/D 题意：给2^n个数，Allen和Bessie轮流操作，每次操作可以选一个数，sum加上或者不加这个数，每个数只能选一次。Allen想让sum最大，Bessie想让sum最小。让你求sum的期望值。然后有r轮，每轮会改变一个数，每次输出改变后sum的期望值。 题解：观察案例猜了个结论就过了… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;int main()&#123; int n,r,i,x,y; double ans; while(~scanf(\"%d%d\",&amp;n,&amp;r)) &#123; n=1&lt;&lt;n; VI a(n); ans=0; for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]),ans+=a[i]; printf(\"%.6f\\n\",ans/n); for(i=0;i&lt;r;i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); ans-=a[x]; a[x]=y; ans+=a[x]; printf(\"%.6f\\n\",ans/n); &#125; &#125; return 0;&#125;","path":"2018/07/01/cf492.1D/","date":"07-01","excerpt":""},{"title":"Codeforces Round#492 div2C/div1A Tesla (构造)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/995/A 题意：给4xn的矩阵，第一行和第四行表示停车位，第二行和第三行表示车或者空位。要求把车移到对应的停车位上，输出移动的方案，移动次数&lt;=20000。 题解：如图。每次所有车转一圈，如果移动到对应的车位前面，就移进去。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;int mp[55][55];int m,k;const int n=4;set&lt;int&gt; s;struct node&#123;int id,x,y;&#125;;vector&lt;node&gt; res;PII findpos()&#123; int i,j; for(i=2;i&lt;=3;i++) &#123; for(j=1;j&lt;=m;j++) &#123; if(!mp[i][j]) return MP(i,j); &#125; &#125; return MP(-1,-1);&#125;void move(PII x)&#123; int i,j; i=x.fi; if(i==2) &#123; for(j=x.se;j&lt;m;j++)//&lt;- &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; if(mp[3][m]) res.pb(&#123;mp[3][m],i,m&#125;);//up swap(mp[2][m],mp[3][m]); i=3; for(j=m;j&gt;1;j--)//-&gt; &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; if(x.se!=1) &#123; if(mp[2][1]) res.pb(&#123;mp[2][1],3,1&#125;);//dwon swap(mp[3][1],mp[2][1]); &#125; i=2; for(j=1;j&lt;x.se-1;j++) &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; &#125; else &#123; for(j=x.se;j&gt;1;j--)//-&gt; &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; if(mp[2][1]) res.pb(&#123;mp[2][1],3,1&#125;);//dwon swap(mp[3][1],mp[2][1]); i=2; for(j=1;j&lt;m;j++)//&lt;- &#123; if(mp[i][j+1]) res.pb(&#123;mp[i][j+1],i,j&#125;); swap(mp[i][j],mp[i][j+1]); &#125; if(x.se!=m) &#123; if(mp[3][m]) res.pb(&#123;mp[3][m],i,m&#125;);//up swap(mp[2][m],mp[3][m]); &#125; i=3; for(j=m;j&gt;x.se+1;j--) &#123; if(mp[i][j-1]) res.pb(&#123;mp[i][j-1],i,j&#125;); swap(mp[i][j],mp[i][j-1]); &#125; &#125;&#125;void gao()&#123; int j; for(j=1;j&lt;=m;j++) &#123; if(mp[2][j]&amp;&amp;mp[2][j]==mp[1][j]) &#123; mp[2][j]=0; res.pb(&#123;mp[1][j],1,j&#125;); s.insert(mp[1][j]); &#125; &#125; for(j=1;j&lt;=m;j++) &#123; if(mp[3][j]&amp;&amp;mp[3][j]==mp[4][j]) &#123; mp[3][j]=0; res.pb(&#123;mp[4][j],4,j&#125;); s.insert(mp[4][j]); &#125; &#125;&#125;int main()&#123; int i,j,f; while(~scanf(\"%d%d\",&amp;m,&amp;k)) &#123; mem(mp,0); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;mp[i][j]); &#125; &#125; s.clear(); res.clear(); gao(); PII pre=findpos(); if(pre==MP(-1,-1)) &#123; puts(\"-1\"); continue; &#125; if(pre.fi==2) f=-1; else f=1; while(sz(s)&lt;k) &#123; /* puts(\"*****\"); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; printf(\"%d \",mp[i][j]); &#125; puts(\"\"); &#125;*/ move(pre); gao(); pre.se+=f; if(pre.se==0||pre.se==m+1) &#123; pre.se=(pre.se==0?1:m); f*=-1; pre.fi^=1; &#125; &#125; printf(\"%d\\n\",sz(res)); for(i=0;i&lt;sz(res);i++) printf(\"%d %d %d\\n\",res[i].id,res[i].x,res[i].y); &#125; return 0;&#125;/*4 51 2 3 47 1 2 34 5 6 05 6 7 0*/","path":"2018/07/01/cf492.1A/","date":"07-01","excerpt":""},{"title":"Codeforces edu#46 F.One Occurrence (线段树+扫描线)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/F 题意：给一个序列，q次查询，每次查询区间[L,R]内只出现一次的数字，输出任意一个，如果没有就输出0。 题解：注意到没有修改，所以很容易想到离线做。把查询按R从小到大排序，扫描线扫R，把每一个数的前驱位置插入线段树，那么要查询区间[L,R]内只出现一次的数字，只需要查询区间[L,R]内出现的数的前驱位置的最小值是不是小于L即可。注意，在每次插入之前，如果有前驱的话，要把前驱插入的信息删除，即把位置赋值成INF，这样就避免了查询到的是某个数的前驱的前驱的问题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;struct Segment_Tree&#123; #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; PII v[MAX&lt;&lt;2],qv; void pushup(int id) &#123; v[id]=min(v[ls],v[rs]); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; v[id]=qv; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; PII query(int l,int r,int id) &#123; PII res=MP(INF,INF); if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res=min(res,query(l,mid,ls)); if(qr&gt;mid) res=min(res,query(mid+1,r,rs)); return res; &#125; void upd(int l,int r,PII x) &#123; ql=l; qr=r; qv=x; update(1,n,1); &#125; PII ask(int l,int r) &#123; ql=l; qr=r; return query(1,n,1); &#125; void build(int _n)&#123;n=_n;mem(v,0);&#125; &#125;tr;struct node&#123; int l,r,id; friend bool operator &lt;(node a,node b) &#123; return a.r&lt;b.r; &#125;&#125;;int a[MAX],ans[MAX],pre[MAX],last[MAX];int main()&#123; int n,q,i,l,r,j; while(~scanf(\"%d\",&amp;n)) &#123; mem(last,0); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); if(!last[a[i]]) pre[i]=0; else pre[i]=last[a[i]]; last[a[i]]=i; &#125; tr.build(MAX-10); scanf(\"%d\",&amp;q); vector&lt;node&gt; res; for(i=1;i&lt;=q;i++) &#123; scanf(\"%d%d\",&amp;l,&amp;r); res.pb(node&#123;l,r,i&#125;); &#125; sort(all(res)); r=1; for(i=0;i&lt;sz(res);i++) &#123; while(r&lt;=res[i].r) &#123; if(pre[r]) tr.upd(pre[r],pre[r],MP(INF,INF)); tr.upd(r,r,MP(pre[r],a[r])); r++; &#125; PII tmp=tr.ask(res[i].l,res[i].r); if(tmp.fi&lt;res[i].l) ans[res[i].id]=tmp.se; else ans[res[i].id]=0; &#125; for(i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); &#125; return 0;&#125;","path":"2018/07/01/cfedu46.F/","date":"07-01","excerpt":""},{"title":"Codeforces edu#46 E.We Need More Bosses (无向图tarjan缩点+树的直径)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/E 题意：一条路径上必经的边为关键边，现在让你找一条路径，使得其关键边最多，输出最多的数量。 题解：如果一条路径上面有环，那么这个环的任意一条边都不是关键边。所以先缩点，缩点完变成一棵树，那么在一棵树上找最多的关键边，显然就是求直径。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=3e5+10;const ll mod=1e9+7;namespace Tarjan&#123; int bcc,top,tot,n; vector&lt;int&gt; mp[MAX]; int low[MAX],dfn[MAX],belong[MAX],fa[MAX]; int stk[MAX]; void dfs(int x,int pre) &#123; int to,i,temp,k; stk[top++]=x; low[x]=dfn[x]=++tot; fa[x]=pre; k=0; for(auto to:mp[x]) &#123; if(to==pre&amp;&amp;!k) &#123; k++; continue; &#125; if(!dfn[to]) &#123; dfs(to,x); low[x]=min(low[x],low[to]); &#125; else low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; bcc++; do &#123; temp=stk[--top]; belong[temp]=bcc; &#125;while(temp!=x); &#125; &#125; void work(int _n,vector&lt;int&gt; e[]) &#123; n=_n; for(int i=1;i&lt;=n;i++) &#123; mp[i]=e[i]; low[i]=dfn[i]=fa[i]=stk[i]=0; &#125; bcc=top=tot=0; for(int i=1;i&lt;=n;i++) &#123; if(!dfn[i]) dfs(i,i); &#125; &#125; void rebuild(vector&lt;int&gt; e[]) &#123; int i,t; for(i=1;i&lt;=n;i++) e[i].clear(); for(i=1;i&lt;=n;i++) &#123; t=fa[i]; if(belong[i]!=belong[t]) &#123; e[belong[i]].pb(belong[t]); e[belong[t]].pb(belong[i]); &#125; &#125; &#125;&#125;int Tree_Diameter(const vector&lt;int&gt; e[])&#123; static int h[MAX]; int mx,rt; function&lt;void(int,int)&gt; dfs=[&amp;](int x,int fa) &#123; h[x]=h[fa]+1; for(auto to:e[x]) &#123; if(to==fa) continue; dfs(to,x); &#125; if(h[x]&gt;mx) &#123; mx=h[x]; rt=x; &#125; &#125;; mx=rt=-1; dfs(1,0); dfs(rt,0); return mx;&#125;vector&lt;int&gt; mp[MAX],res[MAX];int main()&#123; int n,m,a,b,i; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(i=1;i&lt;=n;i++) mp[i].clear(); while(m--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); mp[b].pb(a); &#125; Tarjan::work(n,mp); Tarjan::rebuild(res); printf(\"%d\\n\",Tree_Diameter(res)-1); &#125; return 0;&#125;","path":"2018/06/30/cfedu46.E/","date":"06-30","excerpt":""},{"title":"Codeforces edu#46 D.Yet Another Problem On a Subsequence (dp)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/1000/D 题意：给一个序列。定义good子序列：满足可以划分为若干个组，每个组的第一个数=这个组的长度-1。求有多少个good子序列。 题解：dp[i]表示以i开头的good子序列的个数。直接倒着转移即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-4;const int MAX=5e5+10;const ll mod=998244353;ll C[1010][1010];void init(int n)&#123; int i,j; for(i=(C[0][0]=1);i&lt;=n;i++) &#123; for(j=(C[i][0]=1);j&lt;=n;j++) &#123; C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; &#125;int main()&#123; int n,i,j,a[MAX]; ll dp[1010]; init(1000); while(~scanf(\"%d\",&amp;n)) &#123; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); mem(dp,0); dp[n+1]=1; for(i=n;i;i--) &#123; if(a[i]&lt;=0) continue; for(j=n;j-a[i]&gt;=i;j--) &#123; (dp[i]+=dp[j+1]*C[j-i][a[i]]%mod)%=mod; &#125; &#125; for(i=2;i&lt;=n;i++) (dp[1]+=dp[i])%=mod; printf(\"%lld\\n\",dp[1]); &#125; return 0;&#125;","path":"2018/06/30/cfedu46.D/","date":"06-30","excerpt":""},{"title":"Codeforces Round#490 div3F Cards and Joy (01背包)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/F 题意：有n*k张牌，每张牌上写了数字，分给n个人，每人k张。每个人有一个喜欢的数字，分到i张喜欢的牌，得到的价值就是h[i]，问价值最大。 题解：cnt[x]表示写着数字为x的牌的个数。f[x]表示喜欢数字为x的牌的人数。 把cnt[x]看作背包容量，f[x]看作物品个数。对于每个物品，重量为i时，获得的价值为h[i]，(0&lt;=i&lt;=k，h[0]=0)。 其实就是一个01背包。枚举x，做01背包就行了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=998244353;int cnt[MAX],f[MAX],h[MAX],k;ll dp[5050];ll gao(int x)&#123; int i,j,l; if(!f[x]) return 0; for(i=0;i&lt;=cnt[x];i++) dp[i]=0; while(f[x]--) &#123; for(i=cnt[x];i;i--) &#123; for(j=0;i-j&gt;=0&amp;&amp;j&lt;=k;j++) &#123; dp[i]=max(dp[i],dp[i-j]+h[j]); &#125; &#125; &#125;// cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;dp[cnt[x]]&lt;&lt;endl; return dp[cnt[x]];&#125;int main()&#123; int n,i,x; ll ans; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; mem(cnt,0); mem(f,0); for(i=1;i&lt;=n*k;i++) &#123; scanf(\"%d\",&amp;x); cnt[x]++; &#125; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); f[x]++; &#125; h[0]=0; for(i=1;i&lt;=k;i++) scanf(\"%d\",&amp;h[i]); ans=0; for(i=1;i&lt;=MAX-10;i++) ans+=gao(i); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/22/cf490.3F/","date":"06-22","excerpt":""},{"title":"Codeforces Round#490 div3E Reachability from the Capital (强连通缩点染色)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/E 题意：给一个有向图和一个起点，求最少连多少条边，使得从起点出发，可以到达其他所有点。 题解：先从起点开始dfs，把能走到的点标记掉。剩下不能走到的点，进行缩点染色。最后统计一下缩点后，入度为0的点的个数就是答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;int scc,top,tot;vector&lt;int&gt; mp[MAX];int low[MAX],dfn[MAX],belong[MAX];int stk[MAX],flag[MAX];void init(int n)&#123; int i; for(i=1;i&lt;=n;i++) &#123; mp[i].clear(); low[i]=0; dfn[i]=0; stk[i]=0; flag[i]=0; &#125; scc=top=tot=0;&#125;void tarjan(int x)&#123; int to,i,temp; stk[top++]=x; flag[x]=1; low[x]=dfn[x]=++tot; for(i=0;i&lt;mp[x].size();i++) &#123; to=mp[x][i]; if(!dfn[to]) &#123; tarjan(to); low[x]=min(low[x],low[to]); &#125; else if(flag[to]) low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; scc++; do &#123; temp=stk[--top]; flag[temp]=0; belong[temp]=scc; &#125;while(temp!=x); &#125;&#125;int tag[MAX];void dfs(int x)&#123; if(tag[x]) return ; tag[x]=1; for(auto to:mp[x]) &#123; dfs(to); &#125;&#125;int in[MAX];int main()&#123; int n,m,s,a,b,i,j,ans; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s)) &#123; init(n); while(m--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); mp[a].pb(b); &#125; mem(tag,0); dfs(s); for(i=1;i&lt;=n;i++) &#123; if(tag[i]) continue; if(!dfn[i]) tarjan(i); &#125; mem(in,0); for(i=1;i&lt;=n;i++) &#123; if(!belong[i]) continue; for(j=0;j&lt;sz(mp[i]);j++) &#123; if(belong[i]!=belong[mp[i][j]]) in[belong[mp[i][j]]]++; &#125; &#125; ans=0; for(i=1;i&lt;=scc;i++) &#123; ans+=(!in[i]); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/06/22/cf490.3E/","date":"06-22","excerpt":""},{"title":"Codeforces Round#490 div3D Equalize the Remainders (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/999/D 题意：给n个数和一个k，把n个数按%k的余数，分成n/k组，使得每组数的个数都相等。我们一次操作：可以任选某个数，把它的值+1。问操作的最小次数和操作后的序列。 题解：先把数先按%k的余数分好，记录下标，这里为了方便操作，用了queue而不是vector。记余数为i的数的个数为sz[i]，如果sz[i]&gt;n/k，开个栈，把多的那些数存到栈中，如果sz[i]$&lt;$n/k，就把栈中的那些数往里填。先从左往右扫一遍，如果栈中还有多的数，就再扫一遍。 因为操作是把一个数的值+1，而且多的数必须移走。所以多的数往右移一定是最优的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX];queue&lt;int&gt; res[MAX];PLL st[MAX];int n,k,tot;ll ans;void gao()&#123; int i,j,sz; ll tmp; for(i=0;i&lt;k;i++) &#123; while(sz(res[i])&gt;n/k) &#123; st[tot++]=MP(res[i].front(),i); res[i].pop(); &#125; if(sz(res[i])==n/k) continue; sz=sz(res[i]); for(j=0;tot&amp;&amp;j&lt;n/k-sz;j++) &#123; res[i].push(st[tot-1].fi); tmp=i-st[tot-1].se; if(tmp&lt;0) tmp+=k; a[st[tot-1].fi]+=tmp; ans+=tmp; tot--; &#125; &#125;&#125;int main()&#123; int i,j; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(i=0;i&lt;k;i++) &#123; while(!res[i].empty()) res[i].pop(); &#125; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); res[a[i]%k].push(i); &#125; ans=0; tot=0; gao(); gao(); printf(\"%lld\\n\",ans); for(i=1;i&lt;=n;i++) printf(\"%lld%c\",a[i],\" \\n\"[i==n]); &#125; return 0;&#125;/*8 40 0 0 0 2 2 2 28 41 1 1 1 3 3 3 36 20 0 1 1 1 1*/","path":"2018/06/22/cf490.3D/","date":"06-22","excerpt":""},{"title":"Codeforces Round#489 div2E Nastya and King-Shamans (线段树+暴力剪枝)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/E 题意：给一个序列a，q次操作。每次操作单点修改。每次操作后，询问序列a中有没有一个位置满足a[i]=bit[i-1]，如果有，随便输出一个位置，如果没有输出-1。其中bit为前缀和数组。 题解：容易想到建立线段树维护a[i]-bit[i-1]，问题就转化成查询线段树内值为0的位置。记录一个区间最大值maxx，查询时，如果这个区间maxx小于0，说明这个区间内的数全都不满足，直接剪枝，否则一直查询到叶子节点。 看上去很暴力，其实想想是可行的。因为如果要避开这个剪枝，a[i]-bit[i-1]必须大于0（如果等于0的话，也能很快走到叶子节点），那么这个序列假设a[1]=0，那么a[1]就至少为1，a[2]至少为2，a[3]至少为4，以此类推。也就是说，最多走过log个叶子节点，一定能得出答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX];struct Segment_Tree&#123; #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; ll a[MAX],tag[MAX&lt;&lt;2],maxx[MAX&lt;&lt;2],qv; void pushup(int id) &#123; maxx[id]=max(maxx[ls],maxx[rs]); &#125; void pushdown(int id) &#123; if(!tag[id]) return; maxx[ls]+=tag[id]; maxx[rs]+=tag[id]; tag[ls]+=tag[id]; tag[rs]+=tag[id]; tag[id]=0; &#125; void build(int l,int r,int id) &#123; tag[id]=0; maxx[id]=0; if(l==r) &#123; maxx[id]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); pushup(id); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; tag[id]+=qv; maxx[id]+=qv; return; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=-1; if(maxx[id]&lt;0) return -1; if(l==r) &#123; if(maxx[id]==0) return l; return -1; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res=query(l,mid,ls); if(res!=-1) return res; if(qr&gt;mid) res=query(mid+1,r,rs); return res; &#125; void build(int _n)&#123;n=_n;build(1,n,1);&#125;&#125;tr;int main()&#123; int n,i,q; ll x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; tr.a[i]=a[i]-bit[i-1]; &#125; tr.build(n); while(q--) &#123; scanf(\"%d%lld\",&amp;tr.ql,&amp;x); tr.qv=x-a[tr.ql]; a[tr.ql]=x; tr.qr=tr.ql; tr.update(1,n,1); tr.qv*=-1; tr.ql++; tr.qr=n; if(tr.ql&lt;=n) tr.update(1,n,1); tr.ql=1; printf(\"%d\\n\",tr.query(1,n,1)); &#125; &#125; return 0;&#125;","path":"2018/06/19/cf489.2E/","date":"06-19","excerpt":""},{"title":"Codeforces Round#489 div2D Nastya and a Game (暴力)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/D 题意：给一个序列和一个k，求有多少个区间，区间积/区间和=k。 题解：满足题目条件的区间中，非1的数字的个数一定不会超过log个。所以先处理出对于每个数，右边第一个非1的数字的位置。枚举区间左端点，每次暴力跳log次，复杂度O(n64)。有两个需要注意的地方：1.当跳过一段1时，这一段1中可能会有满足条件的右端点，但如果只判断（区间积小于上一个右端点的区间和k，且区间积大于等于（上一个右端点的区间和+跳过的1的个数）*k）的话，会wa13。原因是没有判断区间积是否是k的倍数。2.要用除法判断是否爆ll。不然可能会wa15或者wa133。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX],r[MAX];int main()&#123; ll n,k,i,j,nex,now,ans,pre; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; r[i]=i+1; &#125; bit[n+1]=bit[n]; nex=n+1; for(i=n;i&gt;=1;i--) &#123; while(i&gt;=1&amp;&amp;a[i]==1) r[i--]=nex; r[i]=nex; nex=i; &#125; r[n]=n+1; ans=0; for(i=1;i&lt;=n;i++) &#123; // cout&lt;&lt;r[i]&lt;&lt;endl; now=1; pre=i; for(j=i;j&lt;=n+1;j=r[j]) &#123; if(pre!=j&amp;&amp;now%k==0&amp;&amp;(bit[pre]-bit[i-1])*k&lt;now&amp;&amp;(bit[j-1]-bit[i-1])*k&gt;=now) ans++; if(j==n+1) break; if(now&gt;=4e18/a[j]) break; now*=a[j]; if(now==(bit[j]-bit[i-1])*k) ans++; pre=j; if(j==n) break; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; &#125; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/19/cf489.2D/","date":"06-19","excerpt":""},{"title":"Codeforces Round#488 div1E Nikita and Order Statistics (FFT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/E 题意：给一个序列和一个x，求有多少个区间，区间内小于x的数的个数恰好等于k，输出k为[0,n]的所有答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=2e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(ll i=(a);i&lt;=(b);i++) const double pi=acos(-1); const ll p=1e9+7; const ll maxn=1&lt;&lt;20; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],ll k,ll v) &#123; ll i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,ll l1,ll l2,ll n) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]; rep(i,0,n)a[i]=a[n+i]; return; &#125; ll K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,n)a[i]=((ll)(z[n+i].a+0.5)); &#125;&#125;;ll a[MAX],b[MAX],c[MAX&lt;&lt;1];int main()&#123; ll n,i,k; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; a[0]=0; mem(c,0); c[0]=1; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); a[i]=a[i]&lt;k; a[i]+=a[i-1]; c[a[i]]++; &#125; for(i=0;i&lt;=n;i++) &#123; a[i]=b[n-i]=c[i]; c[i]=0; &#125; FFT::mul(c,a,b,n,n,n); c[0]-=n; c[0]/=2; for(i=0;i&lt;=n;i++) printf(\"%lld%c\",c[i],\" \\n\"[i==n]); &#125; return 0;&#125;","path":"2018/06/18/cf488.1E/","date":"06-18","excerpt":""},{"title":"Codeforces Round#488 div2E/div1C Careful Maneuvering (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/C 题意：在一个平面上有两组点。第一组的横坐标为x=-100，并且没有相同的y。第二组的横坐标为x=100，并且没有相同的y。现在要在x=0处放两个点(可以放在同一个坐标上)，对于那两组点，每一组的点都会对这两个点做射线，并可能命中另一组的点。求命中点的个数最大是多少。 题解：那两个点肯定是在第一组的某个点和第二组的某个点的连线上。所以先枚举每一对点(为了避免出现小数，输入的每个点的y先X2)，连线与x=0相交求出交点A。然后每个点对A做射线，如果能命中另一组的点，就状压标记一下这个点和命中的点。这里的复杂度是O(n^3*log(n))。 然后再暴力枚举两个交点，计算一下两个交点总共能命中多少个点，取max即可。状压我用了bitset(可以直接用ll)，这里的复杂度是O(n^5/64)，其实就是O(n^4)。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int n,m,a[111],b[111];hash_map&lt;int,int&gt; aa,bb;bitset&lt;65&gt; aaa[62][62],bbb[62][62];void gao(int x,int ii,int jj)&#123; int i,tmp; for(i=1;i&lt;=n;i++) &#123; tmp=a[i]+2*(x-a[i]); if(bb.count(tmp)) &#123; aaa[ii][jj][i]=1; bbb[ii][jj][bb[tmp]]=1; &#125; &#125; for(i=1;i&lt;=m;i++) &#123; tmp=b[i]+2*(x-b[i]); if(aa.count(tmp)) &#123; aaa[ii][jj][aa[tmp]]=1; bbb[ii][jj][i]=1; &#125; &#125;&#125;int main()&#123; int i,j,ans,ii,jj; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; aa.clear(); bb.clear(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); a[i]*=2; aa[a[i]]=i; &#125; for(i=1;i&lt;=m;i++) &#123; scanf(\"%d\",&amp;b[i]); b[i]*=2; bb[b[i]]=i; &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; aaa[i][j].reset(); bbb[i][j].reset(); gao(max(a[i],b[j])-abs(a[i]-b[j])/2,i,j); &#125; &#125; ans=0; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; for(ii=i;ii&lt;=n;ii++) &#123; for(jj=j;jj&lt;=m;jj++) &#123; ans=max(ans,(int)(aaa[i][j]|aaa[ii][jj]).count()+(int)(bbb[i][j]|bbb[ii][jj]).count()); &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/06/17/cf488.1C/","date":"06-17","excerpt":""},{"title":"Codeforces Round#488 div2C/div1A Two Squares (几何)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/A 题意：给出两个正方形，一个边与坐标轴平行，另一个边与坐标轴成45度角。 判断这两个正方形是否相交。 题解：判断一个正方形的4个顶点是否在另一个正方形内，然后wa8，少考虑了一种情况：对于这种情况，再判断一个正方形的4条边是否与另外一个正方形的4条边有交点即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int sgn(int x)&#123; if(x&gt;0) return 1; if(x&lt;0) return -1; return 0;&#125;struct Point&#123; int x,y; Point()&#123;&#125; Point(int a,int b) &#123; x=a; y=b; &#125; void input() &#123; scanf(\"%d%d\",&amp;x,&amp;y); &#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,double p)&#123;return Vector(a.x*p,a.y*p);&#125; Vector operator /(Vector a,double p)&#123;return Vector(a.x/p,a.y/p);&#125;int cross(Vector a,Vector b)&#123;return a.x*b.y-a.y*b.x;&#125;int dot(Vector a,Vector b)&#123;return a.x*b.x+a.y*b.y;&#125;bool OnSeg(Point p,Point p1,Point p2)&#123; return sgn(cross(p1-p,p2-p))==0&amp;&amp;sgn(dot(p1-p,p2-p))&lt;=0;&#125;int JudgePointInPolygon(Point p,vector&lt;Point&gt; poly)&#123; int cnt,n,k,d1,d2; cnt=0; n=poly.size(); for(int i=0;i&lt;n;i++) &#123; if(OnSeg(p,poly[i],poly[(i+1)%n])) return 1;//在边上 k=sgn(cross(poly[(i+1)%n]-poly[i],p-poly[i])); d1=sgn(poly[i].y-p.y); d2=sgn(poly[(i+1)%n].y-p.y); if(k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) cnt++; if(k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) cnt--; &#125; if(cnt) return 1;//内部 else return 0;//外部 &#125;int JudgeSegInter(Point a,Point b,Point c,Point d)&#123; double t1,t2,t3,t4; t1=cross(b-a,c-a); t2=cross(b-a,d-a); t3=cross(d-c,a-c); t4=cross(d-c,b-c); return sgn(t1)*sgn(t2)&lt;0&amp;&amp;sgn(t3)*sgn(t4)&lt;0;&#125;int main()&#123; Point x; vector&lt;Point&gt; a,b; int i,j,flag=0; for(i=0;i&lt;4;i++) &#123; x.input(); a.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; x.input(); b.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; for(j=0;j&lt;4;j++) &#123; flag|=JudgeSegInter(a[i],a[(i+1)%4],b[j],b[(j+1)%4]); &#125; &#125; for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(a[i],b); for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(b[i],a); flag?puts(\"YES\"):puts(\"NO\"); return 0;&#125;","path":"2018/06/17/cf488.1A/","date":"06-17","excerpt":""},{"title":"(转)【博弈】Anti,Multi,Every-SG","text":"原文：http://blog.sina.com.cn/s/blog_51cea4040100h3l9.html 一、Anti-SG 定义：桌子上有N堆石子，游戏者轮流取石子。 每次只能从一堆中取出任意数目的石子，但不能不取。 取走最后一个石子者败。 因为要求是取走最后一个石子的人败，那么，想赢的人，肯定是想，我就要留一个石子让你去取。 所以，我们在考虑条件的时候，就要加上石子数是不是1这个条件了。当然，还有SG函数本身。 贾志豪发明的SJ定理（Sprague Grundy——Jia Zhihao）解决了这个问题。 SJ定理： 对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束。 先手必胜当且仅当：（1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；（2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。 我们提出定理里的两个限制：1、SG函数为不为0。2、有没有某单一游戏的SG函数大于1。 通过这两个限制，我们可以组合出4种情况： （1）SG==0，有某单一游戏的SG&gt;1。 （2）SG!=0，有某单一游戏的SG&gt;1。（必胜SJ） （3）SG==0，无某单一游戏的SG&gt;1。(必胜SJ) （4）SG!=0，无某单一游戏的SG&gt;1。 对于情况（1）： 当SG==0，存在某单一游戏的SG&gt;1，因为SG==0，所以一定存在至少两个单一游戏的SG&gt;1。而一次操作只能改变一个单一游戏的SG值，那么，操作后，一定到情况（2）。所以情况（1）是先手必败。 对于情况（2）： 当SG!=0时，&lt;1&gt;若只有一个单一游戏的SG&gt;1，我们一定可以通过一次操作，使得剩下的单一游戏一共有奇数个1，这样就先手必胜。&lt;2&gt;若不只一个单一游戏的SG&gt;1，我们可以通过一次操作，使得情况变为SG==0，有某单一游戏的SG&gt;1。对于情况（2）来说，都有子状态是必败状态，所以，情况（2）是先手必胜。 对于情况（3）： 当SG==0，并且没有一单一游戏的SG&gt;1，说明这里只存在偶数个1。如果1的个数为0，则先手必胜。如果1个个数大于0，说明一共有偶数个1，依然是先手必胜。 对于情况（4）： 当SG!=0，无某单一游戏的SG&gt;1，说明现在有奇数个SG==1，操作有两种。 &lt;1&gt;将某一单一游戏的SG值变成大于1，转移后SG依然不等于0，且有一个单一游戏的SG&gt;1，这就到了情况（2）。 &lt;2&gt;将一个SG==1的转移为SG==0，这样就到了情况（3）。 所以情况（4）下是先手必败。 二、Multi-SG 定义：Multi-SG游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。 Multi-SG其他规则与SG游戏相同。 关于这个，如果ccy没理解错，就相当于POI1999/2000的Stripes那题。 http://blog.sina.com.cn/s/blog_51cea4040100h37e.html 三、Every-SG 定义：Every-SG 游戏规定，对于还没有结束的单一游戏，游戏者必须对该游戏进行一步决策。 Every-SG 游戏的其他规则与普通SG 游戏相同。 这种类型，可以想成这样，有N组游戏，有N个穿红色衣服的人代表先手，有N个穿蓝色衣服的人代表后手，这个时候，编号相同的人和游戏分到一组游戏，既第i号穿红色衣服人和第i号穿蓝色衣服的人做第i个游戏。游戏开始后，首先所有穿红衣服的人先操作，然后所有穿蓝色衣服的人再操作，这样轮流下去。直到最后还没游戏完的一组，这组如果是红色衣服的人胜利，那么该游戏先手必胜，如果是蓝色衣服的人胜利，就是先手必败。 很明显，Every-SG不仅仅像其他SG那样仅仅跟SG值有关，还与一个游戏的时间长度有关。 如果先手想赢，那么，在做先手必胜的单一游戏时，他肯定是想把战线尽量拉长。在做先手必败的单一游戏时，他肯定是想把游戏尽快结束。 于是我们开一个Step数组。 表示对于先手必胜的单一游戏而言，它最少走好多步胜利。对于先手必败的单一游戏而言，它最多走好多步。 这样，我们只需要看最后所有单一游戏最大的step那组的SG是0还是非0就可以断定是否先手必胜了。 很容易得出： （u是v的子状态） step[v] = 0； （v为终止状态） step[v] = max{step[u]} + 1； （sg[v]&gt;0,sg[u]=0） step[v] = min{step[u]} + 1； （sg[v]==0） 现在需要证明两个东西： （1）先手必胜，step表示的是最少走好多步。 （2）先手必败，step表示的是最多走好多步。 证明（1）： 对于v点，先手必胜。先手总是从sg&gt;1的到sg==0，他可以保证自己每次减少的步数为1。对手每次是从sg==0到sg&gt;1，最少将步数减小1，既对方走的min值所取的结点，如果选其他的，步数反而到那步后还要增加。所以，先手必胜，step表示的是最少走好多步。 （反起想，这也是为什么step第三个递推式是用min的原因。） 证明（2）： 对于v点，先手必败。先手总是从sg==0到sg&gt;1，他可以保证自己每次减少的步数为1。对手每次是从sg&gt;1到sg==0，对手肯定想让战线拉长，那么他只让步数减少1.所以，先手必败，step表示的是最多走好多步。 这里，式子的推导和证明柔和起来看更有利于理解。 值得注意理解的是，这里的最多和最少并不是绝对的最多最少。 对于（1）（2）而言，都是先手保证自己的操作后，看对手操作而决定最多最少。 而这里的最多最少正好等于step也是我们强制先手每次只减少步数1而得来的。 不过，我们是先手嘛，当然可以多个脑壳决定自己了！！！ 贾志豪在证Every-SG时，多证明了一条，就是最大的step为奇数时必胜。 ccy觉得这个虽然好证明，但是何必呢？最多step的那个单一游戏判断下它的SG是不是为0不就可以了吗？ 关于step为奇这个，也说一下。 最终状态，sg[v]==0，step[v]==0，为偶。 每个sg[v]!=0的step是由sg[u]==0的step[u]加上1得到，所以为奇。 每个sg[v]==0的step是由下面sg[u]!=0的step[u]加上1得到，所以为偶。 所以，sg[v]!=0的，step为奇。","path":"2018/06/15/(转)【博弈】Anti,Multi,Every-SG/","date":"06-15","excerpt":""},{"title":"2018ICPC西安邀请赛","text":"转载请注明出处：http://tokitsukaze.live/ 西安公费旅游，住在乡下，住宿体验极差，水是黄的床是脏的马桶还能堵，再也不想来了....然后比赛，A题题目错的(知乎见.jpg)，E和A签完到，K看错题意拍上线段树wa，然后发现D是sg板子题，抄完板子1A，然后又发现G是几何，抄完板子1A(幸好没卡精度)，然后看榜发现在金牌区，而且C和K感觉都能过。然后两个队友yy了K的分块解法，一屁股坐上来就再也没下去过，最后wa还不知道哪写错了。期间我看完I感觉不好做，去看过的人多的C。然后贪心贪到封榜，怎么贪感觉都有反例，这时候我觉得肯定是dp，甩锅给队友，队友不接锅...结果赛后队友一眼秒了emmmmm终榜：http://acm.nwpu.edu.cn/static/frontpage/board/index.html..","path":"2018/05/20/2018ICPCxian/","date":"05-20","excerpt":""},{"title":"2018浙江省赛","text":"转载请注明出处：http://tokitsukaze.live/ 这省赛是打的最气的一次现场赛。开场1小时过完5个签到题，感觉顺的一逼。接着开了两个新题。我开的那道题很快就有了正解，然后一敲，TLE。仔细想想是n*log(n)^2的复杂度，肯定会TLE，于是一直在思考怎么抠掉一个log。zyf和chy开了一道dp(贪心)，一直在搞。然后讨论的差不多了(?)chy就开了个新题，是个构造题，没啥想法，扔了。期间我想不出怎么抠掉那个log，跟队友讲了一下思路，也都没啥想法，然后zyf那个题也是各种WA，于是就陷入僵局。然后chy开了一个大模拟，又是WA到死。因为我不怎么会dp，无法参与zyf的题，我也不会麻将()，无法参与chy的题，于是只能死磕我的题。所以接下来的场景就是，我坐上去改改，TLE，zfy上去改改，WA，chy上去改改，WA。然后就结束了。也就是说，开场过了5个签到后，3个人开始进入梦游状态，然后最后打铁了。 气的原因最主要是，回来一搜题解，发现全是n*log(n)^2的复杂度。几天后py了zoj的管理员，把现场赛我的TLE的代码贴出来，居然AC了！！！而且还是跑的飞快的那种，woc瞬间被气的半死，只能说可能zoj的数据比现场赛的数据弱。然后大概15天后突然想出怎么抠掉那个log...只能怪自己菜了。 直到这场，连着打了3个铁(CCPC杭州，ECL，浙江省赛)，心态略崩TAT。 榜：http://acm.zju.edu.cn/zjp2018/board/index.html?filter=type1","path":"2018/04/30/2018zhejiangshengsai/","date":"04-30","excerpt":""},{"title":"「艦これ」2018三月作戦rank13","text":"转载请注明出处：http://tokitsukaze.live/","path":"2018/04/28/KancolleSenka2018.03/","date":"04-28","excerpt":""},{"title":"「艦これ」「2018冬」捷号決戦！邀撃、レイテ沖海戦(後篇)","text":"转载请注明出处：http://tokitsukaze.live/ ——————————————————E7——————————————————「E7P1斩杀」 「E7P2斩杀」 —————————————————完结撒花—————————————————","path":"2018/02/24/KancolleInvent2018winter/","date":"02-24","excerpt":""},{"title":"2017ICPC上海ECL-Final","text":"转载请注明出处：http://tokitsukaze.live/ 在杭州ccpc区域赛丢人后，这次又去上海ECL-final丢人了。换了个队友。第一天热身赛，编译器炸了一个多小时...体验极差。然后发的里面有80元的饭卡，吃了两餐剩50多，于是晚上去洗劫超市，提了一袋吃的回来...第二天正式赛，我从前往后读题，zyf从后往前，chy开编译器。A题排列组合，翻了一下数学手册，理论AC，上去打了一发假代码，贡献了一发罚时。这时候chy上来切掉了M。然后换我改了改A，过了。然后他们告诉我K读不懂，我接手K。他们L（是个博弈题）推了一波，打了一发，WA。这时候我看懂了K，想了想不就是二分一下前缀和，上来打了一发，超时，又贡献了一发罚时。这时候我发现我把n范围1e9看成了1e5，加了个条件break，过了。然后让我接手L，他们看J。我推了20分钟，放弃（博弈实在不行），他们J也陷入僵局。我看了一下榜，决定开B，让他们开C。然后我瞎打了一发B，没过案例，被chy抢走键盘，莽了一发C，WA。跟chy说了一下B，纠正了思路，我继续调B。然后案例过了，莽了一发，WA。这时候chy又莽来一发C，AC。这时已经快封榜了，我和chy继续搞B，zyf想J。最后半小时，chy改了改B，WA。换zyf打J，WA。又换chy改了改B，又WA，接着又换zyf改了改J，又WA。于是最后4题打铁。赛后题解，B大体思路对，不知道哪有问题。J最开始方向也是对的，但是没有细想很快就被枪毙掉了。L这个博弈，结论对了一半，要是暴力一发找规律，说不定能过。只能怪自己太菜（他们怎么都会啊...）。不过毕竟是final，虽然参赛队比较多，但牌也不是那么好拿的。然后就是，上海大学真tm有钱，还有这个狗牌也做的相当不错（甚至还能用来洗劫超市，emmmm）。PS:丢人丢到gym上了榜：http://codeforces.com/gym/101775/standings","path":"2017/12/17/2017ICPCshanghaiECL-Final/","date":"12-17","excerpt":""},{"title":"2017CCPC杭州赛区","text":"转载请注明出处：http://tokitsukaze.live/ 第一次区域赛，杭州赛区丢人打铁，被数学题按在地上摩擦。起手慢了，队友16分钟过了A，然后分别看BCD，过了一会儿系统提示J案例翻车要重判，看了一眼发现提交了一堆人，看了一下题，跟队友讨论了两分钟，我上去切了，在51分钟过了J。然后B要用到欧拉函数，我拍了个板子上去给队友找规律，D是随机构造树，随机一个节点求子树节点和的期望，直觉可做，就去看D。推了半小时D，上来打了10几分钟，在120分钟切了D，期间队友在讨论C，是个博弈。然后队友C写了个假算法wa了一发后接着推B，我接手C。C陷入僵局，看了眼K，直觉二分或者三分，但是有个式子不会处理，放弃K继续想C（赛后据说K是树状数组+二分答案）。然后继续陷入僵局。240分钟左右，B稍微有点成型，队友瞎敲一波，我帮忙debug。在280分钟过了案例，然后tle了..赛后出来交流了一波，思路没错，可惜没时间优化，最后3题首离铜线差6名...","path":"2017/11/05/2017CCPChangzhou/","date":"11-05","excerpt":""},{"title":"2017宁波市市赛","text":"转载请注明出处：http://tokitsukaze.live/ A忘longlong C忘特判n=1 Ewa几发 GwaN发 唯一一道1A的J bfs水过（我的首A 不！！.jgp） 然后最后翻车在F上 算了一下罚时好像就算A出来也拿不到银 （强行安慰） 保铜冲银 最终还是咸鱼...","path":"2017/05/13/2017ningboshisai/","date":"05-13","excerpt":""},{"title":"2017浙江大学校赛","text":"转载请注明出处：http://tokitsukaze.live/ 公费旅游+骗吃骗喝+日常翻车 1小时a掉2题 然后C题我的思路太繁琐了 强行分类讨论 打一半就不想打然后队友接盘 然后我去看G wa了一发发现思路不对 然后其他题又不是很好做 于是三个人就开始肛C 然后各种翻车...学了两个月算法结果在xjb搞的题上翻车..人生如此艰难.jpg","path":"2017/04/09/2017ZJUxiaosai/","date":"04-09","excerpt":""},{"title":"「艦これ」2017一月作戦rank20","text":"转载请注明出处：http://tokitsukaze.live/","path":"2017/02/25/KancolleSenka2017.01/","date":"02-25","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2016/09/23/hello-world/","date":"09-23","excerpt":""}]}