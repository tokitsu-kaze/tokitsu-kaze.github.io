{"meta":{"title":"tokitsukaze","subtitle":null,"description":null,"author":"tokitsukaze","url":"http://tokitsukaze.live"},"pages":[{"title":"404","date":"2018-06-14T02:32:59.000Z","updated":"2018-06-14T02:32:59.333Z","comments":true,"path":"404/index.html","permalink":"http://tokitsukaze.live/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-02T04:33:16.000Z","updated":"2018-06-13T15:35:22.073Z","comments":true,"path":"categories/index.html","permalink":"http://tokitsukaze.live/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-14T02:32:40.000Z","updated":"2018-06-14T02:32:40.515Z","comments":true,"path":"search/index.html","permalink":"http://tokitsukaze.live/search/index.html","excerpt":"","text":""}],"posts":[{"title":"NIT 453 相似字符串(hash)","slug":"NIT 453 相似字符串(hash)","date":"2018-06-13T16:52:35.216Z","updated":"2018-06-13T17:07:50.108Z","comments":true,"path":"2018/06/14/NIT 453 相似字符串(hash)/","link":"","permalink":"http://tokitsukaze.live/2018/06/14/NIT 453 相似字符串(hash)/","excerpt":"","text":"https://www.nitacm.com/problem_show.php?pid=453 相似字符串 狗风获得了一个长度为n，由a-z小写字母组成的字符串。 我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。 操作是这样的：选择一个字符串，把字符串的每个字母都+1(例如‘a’变成‘b’，’z’变成’a’)。比如选择“acdz”，操作一次后变为“bdea”。 现在狗风从字符串中任取两个子串，狗风想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤105)，表示字符串长度。 第二行包括一个长度为n的字符串。 接下来一行包括一个正整数q(1≤q≤105)，表示询问次数。 接下来q行，每行包括3个正整数x，y，len。(1≤x，y≤n)，(1≤len≤n并且1≤x+len-1，y+len-1≤n)。表示查询子串[x…x+len-1]和子串[y…y+len-1]。 n=105，q=105的数据大约有10组。 Output对于每个查询，输出一行，表示答案。 Sample Input10aabbcdedcz41 3 22 6 24 6 41 10 1 Sample Output13-11 Hint第一个查询的子串为“aa”和“bb”，“aa”变为“bb”需要1次操作，所以相似度为1。 第二个查询的子串为“ab”和“cd”，“ab”变为“cd”需要3次操作，所以相似度为3。 第三个查询的子串为“bcde”和“dedc”，“bcde”不能变为“dedc”，所以两个字符串不相似，输出-1。 第四个查询的子串为“a”和“z”，“z”变为“a”需要1次操作，所以相似度为1。 Source2017级新生选拔#4 Authortokitsukaze 题解： 预处理：对这个字符串的26种变化做hash。 查询：用差分的方式取出y子串的hash值，然后取出x子串26种变化的hash值，判断有没有一种变化能使x子串的hash值等于y子串的hash值，如果有，假设是第i种变化，那么答案就是min(i,26-i)，如果没有，答案就是-1。 代码： 这里给出双hash的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct hash_table&#123; ll seed,p; ll Hash[26][MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;26;j++) &#123; Hash[j][i]=(Hash[j][i-1]*seed%p+(s[i]-&apos;a&apos;+j)%26)%p; &#125; &#125; &#125; ll get(int l,int r,int id) &#123; return (Hash[id][r]-Hash[id][l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;ha[2];char s[MAX];int main()&#123; int n,i,q,x,y,len,ans; ll tmp; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; assert(n&gt;=1&amp;&amp;n&lt;=100000); scanf(&quot; %[a-z]&quot;,s+1); assert(strlen(s+1)==n); ha[0].set(233333,1e9+7); ha[1].set(19260817,998244353); for(i=0;i&lt;2;i++) ha[i].work(s,n); scanf(&quot;%d&quot;,&amp;q); assert(q&gt;=1&amp;&amp;q&lt;=100000); while(q--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); assert(len&gt;=1); assert(x&gt;=1&amp;&amp;x+len-1&lt;=n); assert(y&gt;=1&amp;&amp;y+len-1&lt;=n); vector&lt;int&gt; res; ans=INF; tmp=ha[0].get(y,y+len-1,0); for(i=0;i&lt;26;i++) if(ha[0].get(x,x+len-1,i)==tmp) res.pb(i); tmp=ha[1].get(y,y+len-1,0); for(i=0;i&lt;sz(res);i++) &#123; if(ha[1].get(x,x+len-1,res[i])==tmp) &#123; ans=min(ans,res[i]); ans=min(ans,26-res[i]); &#125; &#125; if(ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0;&#125;","categories":[{"name":"hash","slug":"hash","permalink":"http://tokitsukaze.live/categories/hash/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-06-13T09:36:32.108Z","updated":"2018-06-13T15:39:06.616Z","comments":true,"path":"2018/06/13/hello-world/","link":"","permalink":"http://tokitsukaze.live/2018/06/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"http://tokitsukaze.live/categories/Other/"}],"tags":[]}]}