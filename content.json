{"pages":[{"title":"Game","text":"","path":"Game/index.html","date":"06-20","excerpt":""},{"title":"message","text":"","path":"about/index.html","date":"09-23","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"06-14","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-14","excerpt":""}],"posts":[{"title":"Codeforces Round#489 div2E Nastya and King-Shamans (线段树+暴力剪枝)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/E 题意：给一个序列a，q次操作。每次操作单点修改。每次操作后，询问序列a中有没有一个位置满足a[i]=bit[i-1]，如果有，随便输出一个位置，如果没有输出-1。其中bit为前缀和数组。 题解：容易想到建立线段树维护a[i]-bit[i-1]，问题就转化成查询线段树内值为0的位置。记录一个区间最大值maxx，查询时，如果这个区间maxx小于0，说明这个区间内的数全都不满足，直接剪枝，否则一直查询到叶子节点。 看上去很暴力，其实想想是可行的。因为如果要避开这个剪枝，a[i]-bit[i-1]必须大于0（如果等于0的话，也能很快走到叶子节点），那么这个序列假设a[1]=0，那么a[1]就至少为1，a[2]至少为2，a[3]至少为4，以此类推。也就是说，最多走过log个叶子节点，一定能得出答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX];struct Segment_Tree&#123; #define ls (id&lt;&lt;1) #define rs (id&lt;&lt;1|1) int n,ql,qr; ll a[MAX],tag[MAX&lt;&lt;2],maxx[MAX&lt;&lt;2],qv; void pushup(int id) &#123; maxx[id]=max(maxx[ls],maxx[rs]); &#125; void pushdown(int id) &#123; if(!tag[id]) return; maxx[ls]+=tag[id]; maxx[rs]+=tag[id]; tag[ls]+=tag[id]; tag[rs]+=tag[id]; tag[id]=0; &#125; void build(int l,int r,int id) &#123; tag[id]=0; maxx[id]=0; if(l==r) &#123; maxx[id]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); pushup(id); &#125; void update(int l,int r,int id) &#123; if(l&gt;=ql&amp;&amp;r&lt;=qr) &#123; tag[id]+=qv; maxx[id]+=qv; return; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) update(l,mid,ls); if(qr&gt;mid) update(mid+1,r,rs); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=-1; if(maxx[id]&lt;0) return -1; if(l==r) &#123; if(maxx[id]==0) return l; return -1; &#125; pushdown(id); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res=query(l,mid,ls); if(res!=-1) return res; if(qr&gt;mid) res=query(mid+1,r,rs); return res; &#125; void build(int _n)&#123;n=_n;build(1,n,1);&#125;&#125;tr;int main()&#123; int n,i,q; ll x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; tr.a[i]=a[i]-bit[i-1]; &#125; tr.build(n); while(q--) &#123; scanf(\"%d%lld\",&amp;tr.ql,&amp;x); tr.qv=x-a[tr.ql]; a[tr.ql]=x; tr.qr=tr.ql; tr.update(1,n,1); tr.qv*=-1; tr.ql++; tr.qr=n; if(tr.ql&lt;=n) tr.update(1,n,1); tr.ql=1; printf(\"%d\\n\",tr.query(1,n,1)); &#125; &#125; return 0;&#125;","path":"2018/06/19/cf489.2E/","date":"06-19","excerpt":""},{"title":"Codeforces Round#489 div2D Nastya and a Game (暴力)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/992/D 题意：给一个序列和一个k，求有多少个区间，区间积/区间和=k。 题解：满足题目条件的区间中，非1的数字的个数一定不会超过log个。所以先处理出对于每个数，右边第一个非1的数字的位置。枚举区间左端点，每次暴力跳log次，复杂度O(n64)。有两个需要注意的地方：1.当跳过一段1时，这一段1中可能会有满足条件的右端点，但如果只判断（区间积小于上一个右端点的区间和k，且区间积大于等于（上一个右端点的区间和+跳过的1的个数）*k）的话，会wa13。原因是没有判断区间积是否是k的倍数。2.要用除法判断是否爆ll。不然可能会wa15或者wa133。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;#define VI vector&lt;int&gt;#define VL vector&lt;ll&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=2e5+10;const ll mod=998244353;ll a[MAX],bit[MAX],r[MAX];int main()&#123; ll n,k,i,j,nex,now,ans,pre; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; bit[0]=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); bit[i]=bit[i-1]+a[i]; r[i]=i+1; &#125; bit[n+1]=bit[n]; nex=n+1; for(i=n;i&gt;=1;i--) &#123; while(i&gt;=1&amp;&amp;a[i]==1) r[i--]=nex; r[i]=nex; nex=i; &#125; r[n]=n+1; ans=0; for(i=1;i&lt;=n;i++) &#123; // cout&lt;&lt;r[i]&lt;&lt;endl; now=1; pre=i; for(j=i;j&lt;=n+1;j=r[j]) &#123; if(pre!=j&amp;&amp;now%k==0&amp;&amp;(bit[pre]-bit[i-1])*k&lt;now&amp;&amp;(bit[j-1]-bit[i-1])*k&gt;=now) ans++; if(j==n+1) break; if(now&gt;=4e18/a[j]) break; now*=a[j]; if(now==(bit[j]-bit[i-1])*k) ans++; pre=j; if(j==n) break; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; &#125; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/19/cf489.2D/","date":"06-19","excerpt":""},{"title":"Codeforces Round#488 div1E Nikita and Order Statistics (FFT)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/E 题意：给一个序列和一个x，求有多少个区间，区间内小于x的数的个数恰好等于k，输出k为[0,n]的所有答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=2e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(ll i=(a);i&lt;=(b);i++) const double pi=acos(-1); const ll p=1e9+7; const ll maxn=1&lt;&lt;20; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],ll k,ll v) &#123; ll i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,ll l1,ll l2,ll n) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]; rep(i,0,n)a[i]=a[n+i]; return; &#125; ll K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,n)a[i]=((ll)(z[n+i].a+0.5)); &#125;&#125;;ll a[MAX],b[MAX],c[MAX&lt;&lt;1];int main()&#123; ll n,i,k; while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; a[0]=0; mem(c,0); c[0]=1; for(i=1;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a[i]); a[i]=a[i]&lt;k; a[i]+=a[i-1]; c[a[i]]++; &#125; for(i=0;i&lt;=n;i++) &#123; a[i]=b[n-i]=c[i]; c[i]=0; &#125; FFT::mul(c,a,b,n,n,n); c[0]-=n; c[0]/=2; for(i=0;i&lt;=n;i++) printf(\"%lld%c\",c[i],\" \\n\"[i==n]); &#125; return 0;&#125;","path":"2018/06/18/cf488.1E/","date":"06-18","excerpt":""},{"title":"Codeforces Round#488 div2E/div1C Careful Maneuvering (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/C 题意：在一个平面上有两组点。第一组的横坐标为x=-100，并且没有相同的y。第二组的横坐标为x=100，并且没有相同的y。现在要在x=0处放两个点(可以放在同一个坐标上)，对于那两组点，每一组的点都会对这两个点做射线，并可能命中另一组的点。求命中点的个数最大是多少。 题解：那两个点肯定是在第一组的某个点和第二组的某个点的连线上。所以先枚举每一对点(为了避免出现小数，输入的每个点的y先X2)，连线与x=0相交求出交点A。然后每个点对A做射线，如果能命中另一组的点，就状压标记一下这个点和命中的点。这里的复杂度是O(n^3*log(n))。 然后再暴力枚举两个交点，计算一下两个交点总共能命中多少个点，取max即可。状压我用了bitset(可以直接用ll)，这里的复杂度是O(n^5/64)，其实就是O(n^4)。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int n,m,a[111],b[111];hash_map&lt;int,int&gt; aa,bb;bitset&lt;65&gt; aaa[62][62],bbb[62][62];void gao(int x,int ii,int jj)&#123; int i,tmp; for(i=1;i&lt;=n;i++) &#123; tmp=a[i]+2*(x-a[i]); if(bb.count(tmp)) &#123; aaa[ii][jj][i]=1; bbb[ii][jj][bb[tmp]]=1; &#125; &#125; for(i=1;i&lt;=m;i++) &#123; tmp=b[i]+2*(x-b[i]); if(aa.count(tmp)) &#123; aaa[ii][jj][aa[tmp]]=1; bbb[ii][jj][i]=1; &#125; &#125;&#125;int main()&#123; int i,j,ans,ii,jj; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; aa.clear(); bb.clear(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); a[i]*=2; aa[a[i]]=i; &#125; for(i=1;i&lt;=m;i++) &#123; scanf(\"%d\",&amp;b[i]); b[i]*=2; bb[b[i]]=i; &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; aaa[i][j].reset(); bbb[i][j].reset(); gao(max(a[i],b[j])-abs(a[i]-b[j])/2,i,j); &#125; &#125; ans=0; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; for(ii=i;ii&lt;=n;ii++) &#123; for(jj=j;jj&lt;=m;jj++) &#123; ans=max(ans,(int)(aaa[i][j]|aaa[ii][jj]).count()+(int)(bbb[i][j]|bbb[ii][jj]).count()); &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","path":"2018/06/17/cf488.1C/","date":"06-17","excerpt":""},{"title":"Codeforces Round#488 div2C/div1A Two Squares (几何)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：http://codeforces.com/problemset/problem/993/A 题意：给出两个正方形，一个边与坐标轴平行，另一个边与坐标轴成45度角。 判断这两个正方形是否相交。 题解：判断一个正方形的4个顶点是否在另一个正方形内，然后wa8，少考虑了一种情况：对于这种情况，再判断一个正方形的4条边是否与另外一个正方形的4条边有交点即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int sgn(int x)&#123; if(x&gt;0) return 1; if(x&lt;0) return -1; return 0;&#125;struct Point&#123; int x,y; Point()&#123;&#125; Point(int a,int b) &#123; x=a; y=b; &#125; void input() &#123; scanf(\"%d%d\",&amp;x,&amp;y); &#125;&#125;;typedef Point Vector;Vector operator +(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125; Vector operator -(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125; Vector operator *(Vector a,double p)&#123;return Vector(a.x*p,a.y*p);&#125; Vector operator /(Vector a,double p)&#123;return Vector(a.x/p,a.y/p);&#125;int cross(Vector a,Vector b)&#123;return a.x*b.y-a.y*b.x;&#125;int dot(Vector a,Vector b)&#123;return a.x*b.x+a.y*b.y;&#125;bool OnSeg(Point p,Point p1,Point p2)&#123; return sgn(cross(p1-p,p2-p))==0&amp;&amp;sgn(dot(p1-p,p2-p))&lt;=0;&#125;int JudgePointInPolygon(Point p,vector&lt;Point&gt; poly)&#123; int cnt,n,k,d1,d2; cnt=0; n=poly.size(); for(int i=0;i&lt;n;i++) &#123; if(OnSeg(p,poly[i],poly[(i+1)%n])) return 1;//在边上 k=sgn(cross(poly[(i+1)%n]-poly[i],p-poly[i])); d1=sgn(poly[i].y-p.y); d2=sgn(poly[(i+1)%n].y-p.y); if(k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) cnt++; if(k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) cnt--; &#125; if(cnt) return 1;//内部 else return 0;//外部 &#125;int JudgeSegInter(Point a,Point b,Point c,Point d)&#123; double t1,t2,t3,t4; t1=cross(b-a,c-a); t2=cross(b-a,d-a); t3=cross(d-c,a-c); t4=cross(d-c,b-c); return sgn(t1)*sgn(t2)&lt;0&amp;&amp;sgn(t3)*sgn(t4)&lt;0;&#125;int main()&#123; Point x; vector&lt;Point&gt; a,b; int i,j,flag=0; for(i=0;i&lt;4;i++) &#123; x.input(); a.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; x.input(); b.pb(x); &#125; for(i=0;i&lt;4;i++) &#123; for(j=0;j&lt;4;j++) &#123; flag|=JudgeSegInter(a[i],a[(i+1)%4],b[j],b[(j+1)%4]); &#125; &#125; for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(a[i],b); for(i=0;i&lt;4;i++) flag|=JudgePointInPolygon(b[i],a); flag?puts(\"YES\"):puts(\"NO\"); return 0;&#125;","path":"2018/06/17/cf488.1A/","date":"06-17","excerpt":""},{"title":"NIT 436 C=A+B (数学)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=436 C=A+B C=A+B。其中C为正偶数，A与B都是素数。 现在给你一个C，让你求出A和B，如果有多种答案，输出任意一种即可，如果不能求出A和B，请输出”-1”(不带引号)。 Input多组数据。 对于每组数据，第一行包括一个正偶数C(2≤C≤10^9)。 Output对于每组数据，如果能求出A和B，请按C=A+B的形式输出，如果不能，请输出”-1”(不带引号)。 Sample Input1046666 Sample Output10=3+746666=23333+23333 Source2017级新生选拔#3 Authortokitsukaze 题解：由哥德巴赫猜想可知，C&gt;2必有解。所以我们特判C=2的情况，然后枚举其中一个素数A，判断B=C-A是不是素数，很容易就能求出一组解。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int prime[MAX];vector&lt;int&gt; p;void init(int n)&#123; int i,j; mem(prime,0); p.clear(); for(i=2;i&lt;=n;i++) &#123; if(prime[i]) continue; p.pb(i); for(j=i+i;j&lt;=n;j+=i) &#123; if(!prime[j]) prime[j]=i; &#125; &#125;&#125;int check(int x)&#123; int i; if(x&lt;2) return 0; for(i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125;int main()&#123; init(sqrt(1e9)); int i,a,b,n; while(~scanf(\"%d\",&amp;n)) &#123; if(n==2) &#123; puts(\"-1\"); continue; &#125; for(i=0;i&lt;sz(p);i++) &#123; if(check(n-p[i])) &#123; a=p[i]; b=n-p[i]; break; &#125; &#125; printf(\"%d=%d+%d\\n\",n,a,b); &#125; return 0;&#125;/*//数据构造 ull llrand()&#123; return ( (((ull)rand()&lt;&lt;24)&amp;0xFF000000ul)| (((ull)rand()&lt;&lt;12)&amp;0x00FFF000ul)| (((ull)rand() )&amp;0x00000FFFul));&#125;int main()&#123; int cas; ll x; char s[111]; mem(s,0); srand(time(0)); for(cas=1;cas&lt;=100;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x=1; while((x&amp;1)&amp;&amp;x&lt;=2) x=llrand()%(mod-7); printf(\"%lld\\n\",x); &#125; x=0; for(cas=101;cas&lt;=150;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x+=2; printf(\"%lld\\n\",x); &#125; for(cas=151;cas&lt;=151;cas++) &#123; sprintf(s,\"%03d\",cas); strcpy(s+strlen(s),\".in\"); freopen(s,\"w\",stdout); x=mod-7; printf(\"%lld\\n\",x); &#125; return 0;&#125;*//*//特判程序char IN_FILE[20];char OUT_FILE[20];char USER_ANS[20];char USER_SRC[20];int check(int x)&#123; int i; if(x&lt;2) return 0; for(i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125;int main()&#123; gets(IN_FILE); //输入数据的文件名 gets(OUT_FILE); //标准输出的文件名 gets(USER_ANS); //用户输出的文件名 gets(USER_SRC); //用户源程序的文件名 FILE *IN=fopen(IN_FILE,\"r\"); FILE *OUT=fopen(OUT_FILE,\"r\"); FILE *USER=fopen(USER_ANS,\"r\"); int i,a,b,c,n; char tmp[1111]; fscanf(IN,\"%d\",&amp;n); if(n==2) &#123; fscanf(USER,\"%s\",tmp); return !(strlen(tmp)==2&amp;&amp;tmp[0]=='-'&amp;&amp;tmp[1]=='1'); &#125; c=a=b=0; fscanf(USER,\"%d=%d+%d\",&amp;c,&amp;a,&amp;b); fclose(IN); fclose(USER); if(c&lt;=0||a&lt;=0||b&lt;=0) return 1; if(c!=n) return 1; if(c!=a+b) return 1; if(!check(a)) return 1; if(!check(b)) return 1; return 0;&#125;*/","path":"2018/06/16/NIT436/","date":"06-16","excerpt":""},{"title":"NIT 442 Patrol (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=442 Patrol GF市分为n个区域，编号为1-n。有m个警察在这些区域巡逻，编号为1-m，第i个警察的巡逻区域编号为L[i]，R[i]。巡逻区域可能会有重叠。假设有一个警察请假，这n个区域中，有多少个区域没有警察巡逻。 Input第一行包括一个正整数T(T≤30)，表示T个案例。 对于每个案例： 第一行包括两个正整数n，m(1≤n，m≤10^5)。 接下来m行，每行包括两个正整数L[i]，R[i] (1≤L[i]≤R[i]≤n)。 Output对于每个案例： 第一行输出Case #x:（x表示第i组案例(i从1开始)）。 第二行输出m个整数，每个整数用空格隔开，行末无多余空格。第i个整数表示：若编号为i的警察请假，有多少个区域没有警察巡逻。(1≤i≤m) Sample Input35 31 34 53 46 21 24 59 42 93 44 51 4 Sample OutputCase #1:2 1 0Case #2:4 4Case #3:4 0 0 1 Hint第一个案例： 若编号为1的警察请假，区域1和区域2没有警察巡逻。 若编号为2的警察请假，区域5没有警察巡逻。 若编号为3的警察请假，每个区域还是有至少一个警察巡逻。 第二个案例： 若编号为1的警察请假，区域1、区域2、区域3、区域6没有警察巡逻。 若编号为2的警察请假，区域3、区域4、区域5、区域6没有警察巡逻。 Source2017级新生选拔#3 Authortokitsukaze 题解：先做个前缀和，记录被覆盖的点的个数为sum，再对只被覆盖到一次的点再做前缀和，每次撤销一条线段后的答案就是sum-这条线段内只被覆盖到一次的点的个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int bit[MAX],w[MAX];PII a[MAX];int main()&#123; int n,m,i,j,ans,t,cas=1; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;m); mem(bit,0); mem(w,0); ans=0; for(i=1;i&lt;=m;i++) &#123; scanf(\"%d%d\",&amp;a[i].fi,&amp;a[i].se); bit[a[i].fi]++; bit[a[i].se+1]--; &#125; for(i=1;i&lt;=n;i++) &#123; bit[i]+=bit[i-1]; if(bit[i]) ans++; if(bit[i]==1) w[i]++; w[i]+=w[i-1]; &#125; ans=n-ans; printf(\"Case #%d:\\n\",cas++); for(i=1;i&lt;=m;i++) printf(\"%d%c\",ans+w[a[i].se]-w[a[i].fi-1],\" \\n\"[i==m]); &#125; return 0;&#125;","path":"2018/06/16/NIT442/","date":"06-16","excerpt":""},{"title":"NIT 443 Another Stone Game (sg函数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=443 Another Stone Game 狗风(tokitsukaze)和雪亲王(yukikaze)正在玩一个游戏。有n堆石子，每次可以任选一堆拿。假设你选择的那一堆现在有x个石子，那么你可以拿走： (1) 1个石子。 (2) x个石子。 (3) x的质因数个石子。 两个人轮流拿，狗风先手，每一轮必须拿，最后拿完的人输，问谁有必胜策略。 Input多组数据。 对于每组数据： 第一行包括一个正整数n(1≤n≤10^5)。表示n堆石子 接下来一行包括n个正整数x[i]，(1≤x[i]≤10^5)。表示第i堆有x[i]个石子。 Output如果狗风能赢，输出”tokitsukaze”(不带双引号)。 否则输出”yukikaze”(不带双引号)。 Sample Input21 134 1 11316 Sample Outputtokitsukazetokitsukazeyukikazetokitsukaze Hint第一个样例：因为每堆只有1个石子，狗风先任选一堆拿完，雪亲王必须拿完剩下的一堆，所以狗风必胜。 第二个样例：第一堆有4个石子，如果选第一堆，可以拿走1、2或者4个石子。狗风先手拿走第一堆的1个石子，不管雪亲王怎么拿，狗风必胜。 第三个样例：第一堆有3个石子，如果选第一堆，可以拿走1或者3个石子。狗风如果直接拿走3个石子，狗风就输了，所以狗风不得不拿1个石子。这时候只剩2个石子，可以拿走1或者2个石子。雪亲王可以拿走1个石子，剩下1个石子。到狗风的回合，因为狗风必须拿，所以狗风必输。 第四个样例：第一堆有6个石子，如果选第一堆，可以拿走1、2、3或者6个石子。狗风先手拿走3个石子，剩下3个石子，可以拿走1或者3个石子。雪亲王如果拿走3个石子，她就输了，所以她不得不只拿走1个石子，剩下2个石子。狗风拿走1个石子，剩下一个石子，所以雪亲王必败，狗风必胜。 Source2017级新生选拔#3 Authortokitsukaze 题解：这是一个Anti-SG。先求出sg表，然后运用sj定理。注意尽量优化质因数分解，不然可能会TLE。 关于Anti-SG，请看这里：http://tokitsukaze.live/2018/06/15/(%E8%BD%AC)%E3%80%90%E5%8D%9A%E5%BC%88%E3%80%91Anti,Multi,Every-SG/ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int prime[MAX];vector&lt;int&gt; p;void init(int n)&#123; int i,j; mem(prime,0); p.clear(); for(i=2;i&lt;=n;i++) &#123; if(prime[i]) continue; p.pb(i); for(j=i+i;j&lt;=n;j+=i) &#123; if(!prime[j]) prime[j]=i; &#125; &#125;&#125;vector&lt;int&gt; res;void work(int x)&#123; int t; res.clear(); res.pb(1); while(x&gt;1) &#123; t=prime[x]; if(!t) &#123; res.pb(x); return; &#125; while(x%t==0&amp;&amp;x&gt;1) x/=t; res.pb(t); &#125;&#125;int sg[MAX];void SG(int n)&#123; int i,j,flag[4]; mem(sg,0); for(i=1;i&lt;=n;i++) &#123; mem(flag,0); work(i); res.pb(i); for(j=0;j&lt;sz(res);j++) &#123; flag[sg[i-res[j]]]=1; &#125; for(j=0;;j++) &#123; if(!flag[j]) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125;int x[MAX];int main()&#123; int n,i,ans,tag,maxx; while(~scanf(\"%d\",&amp;n)) &#123; ans=tag=0; maxx=-1; for(i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;x[i]); maxx=max(maxx,x[i]); &#125; init(maxx); SG(maxx); for(i=0;i&lt;n;i++) &#123; ans^=sg[x[i]]; tag+=(sg[x[i]]&gt;1); &#125; if(tag) ans?puts(\"tokitsukaze\"):puts(\"yukikaze\"); else ans?puts(\"yukikaze\"):puts(\"tokitsukaze\"); &#125; return 0;&#125;","path":"2018/06/15/NIT443/","date":"06-15","excerpt":""},{"title":"(转)【博弈】Anti,Multi,Every-SG","text":"原文：http://blog.sina.com.cn/s/blog_51cea4040100h3l9.html 一、Anti-SG 定义：桌子上有N堆石子，游戏者轮流取石子。 每次只能从一堆中取出任意数目的石子，但不能不取。 取走最后一个石子者败。 因为要求是取走最后一个石子的人败，那么，想赢的人，肯定是想，我就要留一个石子让你去取。 所以，我们在考虑条件的时候，就要加上石子数是不是1这个条件了。当然，还有SG函数本身。 贾志豪发明的SJ定理（Sprague Grundy——Jia Zhihao）解决了这个问题。 SJ定理： 对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束。 先手必胜当且仅当：（1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；（2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。 我们提出定理里的两个限制：1、SG函数为不为0。2、有没有某单一游戏的SG函数大于1。 通过这两个限制，我们可以组合出4种情况： （1）SG==0，有某单一游戏的SG&gt;1。 （2）SG!=0，有某单一游戏的SG&gt;1。（必胜SJ） （3）SG==0，无某单一游戏的SG&gt;1。(必胜SJ) （4）SG!=0，无某单一游戏的SG&gt;1。 对于情况（1）： 当SG==0，存在某单一游戏的SG&gt;1，因为SG==0，所以一定存在至少两个单一游戏的SG&gt;1。而一次操作只能改变一个单一游戏的SG值，那么，操作后，一定到情况（2）。所以情况（1）是先手必败。 对于情况（2）： 当SG!=0时，&lt;1&gt;若只有一个单一游戏的SG&gt;1，我们一定可以通过一次操作，使得剩下的单一游戏一共有奇数个1，这样就先手必胜。&lt;2&gt;若不只一个单一游戏的SG&gt;1，我们可以通过一次操作，使得情况变为SG==0，有某单一游戏的SG&gt;1。对于情况（2）来说，都有子状态是必败状态，所以，情况（2）是先手必胜。 对于情况（3）： 当SG==0，并且没有一单一游戏的SG&gt;1，说明这里只存在偶数个1。如果1的个数为0，则先手必胜。如果1个个数大于0，说明一共有偶数个1，依然是先手必胜。 对于情况（4）： 当SG!=0，无某单一游戏的SG&gt;1，说明现在有奇数个SG==1，操作有两种。 &lt;1&gt;将某一单一游戏的SG值变成大于1，转移后SG依然不等于0，且有一个单一游戏的SG&gt;1，这就到了情况（2）。 &lt;2&gt;将一个SG==1的转移为SG==0，这样就到了情况（3）。 所以情况（4）下是先手必败。 二、Multi-SG 定义：Multi-SG游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。 Multi-SG其他规则与SG游戏相同。 关于这个，如果ccy没理解错，就相当于POI1999/2000的Stripes那题。 http://blog.sina.com.cn/s/blog_51cea4040100h37e.html 三、Every-SG 定义：Every-SG 游戏规定，对于还没有结束的单一游戏，游戏者必须对该游戏进行一步决策。 Every-SG 游戏的其他规则与普通SG 游戏相同。 这种类型，可以想成这样，有N组游戏，有N个穿红色衣服的人代表先手，有N个穿蓝色衣服的人代表后手，这个时候，编号相同的人和游戏分到一组游戏，既第i号穿红色衣服人和第i号穿蓝色衣服的人做第i个游戏。游戏开始后，首先所有穿红衣服的人先操作，然后所有穿蓝色衣服的人再操作，这样轮流下去。直到最后还没游戏完的一组，这组如果是红色衣服的人胜利，那么该游戏先手必胜，如果是蓝色衣服的人胜利，就是先手必败。 很明显，Every-SG不仅仅像其他SG那样仅仅跟SG值有关，还与一个游戏的时间长度有关。 如果先手想赢，那么，在做先手必胜的单一游戏时，他肯定是想把战线尽量拉长。在做先手必败的单一游戏时，他肯定是想把游戏尽快结束。 于是我们开一个Step数组。 表示对于先手必胜的单一游戏而言，它最少走好多步胜利。对于先手必败的单一游戏而言，它最多走好多步。 这样，我们只需要看最后所有单一游戏最大的step那组的SG是0还是非0就可以断定是否先手必胜了。 很容易得出： （u是v的子状态） step[v] = 0； （v为终止状态） step[v] = max{step[u]} + 1； （sg[v]&gt;0,sg[u]=0） step[v] = min{step[u]} + 1； （sg[v]==0） 现在需要证明两个东西： （1）先手必胜，step表示的是最少走好多步。 （2）先手必败，step表示的是最多走好多步。 证明（1）： 对于v点，先手必胜。先手总是从sg&gt;1的到sg==0，他可以保证自己每次减少的步数为1。对手每次是从sg==0到sg&gt;1，最少将步数减小1，既对方走的min值所取的结点，如果选其他的，步数反而到那步后还要增加。所以，先手必胜，step表示的是最少走好多步。 （反起想，这也是为什么step第三个递推式是用min的原因。） 证明（2）： 对于v点，先手必败。先手总是从sg==0到sg&gt;1，他可以保证自己每次减少的步数为1。对手每次是从sg&gt;1到sg==0，对手肯定想让战线拉长，那么他只让步数减少1.所以，先手必败，step表示的是最多走好多步。 这里，式子的推导和证明柔和起来看更有利于理解。 值得注意理解的是，这里的最多和最少并不是绝对的最多最少。 对于（1）（2）而言，都是先手保证自己的操作后，看对手操作而决定最多最少。 而这里的最多最少正好等于step也是我们强制先手每次只减少步数1而得来的。 不过，我们是先手嘛，当然可以多个脑壳决定自己了！！！ 贾志豪在证Every-SG时，多证明了一条，就是最大的step为奇数时必胜。 ccy觉得这个虽然好证明，但是何必呢？最多step的那个单一游戏判断下它的SG是不是为0不就可以了吗？ 关于step为奇这个，也说一下。 最终状态，sg[v]==0，step[v]==0，为偶。 每个sg[v]!=0的step是由sg[u]==0的step[u]加上1得到，所以为奇。 每个sg[v]==0的step是由下面sg[u]!=0的step[u]加上1得到，所以为偶。 所以，sg[v]!=0的，step为奇。","path":"2018/06/15/(转)【博弈】Anti,Multi,Every-SG/","date":"06-15","excerpt":""},{"title":"NIT 458 Strictly Increasing Subinterval (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=458 Strictly Increasing Subinterval 给你一个长度为n的序列a，你需要计算严格递增子区间的个数。 Input第一行包括一个正整数T，表示案例个数。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 接下来一行包括n个正整数a[i]，(1≤a[i]≤10^5)。 Output对于每个案例，输出一行，表示答案。 Sample Input261 2 3 4 3 561 2 3 3 2 1 Sample Output139 Hint第一个案例满足题意的区间有：区间长度为1的区间有6个：[1,1]，[2,2]，[3,3]，[4,4]，[5,5]，[6,6]。 区间长度为2的区间有4个：[1,2]，[2,3]，[3,4]，[5,6]。 区间长度为3的区间有2个：[1,3]，[2,4]。 区间长度为4的区间有1个：[1,4]。 所以答案为13。 Source2017级新生选拔#5 Authortokitsukaze 题解：把原序列分成若干个连续的严格递增序列，并要求这些序列是最长的。然后对于每个序列分开计算贡献，最后加起来即为答案。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int n,i,x,now,pre,t; ll ans; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); ans=0; pre=-1; now=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); if(x&gt;pre) now++; else now=1; pre=x; ans+=now; // cout&lt;&lt;now&lt;&lt;endl; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/15/NIT458/","date":"06-15","excerpt":""},{"title":"NIT 445 Length (模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=445 Length 狗风给你一个数字x，希望你告诉她，这个数字转换成二进制后有多长。 Input多组数据。 对于每组数据，第一行包括一个整数x(0≤x≤10^18)。 Output对于每组数据，输出一行，表示答案。 Sample Input411 Sample Output34 Hint4转换成二进制变为100，所以长度为3。11转换成二进制变为1101，所以长度为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可，注意特判x=0的情况。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=5e5+10;const ll mod=1e9+7;int main()&#123; ll x,ans; while(~scanf(\"%lld\",&amp;x)) &#123; assert(x&gt;=0&amp;&amp;x&lt;=1000000000000000000LL); if(x==0) &#123; puts(\"1\"); continue; &#125; ans=0; while(x) &#123; x&gt;&gt;=1; ans++; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/15/NIT445/","date":"06-15","excerpt":""},{"title":"NIT 446 合法序列 (思维)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=446 合法序列 给你一个长度为n的序列A，和一个整数k。如果序列满足条件：abs(Ai-Ai+1)≤k，1≤i＜n，则我们称之为合法序列。现在你可以选择任意两个元素，交换它们，这个操作只能使用一次。请问能不能使原序列变为合法序列。 Input多组数据。 对于每组数据： 第一行包括两个整数n，k (2≤n≤10^5，0≤k≤10^9)。 接下来一行包括n个整数Ai(0≤Ai≤10^9)。 Output对于每个案例，输出一行。 如果原序列已经是合法序列，请输出0。 如果原序列不能变为合法序列，请输出-1。 如果能，请输出交换的两个数的下标(下标从1开始)，输出任意一组可行解即可。 Sample Input4 11 3 2 47 31 2 10 4 7 5 84 21 2 3 44 40 5 10 15 Sample Output1 43 60-1 Hint对于第一个案例，输出1 4或者4 1或者2 3或者3 2都可以。 Source2017级新生选拔#4 Authortokitsukaze 题解： 记录序列中不满足abs(Ai-Ai+1)≤k的位置。如果这样的位置个数&gt;6，答案就是-1。如果这样的位置个数=0，答案就是0。然后枚举每个位置上的数与其他位置上的数交换，check可行性。复杂度O(n)。 原题&amp;官方题解：https://csacademy.com/contest/archive/task/bounded-difference/solution/ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int x[MAX],n,k;int check(int i)&#123; int res=0; if(i&gt;1) &#123; if(abs(x[i]-x[i-1])&gt;k) res|=1; &#125; if(i&lt;n) &#123; if(abs(x[i]-x[i+1])&gt;k) res|=1; &#125; return res;&#125;int main()&#123; int i,j,c,it; while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; assert(n&lt;=100000); assert(n&gt;=2); assert(k&gt;=0); assert(k&lt;=1000000000); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x[i]); assert(x[i]&gt;=0); assert(x[i]&lt;=1000000000); &#125; vector&lt;int&gt; res; for(i=1;i&lt;=n;i++) &#123; if(check(i)) res.pb(i); &#125; if(sz(res)==0) puts(\"0\"); else if(sz(res)&gt;6) puts(\"-1\"); else &#123; for(i=0;i&lt;sz(res);i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(res[i]==j) continue; swap(x[j],x[res[i]]); c=0; c|=check(j); for(it=0;it&lt;sz(res);it++) &#123; c|=check(res[it]); &#125; if(!c) &#123; printf(\"%d %d\\n\",j,res[i]); goto end; &#125; swap(x[j],x[res[i]]); &#125; &#125; puts(\"-1\"); end:; &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT446/","date":"06-15","excerpt":""},{"title":"NIT 447 XOR and MAX (01字典树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=447 XOR and MAX 题意很简单。给你一个长度为n的序列，和q次操作。 总共有两种操作： MODIFY x y：将x位置的值改变成y。 QUERY v：把序列中的每个元素都与v异或，并输出操作后序列中的最大值。 Input第一行包括一个正整数T(T&lt;=10)，表示案例个数。 对于每个案例，第一行包括两个正整数n(1≤n≤10^5)，q(1≤q≤10^5)。 接下来一行是n个非负整数a[i] (0≤a[i]≤10^5)。 接下来有q行，每一行包括一个操作。 MODIFY x y：(1≤x≤n)，(0≤y≤10^5) QUERY v：(0≤v≤10^5) Output对于操作“QUERY”，请输出答案。 Sample Input14 31 2 3 4QUERY 5MODIFY 1 6QUERY 7 Sample Output76 Hint原序列为 1 2 3 4 对于第一次操作，序列变为4 7 6 1，所以最大值是7。 对于第二次操作，序列变为 6 7 6 1 对于第三次操作，序列变为1 0 1 6，所以最大值是6。 Source2017级新生选拔#4 Authortokitsukaze 题解： 对原序列建一棵01字典树。变量now表示原始序列每个数异或now为当前序列。 对于修改操作，先把原始那个数从字典树里删掉，然后往字典树里插入now^y，因为now^y^now=y 对于查询操作，先now^=x，然后查询字典树中与now异或的最大值maxx，那么ans=now^maxx。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct Trie&#123; int cnt[18*MAX],val[18*MAX]; void Insert(int x,int pos,int v) &#123; if(pos&lt;0) &#123; cnt[x]++; val[x]=v; return; &#125; Insert((x&lt;&lt;1)|((v&gt;&gt;pos)&amp;1),pos-1,v); cnt[x]=cnt[x&lt;&lt;1]+cnt[x&lt;&lt;1|1]; &#125; void Delete(int x,int pos,int v) &#123; if(pos&lt;0) &#123; cnt[x]--; return; &#125; Delete((x&lt;&lt;1)|((v&gt;&gt;pos)&amp;1),pos-1,v); cnt[x]=cnt[x&lt;&lt;1]+cnt[x&lt;&lt;1|1]; &#125; void clear(int x,int pos) &#123; cnt[x]=0; if(pos&lt;0) return; clear(x&lt;&lt;1,pos-1); clear(x&lt;&lt;1|1,pos-1); &#125; int query(int x,int pos,int v) &#123; if(pos&lt;0) return val[x]; int temp=(v&gt;&gt;pos)&amp;1; temp|=x&lt;&lt;1; if(cnt[temp^1]) return query(temp^1,pos-1,v); return query(temp,pos-1,v); &#125;&#125;Trie;int a[MAX];int main()&#123; int t,i,x,y,n,q,now; char op[12]; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;q); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); Trie.Insert(1,17,a[i]); &#125; now=0; while(q--) &#123; scanf(\"%s\",op); if(op[0]=='M') &#123; scanf(\"%d%d\",&amp;x,&amp;y); Trie.Delete(1,17,a[x]); a[x]=now^y; Trie.Insert(1,17,a[x]); &#125; else &#123; scanf(\"%d\",&amp;x); now^=x; printf(\"%d\\n\",now^Trie.query(1,17,now)); &#125; &#125; Trie.clear(1,17); &#125; return 0;&#125;","path":"2018/06/15/NIT447/","date":"06-15","excerpt":""},{"title":"hexo 文章中插入图片","text":"1.把博客根目录配置文件_config.yml里的post_asset_folder:这个选项设置为true 2.在你的博客根目录下执行这样一句话npm install hexo-asset-image --save 3.等待一小段时间后，再运行hexo n \"xxxx\"来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4.最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![xxxx](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。xxxx和图片名最好用英文，不要有空格。","path":"2018/06/15/hexo 文章中插入图片/","date":"06-15","excerpt":""},{"title":"NIT 448 逆序数 (树状数组)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=448 逆序数 狗风给你一个长度为n的序列，这个序列是1到n的一种排列。然后狗风会进行q次操作。每次操作会给你L R k这三个数，表示区间[L,R]往右移动k次。移动一次的定义是：一个数的位置是P(L≤P≤R-1)，它往右移动后就会在P+1这个位置上；如果一个数在R这个位置，它会移动到L这个位置。在每次操作结束后，狗风想让你算出现在这个序列的逆序数的多少，简单起见，你只需要告诉狗风现在这个序列的逆序数是奇数还是偶数就行了。 提示：序列的逆序数指的是：a[i]&gt;aj，满足条件的(i,j)的个数。 Input第一行包括一个正整数T(T≤5)，表示案例个数。 对于每个案例： 第一行包括一个正整数n(1≤n≤50000)。 接下来一行，包括一个长度为n的序列，序列为1到n的一种排列。 第三行包括一个正整数q(1≤q≤50000)。 接下来q行，每行包括三个正整数L,R,k(1≤L≤R≤n，1≤k≤n)。 所有变量的含义题面均有给出。 Output在每次操作后，逆序数如果是奇数，就输出1，如果是偶数，就输出0。 Sample Input142 3 1 431 3 22 4 12 3 1 Sample Output001 Hint对于第一个案例： 原序列为：2 3 1 4 第一次操作后，序列变为：3 1 2 4，逆序数为2，所以答案为0。 第二次操作后，序列变为：3 4 1 2，逆序数为4，所以答案为0。 第三次操作后，序列变为：3 1 4 2，逆序数为3，所以答案为1。 Source2017级新生选拔#4 Authortokitsukaze 题解：先树状数组求逆序数，然后有个结论。 结论：1到n的排列，任意交换两个数，逆序数奇偶性发生改变。 所以ans=（操作前的序列的逆序数+需要交换多少次才能变成操作后的序列（不需要求最小操作次数））%2。 结论的证明：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=5e4+10;const ll mod=1e9+7;int bit[MAX],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int v)&#123; while(x&lt;=n) &#123; bit[x]+=v; x+=lowbit(x); &#125;&#125;int getsum(int x)&#123; int res=0; while(x) &#123; res+=bit[x]; x-=lowbit(x); &#125; return res;&#125;int a[MAX];int main()&#123;// freopen(\"in.txt\",\"r\",stdin);// freopen(\"out.txt\",\"w\",stdout); int t,i,ans,q,l,r,k,len; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); mem(bit,0); ans=0; for(i=n;i&gt;=1;i--) &#123; ans+=getsum(a[i]); update(a[i],1); &#125; ans%=2; scanf(\"%d\",&amp;q); while(q--) &#123; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k); len=r-l+1; k%=len; ans+=(len-1)*k; ans%=2; printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT448/","date":"06-15","excerpt":""},{"title":"NIT 449 帅气的ES(改) (STL/线段树/主席树)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=449 帅气的ES(改) 前略 现在ES又有骚操作，他有长度为N的数列，每次他会查询一段区间的和，以及区间内有多少个值 等于 V。 后略 Input输入多组数据，对于每组数据：第一行输入两个整数N，M，M代表有M个询问(1&lt;=N,M&lt;=100000) 。 接下来一行有N个数a[i]，1&lt;=a[i]&lt;=10000000。 接下来M行，每行输入三个整数，L，R，V，代表询问的区间为[L, R]，值是V，1&lt;=L&lt;=R&lt;=N,1&lt;=V&lt;=10000000注：对于N=100000，M=100000，数据有10组。 Output对于每组数据：对于每个询问，输出两个数，第一个数代表区间[L, R]有多少个值等于V，第二个数代表区间[L, R]的和。 Sample Input5 31 1 3 4 41 3 12 4 41 5 1 Sample Output2 51 82 13 Source2017级新生选拔#4 Authortokitsukaze 题解： 因为没有修改，区间和可以用前缀和解决。对于查询区间有多少个数值等于V，有很多种做法。 我的做法（没输入输出外挂，1700+ms）：离散化一下，建n棵动态开点线段树，每次查询直接查V所在的那棵线段树即可。 比较快的做法：开个map&lt;int,vector&lt;int&gt; &gt;，vector里存的是每一种值的下标，查询直接二分vector。 比较慢的做法：主席树(好像能过)，分块(TLE)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;struct Segment_Tree&#123; int tot,ls[MAX*24],rs[MAX*24],v[MAX*24],ql,qr,qv; void init() &#123; ls[0]=rs[0]=0; v[0]=0; tot=1; &#125; int newnode() &#123; ls[tot]=rs[tot]=0; v[tot]=0; return tot++; &#125; void pushup(int id) &#123; v[id]=v[ls[id]]+v[rs[id]]; &#125; void insert(int l,int r,int &amp;id,int pos) &#123; int mid; if(!id) id=newnode(); if(l==r) &#123; v[id]++; return; &#125; mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(l,mid,ls[id],pos); else if(pos&gt;=mid+1) insert(mid+1,r,rs[id],pos); pushup(id); &#125; int query(int l,int r,int id) &#123; int res=0; if(l&gt;=ql&amp;&amp;r&lt;=qr) return v[id]; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res+=query(l,mid,ls[id]); if(qr&gt;mid) res+=query(mid+1,r,rs[id]); return res; &#125;&#125;tr;ll bit[MAX];int main()&#123; int n,q,i,x; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; bit[0]=0; map&lt;int,int&gt; root; tr.init(); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); if(!root.count(x)) root[x]=0; tr.insert(1,n,root[x],i); bit[i]=x; bit[i]+=bit[i-1]; &#125; while(q--) &#123; scanf(\"%d%d%d\",&amp;tr.ql,&amp;tr.qr,&amp;x); printf(\"%d %lld\\n\",tr.query(1,n,root[x]),bit[tr.qr]-bit[tr.ql-1]); &#125; &#125; return 0;&#125;","path":"2018/06/15/NIT449/","date":"06-15","excerpt":""},{"title":"NIT 450 极致色彩 (枚举)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=450 极致色彩 狗风要在一个n*n的棋盘里摆放放棋子。有a个红色的棋子和b个蓝色的棋子，要求任意两个相同颜色的棋子不相邻，允许有空的格子。狗风想知道棋盘的边长n至少多大，才能摆放完a个红色的棋子和b个蓝色的棋子。 Input多组案例。 第一行包括两个整数a,b(0≤a,b≤10^9)，a和b至少有一个不为零。 Output对于每个案例，输出一个正整数，表示答案。 Sample Input4 50 6 Sample Output34 Hint第一个案例，我们只能这样摆： 蓝红蓝 红蓝红 蓝红蓝 第二个案例，我们可以这样摆： 蓝空蓝空 空蓝空蓝 蓝空蓝空 空空空空 Source2017级新生选拔#4 Authortokitsukaze 题解： 枚举答案，check可行性。复杂度O(sqrt(a+b))。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;int a,b;int main()&#123; ll i,now; while(~scanf(\"%d%d\",&amp;a,&amp;b)) &#123; assert(a||b); for(i=1;;i++) &#123; now=i*(i/2); if(i&amp;1) now+=(i+1)/2; if(now&gt;=max(a,b)&amp;&amp;i*i&gt;=a+b) &#123; printf(\"%lld\\n\",i); break; &#125; &#125; &#125; return 0;&#125;/*4 50 6*/","path":"2018/06/15/NIT450/","date":"06-15","excerpt":""},{"title":"NIT 451 等差序列 (FFT计数)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=451 等差序列 给你一个长度为n的序列a，你的任务是找到有多少种不同的三元组(i,j,k)，(i,j,k互不相等)，使得a[i]，a[j]，a[k]，为等差序列。 注意：(i,j,k)，(i,k,j)，(j,i,k)，(j,k,i)，(k,i,j)，(k,j,i)视为同一种方案。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)。 第二行包括n个正整数ai。 Output对于每组数据，输出一行，表示答案，答案对10^9+7取模。 Sample Input51 2 3 3 332 1 341 1 1 1366 666 666611 Sample Output41400 Hint第一个案例：(1,2,3),(1,2,4),(1,2,5),(3,4,5)。所以答案为4。 第二个案例：(2,1,3)。所以答案为1。 第三个案例：(1,2,3),(1,2,4),(1,3,4),(2,3,4)。所以答案为4。 Source2017级新生选拔#4 Authortokitsukaze 题解：FFT计数，与hdu 4609做法类似。注意如果在做FFT时取模，去重时除法要逆元。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) (int)x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-8;const int MAX=1e5+10;const ll mod=1e9+7;namespace FFT&#123; #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) const double pi=acos(-1); const int p=1e9+7; const int maxn=(1&lt;&lt;18)+10; struct cp &#123; double a,b; cp()&#123;&#125; cp(double _x,double _y)&#123;a=_x,b=_y;&#125; cp operator +(const cp &amp;o)const&#123;return (cp)&#123;a+o.a,b+o.b&#125;;&#125; cp operator -(const cp &amp;o)const&#123;return (cp)&#123;a-o.a,b-o.b&#125;;&#125; cp operator *(const cp &amp;o)const&#123;return (cp)&#123;a*o.a-b*o.b,b*o.a+a*o.b&#125;;&#125; cp operator *(const double &amp;o)const&#123;return (cp)&#123;a*o,b*o&#125;;&#125; cp operator !()const&#123;return (cp)&#123;a,-b&#125;;&#125; &#125;x[maxn],y[maxn],z[maxn],w[maxn]; void fft(cp x[],int k,int v) &#123; int i,j,l; for(i=0,j=0;i&lt;k;i++) &#123; if(i&gt;j)swap(x[i],x[j]); for(l=k&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; w[0]=(cp)&#123;1,0&#125;; for(i=2;i&lt;=k;i&lt;&lt;=1) &#123; cp g=(cp)&#123;cos(2*pi/i),(v?-1:1)*sin(2*pi/i)&#125;; for(j=(i&gt;&gt;1);j&gt;=0;j-=2)w[j]=w[j&gt;&gt;1]; for(j=1;j&lt;i&gt;&gt;1;j+=2)w[j]=w[j-1]*g; for(j=0;j&lt;k;j+=i) &#123; cp *a=x+j,*b=a+(i&gt;&gt;1); for(l=0;l&lt;i&gt;&gt;1;l++) &#123; cp o=b[l]*w[l]; b[l]=a[l]-o; a[l]=a[l]+o; &#125; &#125; &#125; if(v)for(i=0;i&lt;k;i++)x[i]=(cp)&#123;x[i].a/k,x[i].b/k&#125;; &#125; void mul(ll *a,ll *b,ll *c,int l1,int l2) &#123; if(l1&lt;128&amp;&amp;l2&lt;128) &#123; rep(i,0,l1+l2)a[i]=0; rep(i,0,l1)rep(j,0,l2)a[i+j]+=b[i]*c[j]%p; rep(i,0,l1+l2)a[i]%=p; return; &#125; int K; for(K=1;K&lt;=l1+l2;K&lt;&lt;=1); rep(i,0,l1)x[i]=cp(b[i],0); rep(i,0,l2)y[i]=cp(c[i],0); rep(i,l1+1,K)x[i]=cp(0,0); rep(i,l2+1,K)y[i]=cp(0,0); fft(x,K,0);fft(y,K,0); rep(i,0,K)z[i]=x[i]*y[i]; fft(z,K,1); rep(i,0,l1+l2)a[i]=((ll)(z[i].a+0.5))%p; &#125;&#125;;ll fac[MAX];void init(int n)&#123; ll i; fac[0]=1; for(i=1;i&lt;=n;i++) &#123; fac[i]=fac[i-1]*i%mod; &#125;&#125;ll pow2(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;ll inv(ll x)&#123; return pow2(x,mod-2);&#125;ll C(int n,int m)&#123; if(m&gt;n||m&lt;0) return 0; return fac[n]*inv(fac[m]*fac[n-m]%mod)%mod;&#125;ll cnt[MAX],res[MAX&lt;&lt;1];int main()&#123; int n,i,x,maxx,cas; ll ans; char s[111]; init(1e5); ll inv2=inv(2); while(~scanf(\"%d\",&amp;n)) &#123; assert(n&gt;=1); assert(n&lt;=MAX-10); mem(cnt,0); maxx=0; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); assert(x&gt;=1); assert(x&lt;=MAX-10); cnt[x]++; maxx=max(maxx,x); &#125; FFT::mul(res,cnt,cnt,maxx,maxx); ans=0; maxx&lt;&lt;=1; for(i=2;i&lt;=maxx;i+=2) &#123; if(!res[i]) continue; res[i]-=cnt[i/2]; res[i]=(res[i]+mod)%mod; res[i]=res[i]*inv2%mod; res[i]-=cnt[i/2]*(cnt[i/2]-1)/2; res[i]=(res[i]+mod)%mod; ans+=res[i]*cnt[i/2]; ans%=mod; ans+=C(cnt[i/2],3); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"2018/06/14/NIT451/","date":"06-14","excerpt":""},{"title":"NIT 452 Thue–Morse 序列 (模拟)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=452 Thue–Morse 序列 这是一个有趣的二进制序列。F[0]=0，F[1]=01，F[2]=0110，F[3]=01101001，F[4]=0110100110010110…观察可知，这个序列的第n项是由第n-1项与第n-1项按位取反后得到的序列拼接而成。现在狗风得到了第x项的序列(x为正无穷)，她想知道这个序列的前n个字符是什么。 Input第一行包括一个正整数T(T≤1000)，表示T个案例。 对于每个案例，第一行包括一个正整数n(1≤n≤10^5)。 Output对于每个案例，输出一行长度为n的01串。 Sample Input61234532 Sample Output00101101100110101101001100101101001011001101001 Source2017级新生选拔#4 Authortokitsukaze 题解：直接模拟即可。这里提供一个非常规写法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#pragma comment(linker, \"/STACK:1024000000,1024000000\")#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;int main()&#123; int t,n; string s=\"\"; for(int i=0;i&lt;100000;i++) s+='0'+__builtin_popcount(i)%2; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); cout&lt;&lt;s.substr(0,n)&lt;&lt;\"\\n\"; &#125; return 0;&#125;","path":"2018/06/14/NIT452/","date":"06-14","excerpt":""},{"title":"NIT 453 相似字符串 (hash)","text":"转载请注明出处：http://tokitsukaze.live/ 题目链接：https://www.nitacm.com/problem_show.php?pid=453 相似字符串 狗风获得了一个长度为n，由a-z小写字母组成的字符串。 我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。 操作是这样的：选择一个字符串，把字符串的每个字母都+1(例如‘a’变成‘b’，’z’变成’a’)。比如选择“acdz”，操作一次后变为“bdea”。 现在狗风从字符串中任取两个子串，狗风想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。 Input多组数据。 对于每组数据，第一行包括一个正整数n(1≤n≤10^5)，表示字符串长度。 第二行包括一个长度为n的字符串。 接下来一行包括一个正整数q(1≤q≤10^5)，表示询问次数。 接下来q行，每行包括3个正整数x，y，len。(1≤x，y≤n)，(1≤len≤n并且1≤x+len-1，y+len-1≤n)。表示查询子串[x…x+len-1]和子串[y…y+len-1]。 n=10^5，q=10^5的数据大约有10组。 Output对于每个查询，输出一行，表示答案。 Sample Input10aabbcdedcz41 3 22 6 24 6 41 10 1 Sample Output13-11 Hint第一个查询的子串为“aa”和“bb”，“aa”变为“bb”需要1次操作，所以相似度为1。 第二个查询的子串为“ab”和“de”，“ab”变为“de”需要3次操作，所以相似度为3。 第三个查询的子串为“bcde”和“dedc”，“bcde”不能变为“dedc”，所以两个字符串不相似，输出-1。 第四个查询的子串为“a”和“z”，“z”变为“a”需要1次操作，所以相似度为1。 Source2017级新生选拔#4 Authortokitsukaze 题解： 预处理：对这个字符串的26种变化做hash。 查询：用差分的方式取出y子串的hash值，然后取出x子串26种变化的hash值，判断有没有一种变化能使x子串的hash值等于y子串的hash值，如果有，假设是第i种变化，那么答案就是min(i,26-i)，如果没有，答案就是-1。 代码： 这里给出双hash的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#define mem(a,b) memset((a),(b),sizeof(a))#define MP make_pair#define pb push_back#define fi first#define se second#define sz(x) x.size()#define all(x) x.begin(),x.end()using namespace std;#define _GLIBCXX_PERMIT_BACKWARD_HASH#include &lt;ext/hash_map&gt;using namespace __gnu_cxx;struct str_hash&#123;size_t operator()(const string&amp; str)const&#123;return __stl_hash_string(str.c_str());&#125;&#125;;typedef long long ll;typedef unsigned long long ull;#define PII pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define PDD pair&lt;double,double&gt;const int INF=0x3f3f3f3f;const ll LLINF=0x3f3f3f3f3f3f3f3f;const double PI=acos(-1.0);const double eps=1e-6;const int MAX=1e5+10;const ll mod=1e9+7;struct hash_table&#123; ll seed,p; ll Hash[26][MAX],tmp[MAX]; void set(ll _seed,ll _p) &#123; seed=_seed; p=_p; &#125; void work(char *s,int n) &#123; ll i,j; tmp[0]=1; for(i=1;i&lt;=n;i++) tmp[i]=tmp[i-1]*seed%p; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;26;j++) &#123; Hash[j][i]=(Hash[j][i-1]*seed%p+(s[i]-&apos;a&apos;+j)%26)%p; &#125; &#125; &#125; ll get(int l,int r,int id) &#123; return (Hash[id][r]-Hash[id][l-1]*tmp[r-l+1]%p+p)%p; &#125;&#125;ha[2];char s[MAX];int main()&#123; int n,i,q,x,y,len,ans; ll tmp; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; assert(n&gt;=1&amp;&amp;n&lt;=100000); scanf(&quot; %[a-z]&quot;,s+1); assert(strlen(s+1)==n); ha[0].set(233333,1e9+7); ha[1].set(19260817,998244353); for(i=0;i&lt;2;i++) ha[i].work(s,n); scanf(&quot;%d&quot;,&amp;q); assert(q&gt;=1&amp;&amp;q&lt;=100000); while(q--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); assert(len&gt;=1); assert(x&gt;=1&amp;&amp;x+len-1&lt;=n); assert(y&gt;=1&amp;&amp;y+len-1&lt;=n); vector&lt;int&gt; res; ans=INF; tmp=ha[0].get(y,y+len-1,0); for(i=0;i&lt;26;i++) if(ha[0].get(x,x+len-1,i)==tmp) res.pb(i); tmp=ha[1].get(y,y+len-1,0); for(i=0;i&lt;sz(res);i++) &#123; if(ha[1].get(x,x+len-1,res[i])==tmp) &#123; ans=min(ans,res[i]); ans=min(ans,26-res[i]); &#125; &#125; if(ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2018/06/14/NIT453/","date":"06-14","excerpt":""},{"title":"2018ICPC西安邀请赛","text":"转载请注明出处：http://tokitsukaze.live/ 西安公费旅游，住在乡下，住宿体验极差，水是黄的床是脏的马桶还能堵，再也不想来了....然后比赛，A题题目错的(知乎见.jpg)，E和A签完到，K看错题意拍上线段树wa，然后发现D是sg板子题，抄完板子1A，然后又发现G是几何，抄完板子1A(幸好没卡精度)，然后看榜发现在金牌区，而且C和K感觉都能过。然后两个队友yy了K的分块解法，一屁股坐上来就再也没下去过，最后wa还不知道哪写错了。期间我看完I感觉不好做，去看过的人多的C。然后贪心贪到封榜，怎么贪感觉都有反例，这时候我觉得肯定是dp，甩锅给队友，队友不接锅...结果赛后队友一眼秒了emmmmm终榜：http://acm.nwpu.edu.cn/static/frontpage/board/index.html..","path":"2018/05/20/2018ICPCxian/","date":"05-20","excerpt":""},{"title":"2018浙江省赛","text":"转载请注明出处：http://tokitsukaze.live/ 这省赛是打的最气的一次现场赛。开场1小时过完5个签到题，感觉顺的一逼。接着开了两个新题。我开的那道题很快就有了正解，然后一敲，TLE。仔细想想是n*log(n)^2的复杂度，肯定会TLE，于是一直在思考怎么抠掉一个log。zyf和chy开了一道dp(贪心)，一直在搞。然后讨论的差不多了(?)chy就开了个新题，是个构造题，没啥想法，扔了。期间我想不出怎么抠掉那个log，跟队友讲了一下思路，也都没啥想法，然后zyf那个题也是各种WA，于是就陷入僵局。然后chy开了一个大模拟，又是WA到死。因为我不怎么会dp，无法参与zyf的题，我也不会麻将()，无法参与chy的题，于是只能死磕我的题。所以接下来的场景就是，我坐上去改改，TLE，zfy上去改改，WA，chy上去改改，WA。然后就结束了。也就是说，开场过了5个签到后，3个人开始进入梦游状态，然后最后打铁了。 气的原因最主要是，回来一搜题解，发现全是n*log(n)^2的复杂度。几天后py了zoj的管理员，把现场赛我的TLE的代码贴出来，居然AC了！！！而且还是跑的飞快的那种，woc瞬间被气的半死，只能说可能zoj的数据比现场赛的数据弱。然后大概15天后突然想出怎么抠掉那个log...只能怪自己菜了。 直到这场，连着打了3个铁(CCPC杭州，ECL，浙江省赛)，心态略崩TAT。 榜：http://acm.zju.edu.cn/zjp2018/board/index.html?filter=type1","path":"2018/04/30/2018zhejiangshengsai/","date":"04-30","excerpt":""},{"title":"2017ICPC上海ECL-Final","text":"转载请注明出处：http://tokitsukaze.live/ 在杭州ccpc区域赛丢人后，这次又去上海ECL-final丢人了。换了个队友。第一天热身赛，编译器炸了一个多小时...体验极差。然后发的里面有80元的饭卡，吃了两餐剩50多，于是晚上去洗劫超市，提了一袋吃的回来...第二天正式赛，我从前往后读题，zyf从后往前，chy开编译器。A题排列组合，翻了一下数学手册，理论AC，上去打了一发假代码，贡献了一发罚时。这时候chy上来切掉了M。然后换我改了改A，过了。然后他们告诉我K读不懂，我接手K。他们L（是个博弈题）推了一波，打了一发，WA。这时候我看懂了K，想了想不就是二分一下前缀和，上来打了一发，超时，又贡献了一发罚时。这时候我发现我把n范围1e9看成了1e5，加了个条件break，过了。然后让我接手L，他们看J。我推了20分钟，放弃（博弈实在不行），他们J也陷入僵局。我看了一下榜，决定开B，让他们开C。然后我瞎打了一发B，没过案例，被chy抢走键盘，莽了一发C，WA。跟chy说了一下B，纠正了思路，我继续调B。然后案例过了，莽了一发，WA。这时候chy又莽来一发C，AC。这时已经快封榜了，我和chy继续搞B，zyf想J。最后半小时，chy改了改B，WA。换zyf打J，WA。又换chy改了改B，又WA，接着又换zyf改了改J，又WA。于是最后4题打铁。赛后题解，B大体思路对，不知道哪有问题。J最开始方向也是对的，但是没有细想很快就被枪毙掉了。L这个博弈，结论对了一半，要是暴力一发找规律，说不定能过。只能怪自己太菜（他们怎么都会啊...）。不过毕竟是final，虽然参赛队比较多，但牌也不是那么好拿的。然后就是，上海大学真tm有钱，还有这个狗牌也做的相当不错（甚至还能用来洗劫超市，emmmm）。PS:丢人丢到gym上了榜：http://codeforces.com/gym/101775/standings","path":"2017/12/17/2017ICPCshanghaiECL-Final/","date":"12-17","excerpt":""},{"title":"2017CCPC杭州赛区","text":"转载请注明出处：http://tokitsukaze.live/ 第一次区域赛，杭州赛区丢人打铁，被数学题按在地上摩擦。起手慢了，队友16分钟过了A，然后分别看BCD，过了一会儿系统提示J案例翻车要重判，看了一眼发现提交了一堆人，看了一下题，跟队友讨论了两分钟，我上去切了，在51分钟过了J。然后B要用到欧拉函数，我拍了个板子上去给队友找规律，D是随机构造树，随机一个节点求子树节点和的期望，直觉可做，就去看D。推了半小时D，上来打了10几分钟，在120分钟切了D，期间队友在讨论C，是个博弈。然后队友C写了个假算法wa了一发后接着推B，我接手C。C陷入僵局，看了眼K，直觉二分或者三分，但是有个式子不会处理，放弃K继续想C（赛后据说K是树状数组+二分答案）。然后继续陷入僵局。240分钟左右，B稍微有点成型，队友瞎敲一波，我帮忙debug。在280分钟过了案例，然后tle了..赛后出来交流了一波，思路没错，可惜没时间优化，最后3题首离铜线差6名...","path":"2017/11/05/2017CCPChangzhou/","date":"11-05","excerpt":""},{"title":"2017宁波市市赛","text":"转载请注明出处：http://tokitsukaze.live/ A忘longlong C忘特判n=1 Ewa几发 GwaN发 唯一一道1A的J bfs水过（我的首A 不！！.jgp） 然后最后翻车在F上 算了一下罚时好像就算A出来也拿不到银 （强行安慰） 保铜冲银 最终还是咸鱼...","path":"2017/05/13/2017ningboshisai/","date":"05-13","excerpt":""},{"title":"2017浙江大学校赛","text":"转载请注明出处：http://tokitsukaze.live/ 公费旅游+骗吃骗喝+日常翻车 1小时a掉2题 然后C题我的思路太繁琐了 强行分类讨论 打一半就不想打然后队友接盘 然后我去看G wa了一发发现思路不对 然后其他题又不是很好做 于是三个人就开始肛C 然后各种翻车...学了两个月算法结果在xjb搞的题上翻车..人生如此艰难.jpg","path":"2017/04/09/2017ZJUxiaosai/","date":"04-09","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2016/09/23/hello-world/","date":"09-23","excerpt":""}]}